#!/usr/bin/env perl
BEGIN { # START of fatpack xs
my %fatpack;
$fatpack{"5.20/darwin-2level/auto/Mouse/Mouse.bundle"} = <<'...';
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
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQVNMjR3X9f//QVP/Jc/lAAAPHwD/Jc7lAACQkJCQ
kJBVSInlSIs1fekAAOjALQAASIXAdCyLSAz2xf91Fg+20YP6CHQOgeH/wAABgfkKAAABdQ6+AgAA
AEiJx13psaQAAEiNDWSqAAAxwEiJz+g0pAAAZmZmZmYuDx+EAAAAAABVSInlQVdBVlNQTIs1z+UA
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
Sos8+UiNNcyIAAC6BwAAAOgRggAASI0Vw4gAALkGAAAAid9Eif7oAYIAAEiNPbSIAABIjTUX3P//
SI0di4gAAEiJ2ug2gQAASI09togAAEiNNerc//9IidroIIEAAEiNPcCIAABIjTV03v//SIna6AqB
AABIjT3NiAAASI01rt///0iJ2uj0gAAASI093ogAAEiNNdjk//9Iidro3oAAAEiNPeeIAABIjTWS
7f//SIna6MiAAABIjT39hgAASI01rO7//0iJ2uiygAAASI093IgAAEiNNcbw//9IidronIAAAEiN
PfaIAABMjT3Q8f//TIn+SIna6IOAAABIiwDHQCgCAAAASI09AIkAAEyJ/kiJ2uhngAAASIsAx0Ao
AQAAAEiNPRKJAABMif5IidroS4AAAEiLAMdAKAAAAABIjT0kiQAATIn+SIna6C+AAABIiwDHQCgA
AAAASI09L4kAAEyNPSnz//9Mif5IidroDIAAAEiLAMdAKAIAAABIjT06iQAATIn+SIna6PB/AABI
iwDHQCgBAAAASI09TYkAAEyJ/kiJ2ujUfwAASIsAx0AoAAAAAEiNPWCJAABMif5IidrouH8AAEiL
AMdAKAAAAABIjT1siQAASI01IvT//0iJ2uiYfwAASI09gIkAAEiNNRz1//9Iidrogn8AAEiNPX2J
AABMjT3G9///TIn+SIna6Gl/AABIiwDHQCgBAAAASI09dYkAAEyJ/kiJ2uhNfwAASYnHSYsHx0Ao
AAAAAEiNPW2JAABIjTX0+///SIna6Cp/AABIjT1wiQAASI01fvz//0iJ2ugUfwAASI09cokAAL4H
AAAAMdLo734AAEiJBfTCAABIjT1giQAAvgkAAAAx0ujVfgAASIkF8sIAAEiNPVCJAAC+BwAAADHS
6Lt+AABIiQXIwgAASI09PokAAL4EAAAAMdLooX4AAEiJBbbCAABIjT0piQAAvgYAAAAx0uiHfgAA
SIkFrMIAAEiNPRaJAAC+DQAAADHS6G1+AABIiQWawgAASI09CokAAL4SAAAAMdLoU34AAEiJBYjC
AABJiwQkSIPABEmJBCRIix21vgAASDsDD4SxAwAATInxSStNAEjB6QOJCEyJ/+hfewAASYsEJEiD
wARJiQQkSDsDD4SVAwAATInxSStNAEjB6QOJCEyJ/+gVWgAASYsEJEiDwARJiQQkSDsDD4R5AwAA
TInxSStNAEjB6QOJCEyJ/+irHgAASYsEJEiDwARJiQQkSDsDD4RdAwAATSt1AEnB7gNEiTBMif/o
UzkAAEiNPVaIAABIjTUIiAAATI01jhAAALoHAAAARTHARTHJTInx6JsPAABIjT1IiAAASI018ocA
ALoHAAAARTHARTHJTInx6HoPAABIjT1IiAAASI01ZYgAALoKAAAARTHARTHJTInx6FkPAABIjT1W
iAAASI01aYgAALoFAAAARTHARTHJTInx6DgPAABIjT1ViAAASI01cIgAAEiNDXMTAAC6DgAAAEUx
wEUxyegTDwAASI09YYgAAEiNNXuIAAC6DAAAAEUxwEUxyUyJ8ejyDgAASI09bogAAEiNNY6IAABI
jQ09FAAAuhIAAABFMcBFMcnozQ4AAEiNPbmIAAC+EwAAAOiMfAAASI09cogAAEiNNZCIAAC6EAAA
AEG5/v///0mJwEyJ8eiYDgAASI091IgAAL4WAAAA6Fd8AABIjT2HiAAASI01qIgAALoTAAAAQbn+
////SYnATInx6GMOAABIjT3uiAAAviQAAADoInwAAEiNPaWIAABIjTXEiAAAuhEAAABBuf7///9J
icBMifHoLg4AAEiNPRSJAAC+IwAAAOjtewAASI09zYgAAEiNNeuIAAC6EAAAAEG5/v///0mJwEyJ
8ej5DQAASI09A4kAAEyNJYsBAABMjS0fgwAATInmTInq6Md7AABJicdIjT2shQAAvhIAAAC6AQAA
AOjKegAASInH6Gp7AABJiw9IiUEoSI0994gAAEyJ5kyJ6uiNewAASInDSI09oIUAAL4WAAAAugEA
AADokHoAAEiJx+gwewAASIsLSIlBKEiNPfeIAAC6BQAAAEUxwEUxyUiNNXyGAABMifHoVg0AAEiN
PfOIAAC6DgAAAEUxwEUxyUiNNYOGAABIjQ2GEQAA6DENAABIjT0SiQAAvhkAAADo8HoAAEiNPd2I
AAC6EAAAAEG5/v///0iNNemGAABMifFJicDo/AwAAEiLBc27AABIizBIhfZ0DkiLBW67AACLOOin
eQAASIsFaLsAAEiJwkiLAkiLDYu7AABIi3XQSIkM8EjB5gNIAzJIiwVVuwAASIkwSIPECFtBXEFd
QV5BX13D6CZ6AABJiwQk6UH8///oGHoAAEmLBCTpXfz//+gKegAASYsEJOl5/P//6Px5AABJiwQk
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
hQAATIs1loUAAOsZTIs1jYUAAOsQTIs1hIUAAOsHTIs1e4UAAEiLBWSFAABIicFIiwFMiSzYSMHj
A0gDGUmJHkiDxAhbQVxBXUFeQV9dw+g0RAAASYsG6Uf///+6AQAAAEyJ50yJ5uisRAAASYnE6Vn/
//9IjQW9XQAASInG6GlDAABmZmZmLg8fhAAAAAAAVUiJ5UFXQVZBVUFUU1BIiwW7hAAASIsISI1R
/EiJEIsBSIsN2IQAAEiLCf/ATGPoSos86UiNNXxLAAC6BwAAAOjBRAAASI09algAAEiNNS3w//9I
jR1jXQAASIna6PxDAABIjT1sXQAASI01sP3//0iJ2ujmQwAASI09dl0AAEiNNVdOAABIjR3D1v//
ugQAAABFMcBFMclIidno0NX//0iNPWtdAABIjTWNXQAAuhAAAABFMcBFMclIidnor9X//0iNPYRd
AABIjTVmWQAAuggAAABFMcBFMclIidnojtX//0iNPYRdAABIjTU0WQAAugYAAABFMcBFMclIidno
bdX//0iNPYJdAABIjTUdWQAAugYAAABFMcBFMclIidnoTNX//0iNPYBdAABIjTXzWgAAugkAAABF
McBFMclIidnoK9X//0iNPYFdAABIjTXKWgAAugcAAABFMcBFMclIidnoCtX//0iNPYBdAABIjTWZ
XQAAugcAAABFMcBFMclIidno6dT//0iNPYddAABIjTWDWAAAugIAAABFMcBFMclIidnoyNT//0iN
PYtdAABIjTUDWAAAuggAAABFMcBFMclIidnop9T//0iNPY5dAABIjTU2WgAAugQAAABFMcBFMclI
idnohtT//0iNPY1dAABIjTXGWQAAugoAAABFMcBFMclIidnoZdT//0iNPZJdAABIjTVVWQAAuggA
AABFMcBFMclIidnoRNT//0iNPZVdAABIjTW3VgAAuggAAABFMcBFMclIidnoI9T//0iNPZVdAABI
jTWyWAAAug8AAABFMcBFMclIidnoAtT//0iNPZxdAABIjTXEUAAAugcAAABFMcBFMclIidno4dP/
/0iNPZtdAABIjTX3VQAAugcAAABFMcBFMclJifZIidnovdP//0iNPZddAABIjTWSWQAAugoAAABF
McBFMclIidnonNP//0iNPaBdAABIjTUATAAAugYAAABFMcBFMclIidnoe9P//0iNPaVdAABIjTXE
XQAAug0AAABFMcBFMclJifdIidnoV9P//0iNPbVdAABIjTXWXQAAug8AAABFMcBFMclIidnoNtP/
/0iNPcxdAABMjSV41///uggAAABFMcBFMclIjTXbVgAATInh6A7T//9IjT3JXQAAugYAAABFMcBF
MclIjTWpVgAATInh6O3S//9IjT3LXQAAugYAAABFMcBFMclIjTWSVgAATInh6MzS//9IjT3NXQAA
ugkAAABFMcBFMclIjTVoWAAATInh6KvS//9IjT3SXQAAugcAAABFMcBFMclIjTU/WAAATInh6IrS
//9IjT3VXQAAugcAAABFMcBFMclIjTUOWwAATInh6GnS//9IjT3YXQAASI01h1QAALoHAAAARTHA
RTHJTInh6EjS//9IjT3bXQAAug8AAABFMcBFMclIjTXMVgAATInh6CfS//9IjT3mXQAAugcAAABF
McBFMclIjTXeTgAATInh6AbS//9IjT3pXQAAugcAAABFMcBFMclMifZMieHo6dH//0iNPfBdAAC6
DQAAAEUxwEUxyUyJ/kyJ4ejM0f//SI09O14AAL4hAAAA6Is/AABIjT3sXQAASI01EF4AALoSAAAA
Qbn+////SYnASInZ6JfR//9IiwVogAAASIswSIX2dA5IiwUJgAAAizjoQj4AAEiLBQOAAABIicJI
iwJIiw0mgAAASokM6EnB5QNMAypIiwX0fwAATIkoSIPECFtBXEFdQV5BX13DkJBVSInlQVdBVkFV
QVRTSIPsKEmJ9EmJ/0mLRxBIiwBIjQ27AQAASDlIMA+E6AAAAEiLBap/AABIixjo/D4AAEyLNcN/
AABMiffoBT8AAEiLBbx/AABIiwBJiQZMizU/fwAASYsGSIPABEmJBkiLDSZ/AABIOwEPhC0BAABI
iw1OfwAASInaSCsRSMHqA4kQTIs1Q38AAEmLBkgp2EiD+AcPjhABAABMiWMISIPDCEyLJXyDAABN
heQPhIUAAABMiX3QSYsEJEyLaBBBjUUBhcB+dUH/xUUx/+sXugEAAABIid9Iid7obz4AAEiJw+sO
ZpBJiwZIKdhIg/gHft1Ji0QkEEqLBPhIiUMISIPDCEn/x0U5/XXb6y9Ii1goQfZEJA4gD4WmAAAA
SIt7IEiLQyhMieZIg8QoW0FcQV1BXkFfXf/gTIl90EiLBZN+AABJicdJiR++AgAAAEiLfdDouTwA
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
/yVaQgAA/yVcQgAA/yVeQgAA/yVgQgAA/yViQgAA/yVkQgAA/yVmQgAA/yVoQgAA/yVqQgAA/yVs
QgAA/yVuQgAA/yVwQgAA/yVyQgAA/yV0QgAA/yV2QgAA/yV4QgAA/yV6QgAA/yV8QgAA/yV+QgAA
/yWAQgAA/yWCQgAA/yWEQgAA/yWGQgAA/yWIQgAA/yWKQgAA/yWMQgAA/yWOQgAA/yWQQgAA/yWS
QgAA/yWUQgAA/yWWQgAA/yWYQgAA/yWaQgAA/yWcQgAA/yWeQgAA/yWgQgAA/yWiQgAA/yWkQgAA
/yWmQgAA/yWoQgAA/yWqQgAA/yWsQgAA/yWuQgAA/yWwQgAA/yWyQgAA/yW0QgAA/yW2QgAA/yW4
QgAA/yW6QgAA/yW8QgAA/yW+QgAA/yXAQgAA/yXCQgAA/yXEQgAA/yXGQgAA/yXIQgAA/yXKQgAA
/yXMQgAA/yXOQgAA/yXQQgAA/yXSQgAA/yXUQgAA/yXWQgAA/yXYQgAA/yXaQgAA/yXcQgAA/yXe
QgAA/yXgQgAA/yXiQgAA/yXkQgAA/yXmQgAA/yXoQgAA/yXqQgAA/yXsQgAA/yXuQgAA/yXwQgAA
/yXyQgAA/yX0QgAA/yX2QgAA/yX4QgAA/yX6QgAA/yX8QgAA/yX+QgAA/yUAQwAA/yUCQwAA/yUE
QwAA/yUGQwAAAABMjR0lQAAA6XhZ//9MjR0hQAAA6WxZ//9MjR0dQAAA6WBZ//9MjR0ZQAAA6VRZ
//9MjR0VQAAA6UhZ//9MjR0RQAAA6TxZ//9MjR0NQAAA6TBZ//9MjR0JQAAA6SRZ//9MjR0FQAAA
6RhZ//9MjR0BQAAA6QxZ//9MjR39PwAA6QBZ//9MjR35PwAA6fRY//9MjR31PwAA6ehY//9MjR3x
PwAA6dxY//9MjR3tPwAA6dBY//9MjR3pPwAA6cRY//9MjR3lPwAA6bhY//9MjR3hPwAA6axY//9M
jR3dPwAA6aBY//9MjR3ZPwAA6ZRY//9MjR3VPwAA6YhY//9MjR3RPwAA6XxY//9MjR3NPwAA6XBY
//9MjR3JPwAA6WRY//9MjR3FPwAA6VhY//9MjR3BPwAA6UxY//9MjR29PwAA6UBY//9MjR25PwAA
6TRY//9MjR21PwAA6ShY//9MjR2xPwAA6RxY//9MjR2tPwAA6RBY//9MjR2pPwAA6QRY//9MjR2l
PwAA6fhX//9MjR2hPwAA6exX//9MjR2dPwAA6eBX//9MjR2ZPwAA6dRX//9MjR2VPwAA6chX//9M
jR2RPwAA6bxX//9MjR2NPwAA6bBX//9MjR2JPwAA6aRX//9MjR2FPwAA6ZhX//9MjR2BPwAA6YxX
//9MjR19PwAA6YBX//9MjR15PwAA6XRX//9MjR11PwAA6WhX//9MjR1xPwAA6VxX//9MjR1tPwAA
6VBX//9MjR1pPwAA6URX//9MjR1lPwAA6ThX//9MjR1hPwAA6SxX//9MjR1dPwAA6SBX//9MjR1Z
PwAA6RRX//9MjR1VPwAA6QhX//9MjR1RPwAA6fxW//9MjR1NPwAA6fBW//9MjR1JPwAA6eRW//9M
jR1FPwAA6dhW//9MjR1BPwAA6cxW//9MjR09PwAA6cBW//9MjR05PwAA6bRW//9MjR01PwAA6ahW
//9MjR0xPwAA6ZxW//9MjR0tPwAA6ZBW//9MjR0pPwAA6YRW//9MjR0lPwAA6XhW//9MjR0hPwAA
6WxW//9MjR0dPwAA6WBW//9MjR0ZPwAA6VRW//9MjR0VPwAA6UhW//9MjR0RPwAA6TxW//9MjR0N
PwAA6TBW//9MjR0JPwAA6SRW//9MjR0FPwAA6RhW//9MjR0BPwAA6QxW//9MjR39PgAA6QBW//9M
jR35PgAA6fRV//9MjR31PgAA6ehV//9MjR3xPgAA6dxV//9MjR3tPgAA6dBV//9MjR3pPgAA6cRV
//9MjR3lPgAA6bhV//9MjR3hPgAA6axV//9MjR3dPgAA6aBV//9MjR3ZPgAA6ZRV//9MjR3VPgAA
6YhV//9MjR3RPgAA6XxV//9MjR3NPgAA6XBV//9MjR3JPgAA6WRV//9MjR3FPgAA6VhV//9MjR3B
PgAA6UxV//9MjR29PgAA6UBV//9MjR25PgAA6TRV//9ObyBwYWNrYWdlIG5hbWUgZGVmaW5lZCBm
b3IgbWV0YWNsYXNzAHNlbGYAc2VsZiwgbmFtZSwgY29kZSwgLi4uAE5vIHBhY2thZ2UgbmFtZSBk
ZWZpbmVkAGEgbWV0aG9kIG5hbWUAYSBDT0RFIHJlZmVyZW5jZQAlLXA6OiUtcABtZXRhLCAuLi4A
bWV0YSwgb2JqZWN0LCAuLi4AWW91IG11c3QgcGFzcyBhbiBpbnN0YW5jZSBvZiB0aGUgbWV0YWNs
YXNzICglLXApLCBub3QgKCUtcCkAbWV0YSwgb2JqZWN0LCBhcmdzLCBpc19jbG9uaW5nPSBGQUxT
RQAlczogJXMgaXMgbm90IGEgSEFTSCByZWZlcmVuY2UATW91c2U6Ok1ldGE6OkNsYXNzOjpfaW5p
dGlhbGl6ZV9vYmplY3QAYXJncwBtZXRhAF9tb3VzZV9jYWNoZV8Ac2VsZiwgbmFtZSwgbW9kaWZp
ZXIAc2VsZiwgbmFtZQBrbGFzcywgLi4uAEJVSUxEQVJHUwBCVUlMREFSR1MgZGlkIG5vdCByZXR1
cm4gYSBIQVNIIHJlZmVyZW5jZQBvYmplY3QAWW91IG11c3Qgbm90IGNhbGwgJXMgYXMgYSBjbGFz
cyBtZXRob2QAREVTVFJPWQBERU1PTElTSEFMTABERU1PTElTSABzZWxmLCBhcmdzAGEgSEFTSCBy
ZWZlcmVuY2UgdG8gQlVJTERBTEwAbGliL01vdXNlLmMAdjUuMjAuMAB2Mi40LjEATW91c2U6Ok1l
dGE6Ok1vZHVsZTo6bmFtZXNwYWNlAE1vdXNlOjpNZXRhOjpNb2R1bGU6OmFkZF9tZXRob2QATW91
c2U6Ok1ldGE6OkNsYXNzOjpsaW5lYXJpemVkX2lzYQBNb3VzZTo6TWV0YTo6Q2xhc3M6OmdldF9h
bGxfYXR0cmlidXRlcwBNb3VzZTo6TWV0YTo6Q2xhc3M6Om5ld19vYmplY3QATW91c2U6Ok1ldGE6
OkNsYXNzOjpjbG9uZV9vYmplY3QATW91c2U6Ok1ldGE6OkNsYXNzOjpfaW52YWxpZGF0ZV9tZXRh
Y2xhc3NfY2FjaGUATW91c2U6Ok1ldGE6OlJvbGU6OmFkZF9hZnRlcl9tZXRob2RfbW9kaWZpZXIA
TW91c2U6Ok1ldGE6OlJvbGU6OmFkZF9hcm91bmRfbWV0aG9kX21vZGlmaWVyAE1vdXNlOjpNZXRh
OjpSb2xlOjphZGRfYmVmb3JlX21ldGhvZF9tb2RpZmllcgBNb3VzZTo6TWV0YTo6Um9sZTo6YWRk
X2JlZm9yZV9tb2RpZmllcgBNb3VzZTo6TWV0YTo6Um9sZTo6Z2V0X2FmdGVyX21ldGhvZF9tb2Rp
ZmllcnMATW91c2U6Ok1ldGE6OlJvbGU6OmdldF9hcm91bmRfbWV0aG9kX21vZGlmaWVycwBNb3Vz
ZTo6TWV0YTo6Um9sZTo6Z2V0X2JlZm9yZV9tZXRob2RfbW9kaWZpZXJzAE1vdXNlOjpNZXRhOjpS
b2xlOjpnZXRfYmVmb3JlX21vZGlmaWVycwBNb3VzZTo6TWV0YTo6Um9sZTo6YWRkX21ldGFjbGFz
c19hY2Nlc3NvcgBNb3VzZTo6T2JqZWN0OjpuZXcATW91c2U6Ok9iamVjdDo6REVNT0xJU0hBTEwA
TW91c2U6Ok9iamVjdDo6REVTVFJPWQBNb3VzZTo6T2JqZWN0OjpCVUlMREFSR1MATW91c2U6Ok9i
amVjdDo6QlVJTERBTEwAcGFja2FnZQBuYW1lc3BhY2UAbWV0aG9kcwBuYW1lAGNvZXJjZQBnZXRf
YXR0cmlidXRlAGdldF9hdHRyaWJ1dGVfbGlzdABNb3VzZTo6TWV0YTo6TW9kdWxlOjpuYW1lAE1v
dXNlOjpNZXRhOjpNb2R1bGU6Ol9tZXRob2RfbWFwAE1vdXNlOjpNZXRhOjpNb2R1bGU6Ol9hdHRy
aWJ1dGVfbWFwAGF0dHJpYnV0ZXMATW91c2U6Ok1ldGE6OkNsYXNzOjpyb2xlcwByb2xlcwBNb3Vz
ZTo6TWV0YTo6Q2xhc3M6OmlzX2Fub25fY2xhc3MAYW5vbl9zZXJpYWxfaWQATW91c2U6Ok1ldGE6
OkNsYXNzOjppc19pbW11dGFibGUAaXNfaW1tdXRhYmxlAE1vdXNlOjpNZXRhOjpDbGFzczo6c3Ry
aWN0X2NvbnN0cnVjdG9yAHN0cmljdF9jb25zdHJ1Y3RvcgBNb3VzZTo6TWV0YTo6Q2xhc3M6Om1l
dGhvZF9tZXRhY2xhc3MAbWV0aG9kX21ldGFjbGFzcwBNb3VzZTo6TWV0YTo6TWV0aG9kAE1vdXNl
OjpNZXRhOjpDbGFzczo6YXR0cmlidXRlX21ldGFjbGFzcwBhdHRyaWJ1dGVfbWV0YWNsYXNzAE1v
dXNlOjpNZXRhOjpBdHRyaWJ1dGUATW91c2U6Ok1ldGE6OkNsYXNzOjpjb25zdHJ1Y3Rvcl9jbGFz
cwBjb25zdHJ1Y3Rvcl9jbGFzcwBNb3VzZTo6TWV0YTo6TWV0aG9kOjpDb25zdHJ1Y3Rvcjo6WFMA
TW91c2U6Ok1ldGE6OkNsYXNzOjpkZXN0cnVjdG9yX2NsYXNzAGRlc3RydWN0b3JfY2xhc3MATW91
c2U6Ok1ldGE6Ok1ldGhvZDo6RGVzdHJ1Y3Rvcjo6WFMATW91c2U6Ok1ldGE6Ok1ldGhvZDo6Q29u
c3RydWN0b3I6OlhTOjpfZ2VuZXJhdGVfY29uc3RydWN0b3IATW91c2U6Ok1ldGE6Ok1ldGhvZDo6
RGVzdHJ1Y3Rvcjo6WFM6Ol9nZW5lcmF0ZV9kZXN0cnVjdG9yAE1vdXNlOjpNZXRhOjpSb2xlOjpn
ZXRfcm9sZXMATW91c2U6Ok1ldGE6OlJvbGU6OmlzX2Fub25fcm9sZQBNb3VzZTo6TWV0YTo6Um9s
ZTo6bWV0aG9kX21ldGFjbGFzcwBNb3VzZTo6TWV0YTo6Um9sZTo6TWV0aG9kAE1vdXNlOjpNZXRh
OjpDbGFzcwBpbml0aWFsaXplAGJlZm9yZQBhcm91bmQAYWZ0ZXIAJXNfbWV0aG9kX21vZGlmaWVy
cwBNb2RpZmllciBzdHJvcmFnZSBmb3IgJyVzJyBpcyBub3QgYW4gQVJSQVkgcmVmZXJlbmNlAE5v
dCBhIE1vdXNlIG1ldGFjbGFzcwBZb3UgY2Fubm90IHVzZSB0aWVkIEhBU0ggcmVmZXJlbmNlIGFz
IGluaXRpYWxpemluZyBhcmd1bWVudHMAdHJpZ2dlcgBBdHRyaWJ1dGUgKCUtcCkgaXMgcmVxdWly
ZWQAX19NRVRBQ0xBU1NfXwAAJS1wLCAAKHVua25vd24pAFVua25vd24gYXR0cmlidXRlIHBhc3Nl
ZCB0byB0aGUgY29uc3RydWN0b3Igb2YgJS1wOiAlLXAAU2luZ2xlIHBhcmFtZXRlcnMgdG8gbmV3
KCkgbXVzdCBiZSBhIEhBU0ggcmVmAE9kZCBudW1iZXIgb2YgcGFyYW1ldGVycyB0byBuZXcoKQBp
c19hbm9uX2NsYXNzAEJVSUxEAF9jYWxjdWxhdGVfYWxsX2F0dHJpYnV0ZXMAJG1ldGEtPl9jYWxj
dWxhdGVfYWxsX2F0dHJpYnV0ZXMgZGlkIG5vdCByZXR1cm4gYW4gQVJSQVkgcmVmZXJlbmNlAElu
dmFsaWQgb2JqZWN0IGluc3RhbmNlOiAnJS1wJwB4cy1zcmMvTW91c2VBY2Nlc3Nvci54cwBFeHBl
Y3RlZCBleGFjdGx5IG9uZSBvciB0d28gYXJndW1lbnQgZm9yIGFuIGFjY2Vzc29yIG9mICUtcABD
YW5ub3QgYXNzaWduIGEgdmFsdWUgdG8gYSByZWFkLW9ubHkgYWNjZXNzb3Igb2YgJS1wAFRvbyBm
ZXcgYXJndW1lbnRzIGZvciBhIHdyaXRlLW9ubHkgYWNjZXNzb3Igb2YgJS1wAEV4cGVjdGVkIGV4
YWN0bHkgb25lIGFyZ3VtZW50IGZvciBhIHJlYWRlciBvZiAlLXAARXhwZWN0ZWQgZXhhY3RseSB0
d28gYXJndW1lbnQgZm9yIGEgd3JpdGVyIG9mICUtcABFeHBlY3RlZCBleGFjdGx5IG9uZSBhcmd1
bWVudCBmb3IgYSBjbGVhcmVyIG9mICUtcABFeHBlY3RlZCBleGFjdGx5IG9uZSBhcmd1bWVudCBm
b3IgYSBwcmVkaWNhdGUgb2YgJS1wAEV4cGVjdGVkIGV4YWN0bHkgb25lIG9yIHR3byBhcmd1bWVu
dCBmb3IgYSBjbGFzcyBkYXRhIGFjY2Vzc29yb2YgJS1wAGtsYXNzLCBhdHRyLCBtZXRhY2xhc3MA
eHMtc3JjL01vdXNlQWNjZXNzb3IuYwBNb3VzZTo6TWV0YTo6TWV0aG9kOjpBY2Nlc3Nvcjo6WFM6
Ol9nZW5lcmF0ZV9hY2Nlc3NvcgBNb3VzZTo6TWV0YTo6TWV0aG9kOjpBY2Nlc3Nvcjo6WFM6Ol9n
ZW5lcmF0ZV9yZWFkZXIATW91c2U6Ok1ldGE6Ok1ldGhvZDo6QWNjZXNzb3I6OlhTOjpfZ2VuZXJh
dGVfd3JpdGVyAE1vdXNlOjpNZXRhOjpNZXRob2Q6OkFjY2Vzc29yOjpYUzo6X2dlbmVyYXRlX2Ns
ZWFyZXIATW91c2U6Ok1ldGE6Ok1ldGhvZDo6QWNjZXNzb3I6OlhTOjpfZ2VuZXJhdGVfcHJlZGlj
YXRlAE1vdXNlLXBhbmljOiBOb3QgYW4gQVJSQVkgcmVmZXJlbmNlAE1vdXNlLXBhbmljOiBOb3Qg
YSBIQVNIIHJlZmVyZW5jZQBUb28gZmV3IGFyZ3VtZW50cyBmb3IgJXMATm90IGEgTW91c2UgbWV0
YSBhdHRyaWJ1dGUAX2NvbXBpbGVkX3R5cGVfY29uc3RyYWludABOb3QgYSBDT0RFIHJlZmVyZW5j
ZQBBdHRyaWJ1dGUgKCUtcCkgZG9lcyBub3QgcGFzcyB0aGUgdHlwZSBjb25zdHJhaW50IGJlY2F1
c2U6ICUtcABnZXRfbWVzc2FnZQBidWlsZGVyAGRlZmF1bHQAa2xhc3MsIG5hbWUsIGFyZ3MATW91
c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6X3Byb2Nlc3Nfb3B0aW9ucwBhbiBhdHRyaWJ1dGUgbmFtZQBp
bml0X2FyZwBidWlsZGVyIG11c3QgYmUgYSBkZWZpbmVkIHNjYWxhciB2YWx1ZSB3aGljaCBpcyBh
IG1ldGhvZCBuYW1lAFJlZmVyZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGFzIGRlZmF1bHQgdmFsdWVz
LCB5b3UgbXVzdCB3cmFwIHRoZSBkZWZhdWx0IG9mICclLXAnIGluIGEgQ09ERSByZWZlcmVuY2Ug
KGV4OiBzdWIgeyBbXSB9IGFuZCBub3QgW10pAHJlcXVpcmVkAFlvdSBjYW5ub3QgaGF2ZSBhIHJl
cXVpcmVkIGF0dHJpYnV0ZSAoJS1wKSB3aXRob3V0IGEgZGVmYXVsdCwgYnVpbGRlciwgb3IgYW4g
aW5pdF9hcmcAaXMAdW5kZWYAcm8AcmVhZGVyAHJ3AHdyaXRlcgBhY2Nlc3NvcgBiYXJlAEkgZG8g
bm90IHVuZGVyc3RhbmQgdGhpcyBvcHRpb24gKGlzID0+ICVzKSBvbiBhdHRyaWJ1dGUgKCUtcCkA
aXNhAE1vdXNlOjpVdGlsOjpUeXBlQ29uc3RyYWludHM6OmZpbmRfb3JfY3JlYXRlX2lzYV90eXBl
X2NvbnN0cmFpbnQAZG9lcwBNb3VzZTo6VXRpbDo6VHlwZUNvbnN0cmFpbnRzOjpmaW5kX29yX2Ny
ZWF0ZV9kb2VzX3R5cGVfY29uc3RyYWludAB0eXBlX2NvbnN0cmFpbnQAWW91IGNhbm5vdCBoYXZl
IGNvZXJjaW9uIHdpdGhvdXQgc3BlY2lmeWluZyBhIHR5cGUgY29uc3RyYWludCBvbiBhdHRyaWJ1
dGUgKCUtcCkAd2Vha19yZWYAWW91IGNhbm5vdCBoYXZlIGEgd2VhayByZWZlcmVuY2UgdG8gYSBj
b2VyY2VkIHZhbHVlIG9uIGF0dHJpYnV0ZSAoJS1wKQBsYXp5X2J1aWxkAFlvdSBjYW4gbm90IHVz
ZSBsYXp5X2J1aWxkIGFuZCBkZWZhdWx0IGZvciB0aGUgc2FtZSBhdHRyaWJ1dGUgKCUtcCkAbGF6
eQBfYnVpbGRfJS1wAGNsZWFyZXIAcHJlZGljYXRlAF9jbGVhciUtcABfaGFzJS1wAGNsZWFyXyUt
cABoYXNfJS1wAGF1dG9fZGVyZWYAaXNfYV90eXBlX29mAFlvdSBjYW5ub3QgYXV0by1kZXJlZmVy
ZW5jZSB3aXRob3V0IHNwZWNpZnlpbmcgYSB0eXBlIGNvbnN0cmFpbnQgb24gYXR0cmlidXRlICgl
LXApAEFycmF5UmVmAEhhc2hSZWYAWW91IGNhbm5vdCBhdXRvLWRlcmVmZXJlbmNlIGFueXRoaW5n
IG90aGVyIHRoYW4gYSBBcnJheVJlZiBvciBIYXNoUmVmIG9uIGF0dHJpYnV0ZSAoJS1wKQBUcmln
Z2VyIG11c3QgYmUgYSBDT0RFIHJlZiBvbiBhdHRyaWJ1dGUgKCUtcCkAWW91IGNhbm5vdCBoYXZl
IGEgbGF6eSBhdHRyaWJ1dGUgKCUtcCkgd2l0aG91dCBzcGVjaWZ5aW5nIGEgZGVmYXVsdCB2YWx1
ZSBmb3IgaXQAc2VsZiwgaW5zdGFuY2U9IE5VTEwAeHMtc3JjL01vdXNlQXR0cmlidXRlLmMATW91
c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6ZGVmYXVsdABNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpuYW1l
AE1vdXNlOjpNZXRhOjpBdHRyaWJ1dGU6OmFzc29jaWF0ZWRfY2xhc3MAYXNzb2NpYXRlZF9jbGFz
cwBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjphY2Nlc3NvcgBNb3VzZTo6TWV0YTo6QXR0cmlidXRl
OjpyZWFkZXIATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6d3JpdGVyAE1vdXNlOjpNZXRhOjpBdHRy
aWJ1dGU6OnByZWRpY2F0ZQBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpjbGVhcmVyAE1vdXNlOjpN
ZXRhOjpBdHRyaWJ1dGU6OmhhbmRsZXMAaGFuZGxlcwBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpf
aXNfbWV0YWRhdGEATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6aXNfcmVxdWlyZWQATW91c2U6Ok1l
dGE6OkF0dHJpYnV0ZTo6aXNfbGF6eQBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjppc19sYXp5X2J1
aWxkAE1vdXNlOjpNZXRhOjpBdHRyaWJ1dGU6OmlzX3dlYWtfcmVmAE1vdXNlOjpNZXRhOjpBdHRy
aWJ1dGU6OmluaXRfYXJnAE1vdXNlOjpNZXRhOjpBdHRyaWJ1dGU6OnR5cGVfY29uc3RyYWludABN
b3VzZTo6TWV0YTo6QXR0cmlidXRlOjp0cmlnZ2VyAE1vdXNlOjpNZXRhOjpBdHRyaWJ1dGU6OmJ1
aWxkZXIATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6c2hvdWxkX2F1dG9fZGVyZWYATW91c2U6Ok1l
dGE6OkF0dHJpYnV0ZTo6c2hvdWxkX2NvZXJjZQBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpkb2N1
bWVudGF0aW9uAGRvY3VtZW50YXRpb24ATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6aW5zZXJ0aW9u
X29yZGVyAGluc2VydGlvbl9vcmRlcgBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpoYXNfYWNjZXNz
b3IATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6aGFzX3JlYWRlcgBNb3VzZTo6TWV0YTo6QXR0cmli
dXRlOjpoYXNfd3JpdGVyAE1vdXNlOjpNZXRhOjpBdHRyaWJ1dGU6Omhhc19wcmVkaWNhdGUATW91
c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6aGFzX2NsZWFyZXIATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6
aGFzX2hhbmRsZXMATW91c2U6Ok1ldGE6OkF0dHJpYnV0ZTo6aGFzX2RlZmF1bHQATW91c2U6Ok1l
dGE6OkF0dHJpYnV0ZTo6aGFzX3R5cGVfY29uc3RyYWludABNb3VzZTo6TWV0YTo6QXR0cmlidXRl
OjpoYXNfdHJpZ2dlcgBNb3VzZTo6TWV0YTo6QXR0cmlidXRlOjpoYXNfYnVpbGRlcgBNb3VzZTo6
TWV0YTo6QXR0cmlidXRlOjpoYXNfZG9jdW1lbnRhdGlvbgBNb3VzZTo6TWV0YTo6QXR0cmlidXRl
OjphY2Nlc3Nvcl9tZXRhY2xhc3MAYWNjZXNzb3JfbWV0YWNsYXNzAE1vdXNlOjpNZXRhOjpNZXRo
b2Q6OkFjY2Vzc29yOjpYUwBDYW5ub3QgaGF2ZSBib3RoIGFuIGlzYSBvcHRpb24gYW5kIGEgZG9l
cyBvcHRpb25iZWNhdXNlICclLXAnIGRvZXMgbm90IGRvICclLXAnIG9uIGF0dHJpYnV0ZSAoJS1w
KQBoYXNfdHlwZV9jb25zdHJhaW50AHNob3VsZF9hdXRvX2RlcmVmAENhbiBub3QgYXV0byBkZS1y
ZWZlcmVuY2UgdGhlIHR5cGUgY29uc3RyYWludCAnJS1wJwBzaG91bGRfY29lcmNlAGhhc19jb2Vy
Y2lvbgBoYXNfdHJpZ2dlcgBpc19sYXp5AGhhc19idWlsZGVyAGhhc19kZWZhdWx0AGlzX3dlYWtf
cmVmAGlzX3JlcXVpcmVkAE1vdXNlOjpNZXRhOjpSb2xlAElPOjpIYW5kbGUAVU5JVkVSU0FMAGFu
IEFSUkFZIHJlZiBmb3IgbWV0aG9kIG5hbWVzAHBhcmFtAF9jb21waWxlZF90eXBlX2NvbnN0cmFp
bnQgZGlkbid0IHJldHVybiBhIENPREUgcmVmZXJlbmNlAHNlbGYsIC4uLgBwYXJlbnQAaGFuZF9v
cHRpbWl6ZWRfdHlwZV9jb25zdHJhaW50AGNvbnN0cmFpbnQAdHlwZV9jb25zdHJhaW50cwBOb3Qg
YW4gQVJSQVkgcmVmZXJlbmNlAGNvbXBpbGVkX3R5cGVfY29uc3RyYWludAAnJS1wJyBoYXMgbm8g
Y29tcGlsZWQgdHlwZSBjb25zdHJhaW50AE1vdXNlOjpVdGlsOjpUeXBlQ29uc3RyYWludHM6OkFu
eQBzZWxmLCBzdiwgLi4uAHhzLXNyYy9Nb3VzZVR5cGVDb25zdHJhaW50cy5jAE1vdXNlOjpVdGls
OjpUeXBlQ29uc3RyYWludHM6Ol9wYXJhbWV0ZXJpemVfQXJyYXlSZWZfZm9yAE1vdXNlOjpVdGls
OjpUeXBlQ29uc3RyYWludHM6Ol9wYXJhbWV0ZXJpemVfSGFzaFJlZl9mb3IATW91c2U6OlV0aWw6
OlR5cGVDb25zdHJhaW50czo6X3BhcmFtZXRlcml6ZV9NYXliZV9mb3IATW91c2U6Ok1ldGE6OlR5
cGVDb25zdHJhaW50OjpfaWRlbnRpdHkATW91c2U6Ok1ldGE6OlR5cGVDb25zdHJhaW50Ojpjb21w
aWxlX3R5cGVfY29uc3RyYWludABNb3VzZTo6TWV0YTo6VHlwZUNvbnN0cmFpbnQ6OmNoZWNrAE1v
dXNlOjpVdGlsOjpUeXBlQ29uc3RyYWludHM6OlVuZGVmAE1vdXNlOjpVdGlsOjpUeXBlQ29uc3Ry
YWludHM6OkRlZmluZWQATW91c2U6OlV0aWw6OlR5cGVDb25zdHJhaW50czo6Qm9vbABNb3VzZTo6
VXRpbDo6VHlwZUNvbnN0cmFpbnRzOjpWYWx1ZQBNb3VzZTo6VXRpbDo6VHlwZUNvbnN0cmFpbnRz
OjpSZWYATW91c2U6OlV0aWw6OlR5cGVDb25zdHJhaW50czo6U3RyAE1vdXNlOjpVdGlsOjpUeXBl
Q29uc3RyYWludHM6Ok51bQBNb3VzZTo6VXRpbDo6VHlwZUNvbnN0cmFpbnRzOjpJbnQATW91c2U6
OlV0aWw6OlR5cGVDb25zdHJhaW50czo6U2NhbGFyUmVmAE1vdXNlOjpVdGlsOjpUeXBlQ29uc3Ry
YWludHM6OkFycmF5UmVmAE1vdXNlOjpVdGlsOjpUeXBlQ29uc3RyYWludHM6Okhhc2hSZWYATW91
c2U6OlV0aWw6OlR5cGVDb25zdHJhaW50czo6Q29kZVJlZgBNb3VzZTo6VXRpbDo6VHlwZUNvbnN0
cmFpbnRzOjpHbG9iUmVmAE1vdXNlOjpVdGlsOjpUeXBlQ29uc3RyYWludHM6OkZpbGVIYW5kbGUA
TW91c2U6OlV0aWw6OlR5cGVDb25zdHJhaW50czo6UmVnZXhwUmVmAE1vdXNlOjpVdGlsOjpUeXBl
Q29uc3RyYWludHM6Ok9iamVjdABNb3VzZTo6VXRpbDo6VHlwZUNvbnN0cmFpbnRzOjpDbGFzc05h
bWUATW91c2U6OlV0aWw6OlR5cGVDb25zdHJhaW50czo6Um9sZU5hbWUATW91c2U6Ok1ldGE6OlR5
cGVDb25zdHJhaW50OjpuYW1lAE1vdXNlOjpNZXRhOjpUeXBlQ29uc3RyYWludDo6cGFyZW50AE1v
dXNlOjpNZXRhOjpUeXBlQ29uc3RyYWludDo6bWVzc2FnZQBtZXNzYWdlAE1vdXNlOjpNZXRhOjpU
eXBlQ29uc3RyYWludDo6dHlwZV9wYXJhbWV0ZXIAdHlwZV9wYXJhbWV0ZXIATW91c2U6Ok1ldGE6
OlR5cGVDb25zdHJhaW50OjpfY29tcGlsZWRfdHlwZV9jb25zdHJhaW50AE1vdXNlOjpNZXRhOjpU
eXBlQ29uc3RyYWludDo6aGFzX2NvZXJjaW9uAF9jb21waWxlZF90eXBlX2NvZXJjaW9uAE1vdXNl
OjpNZXRhOjpUeXBlQ29uc3RyYWludDo6X19pc19wYXJhbWV0ZXJpemVkAE1vdXNlOjpNZXRhOjpU
eXBlQ29uc3RyYWludDo6KCkATW91c2U6Ok1ldGE6OlR5cGVDb25zdHJhaW50OjpfYXNfc3RyaW5n
AE1vdXNlOjpNZXRhOjpUeXBlQ29uc3RyYWludDo6KCIiAE1vdXNlOjpNZXRhOjpUeXBlQ29uc3Ry
YWludDo6KDArAE1vdXNlOjpNZXRhOjpUeXBlQ29uc3RyYWludDo6X3VuaXRlAE1vdXNlOjpNZXRh
OjpUeXBlQ29uc3RyYWludDo6KHwAVU5JVkVSU0FMOjppc2EAVU5JVkVSU0FMOjpjYW4AVG9vIGZl
dyBhcmd1bWVudHMgZm9yIHR5cGUgY29uc3RyYWludCBjaGVjayBmdW5jdGlvbnMAY2FuAHhzLXNy
Yy9Nb3VzZVR5cGVDb25zdHJhaW50cy54cwBtYWluOjoAJS4qZwBkYXRhAGRlcHRoAHRocm93X2Vy
cm9yAE1vdXNlOjpVdGlsOjp0aHJvd19lcnJvcgB0aHJvd19lcnJvcigpIGRpZCBub3QgdGhyb3cg
dGhlIGVycm9yICglLXApAFlvdSBtdXN0IGRlZmluZSAlcwBZb3UgbXVzdCBwYXNzICVzLCBub3Qg
JXMAVkVSU0lPTgBJU0EAbW91c2VfbWdfZmluZDogbm8gTUFHSUMgZm91bmQgZm9yICUtcABtZXRh
cywgY2xvbmluZwBNb3VzZTo6VXRpbDo6X19yZWdpc3Rlcl9tZXRhY2xhc3Nfc3RvcmFnZQBtZXRh
cwBNZXRhY2xhc3Mgc3RvcmFnZSBtb3JlIHRoYW4gb25jZQBzdgBjb2RlACVzOiAlcyBpcyBub3Qg
YSBDT0RFIHJlZmVyZW5jZQBNb3VzZTo6VXRpbDo6Z2V0X2NvZGVfaW5mbwBNb3VzZTo6VXRpbDo6
Z2V0X2NvZGVfcGFja2FnZQBwYWNrYWdlLCBuYW1lAGEgcGFja2FnZSBuYW1lAGEgc3Vicm91dGlu
ZSBuYW1lAGFyZywgcHJlZGljYXRlX25hbWU9IE5VTEwAYSBjbGFzc19uYW1lAG1ldGhvZCBuYW1l
cwBhIHByZWRpY2F0ZSBuYW1lAGludG8sIC4uLgBpbnRvLCBuYW1lID0+IGNvZGVyZWYgWywgb3Ro
ZXJfbmFtZSwgb3RoZXJfY29kZXJlZiAuLi5dAHhzLXNyYy9Nb3VzZVV0aWwuYwBNb3VzZTo6VXRp
bDo6aXNfdmFsaWRfY2xhc3NfbmFtZQBNb3VzZTo6VXRpbDo6aXNfY2xhc3NfbG9hZGVkAE1vdXNl
OjpVdGlsOjpnZXRfY29kZV9yZWYATW91c2U6OlV0aWw6OmdlbmVyYXRlX2Nhbl9wcmVkaWNhdGVf
Zm9yAE1vdXNlOjpVdGlsOjpnZW5lcmF0ZV9pc2FfcHJlZGljYXRlX2ZvcgBNb3VzZTo6VXRpbDo6
aW5zdGFsbF9zdWJyb3V0aW5lcwAAAAAAAAAAAAAAAAAA8D8BAAAAHAAAAAYAAAA0AAAAAAAAADQA
AAACAAAA0VgFAQAAAAERCwQBYQEDASEAAgEBAAEBIAoAAEwAAABMAAAAc64AAAAAAABMAAAAAwAA
AAwAPAD8AAEAAAAABiAAAAGAAAADcAEAANAVAALwFgAAcCIAAxAjAABgKwABsCsAA/AsAAUwLQAE
kC0AAfAtAAVgLgAE8C4AAdAvAANwMAACEDIAAKA4AALAOQAAEDsAAyA9AACARgADgEcAANBOAAJQ
UAAAIGkAATBpAAQQagABwGoABNBrAAFAbAAC0GwAAIBvAAGwcAAFQHEAAXBxAAKQcgABsHIAAMB3
AAJQeAAEwHgAAfB4AAAgfwACEIAAALCJAAHwiQAAwIsABCCMAAPQjAAEUI4AAKCQAAWgkQAB8JEA
AACWAAIglwADwJcAAoCbAADgogACAAAAAAAAAAAUAAAAAAAAAAF6UgABeBABEAwHCJABAAAkAAAA
HAAAAEAu////////UgAAAAAAAAAAQQ4QhgJDDQYAAAAAAAAAJAAAAEQAAAB4Lv///////+QAAAAA
AAAAAEEOEIYCQw0GRoMFjgSPAywAAABsAAAAQC////////+aAQAAAAAAAABBDhCGAkMNBkqDB4wG
jQWOBI8DAAAAACwAAACcAAAAsDD///////9LAQAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAA
ACwAAADMAAAA0DH///////8RAQAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAAD8AAAA
wDL///////8eBAAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAAAsAQAAsDb////////4
AAAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAABcAQAAgDf///////86AQAAAAAAAABB
DhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAACMAQAAkDj///////9yBQAAAAAAAABBDhCGAkMNBk2D
B4wGjQWOBI8DAAAAACwAAAC8AQAA4D3///////8MAQAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8D
AAAAACwAAADsAQAAwD7///////8rAQAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAAAc
AgAAwD////////8rAgAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAABMAgAAwEH/////
//8WAQAAAAAAAABBDhCGAkMNBkeDBowFjgSPAwAAAAAAACwAAAB8AgAAsEL///////+4AAAAAAAA
AABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAACsAgAAQEP///////8DAQAAAAAAAABBDhCGAkMN
BkqDB4wGjQWOBI8DAAAAACwAAADcAgAAIET///////9kAQAAAAAAAABBDhCGAkMNBkqDB4wGjQWO
BI8DAAAAACwAAAAMAwAAYEX///////8EAQAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwA
AAA8AwAAQEb///////+1AgAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAABsAwAA0Ej/
//////9iBAAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACQAAACcAwAAEE3///////+VAAAA
AAAAAABBDhCGAkMNBkaDBY4EjwMsAAAAxAMAAIhN////////yQAAAAAAAAAAQQ4QhgJDDQZKgweM
Bo0FjgSPAwAAAAAsAAAA9AMAAChO////////dQcAAAAAAAAAQQ4QhgJDDQZKgweMBo0FjgSPAwAA
AAAkAAAAJAQAAHhV////////QwAAAAAAAAAAQQ4QhgJDDQYAAAAAAAAAJAAAAEwEAACgVf//////
/zMBAAAAAAAAAEEOEIYCQw0GRoMFjgSPAxQAAAAAAAAAAXpSAAF4EAEQDAcIkAEAACQAAAAcAAAA
oFb///////80AAAAAAAAAABBDhCGAkMNBkKDAwAAAAAkAAAARAAAALhW////////YAAAAAAAAAAA
QQ4QhgJDDQZDgwSOAwAAJAAAAGwAAADwVv///////2AAAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQA
AACUAAAAKFf///////9nAAAAAAAAAABBDhCGAkMNBkWDAwAAAAAkAAAAvAAAAHBX////////igAA
AAAAAAAAQQ4QhgJDDQZHgwSOAwAAJAAAAOQAAADYV////////1oAAAAAAAAAAEEOEIYCQw0GAAAA
AAAAACQAAAAMAQAAEFj///////9+AAAAAAAAAABBDhCGAkMNBgAAAAAAAAAkAAAANAEAAGhY////
////kgAAAAAAAAAAQQ4QhgJDDQZGgwWOBI8DLAAAAFwBAADgWP///////5EBAAAAAAAAAEEOEIYC
Qw0GS4MGjAWOBI8DAAAAAAAALAAAAIwBAABQWv///////0wDAAAAAAAAAEEOEIYCQw0GTYMHjAaN
BY4EjwMAAAAALAAAALwBAABwXf///////18BAAAAAAAAAEEOEIYCQw0GTYMHjAaNBY4EjwMAAAAA
LAAAAOwBAACgXv////////gAAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAALAAAABwCAABw
X////////9wAAAAAAAAAAEEOEIYCQw0GTYMHjAaNBY4EjwMAAAAALAAAAEwCAAAgYP///////x4B
AAAAAAAAAEEOEIYCQw0GS4MGjAWOBI8DAAAAAAAALAAAAHwCAAAQYf///////0IBAAAAAAAAAEEO
EIYCQw0GTYMHjAaNBY4EjwMAAAAAJAAAAKwCAAAwYv///////wABAAAAAAAAAEEOEIYCQw0GSYMF
jgSPAyQAAADUAgAACGP///////8LAQAAAAAAAABBDhCGAkMNBkmDBY4EjwMsAAAA/AIAAPBj////
////yAIAAAAAAAAAQQ4QhgJDDQZNgweMBo0FjgSPAwAAAAAsAAAALAMAAJBm////////MAEAAAAA
AAAAQQ4QhgJDDQZKgweMBo0FjgSPAwAAAAAsAAAAXAMAAJBn////////MAEAAAAAAAAAQQ4QhgJD
DQZKgweMBo0FjgSPAwAAAAAsAAAAjAMAAJBo////////MAEAAAAAAAAAQQ4QhgJDDQZKgweMBo0F
jgSPAwAAAAAsAAAAvAMAAJBp////////cwEAAAAAAAAAQQ4QhgJDDQZNgweMBo0FjgSPAwAAAAAs
AAAA7AMAAOBq////////cwEAAAAAAAAAQQ4QhgJDDQZNgweMBo0FjgSPAwAAAAAkAAAAHAQAADBs
/////////QAAAAAAAAAAQQ4QhgJDDQZGgwWOBI8DLAAAAEQEAAAIbf///////1UCAAAAAAAAAEEO
EIYCQw0GSoMHjAaNBY4EjwMAAAAAFAAAAAAAAAABelIAAXgQARAMBwiQAQAALAAAABwAAAAgb///
/////+EEAAAAAAAAAEEOEIYCQw0GTYMHjAaNBY4EjwMAAAAALAAAAEwAAADgc////////3oBAAAA
AAAAAEEOEIYCQw0GR4MGjAWOBI8DAAAAAAAALAAAAHwAAAAwdf///////3gBAAAAAAAAAEEOEIYC
Qw0GSoMHjAaNBY4EjwMAAAAALAAAAKwAAACAdv///////5kNAAAAAAAAAEEOEIYCQw0GTYMHjAaN
BY4EjwMAAAAALAAAANwAAADwg////////9MBAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAA
LAAAAAwBAACghf///////y4FAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAAFAAAAAAAAAAB
elIAAXgQARAMBwiQAQAALAAAABwAAACIiv///////9oBAAAAAAAAAEEOEIYCQw0GTYMHjAaNBY4E
jwMAAAAALAAAAEwAAAA4jP///////7MAAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAAJAAA
AHwAAADIjP///////wsAAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQAAACkAAAAsIz////////aAAAA
AAAAAABBDhCGAkMNBkeDBI4DAAAkAAAAzAAAAGiN////////KgAAAAAAAAAAQQ4QhgJDDQYAAAAA
AAAAJAAAAPQAAABwjf///////ygAAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQAAAAcAQAAeI3/////
//8zAAAAAAAAAABBDhCGAkMNBgAAAAAAAAAkAAAARAEAAJCN////////DQAAAAAAAAAAQQ4QhgJD
DQYAAAAAAAAAJAAAAGwBAAB4jf///////wcBAAAAAAAAAEEOEIYCQw0GR4MEjgMAACQAAACUAQAA
YI7///////9CAAAAAAAAAABBDhCGAkMNBgAAAAAAAAAkAAAAvAEAAIiO////////EQAAAAAAAAAA
QQ4QhgJDDQYAAAAAAAAALAAAAOQBAACAjv///////4oAAAAAAAAAAEEOEIYCQw0GR4MGjAWOBI8D
AAAAAAAALAAAABQCAADgjv///////6ICAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAAJAAA
AEQCAABgkf///////w4AAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQAAABsAgAASJH///////8zAAAA
AAAAAABBDhCGAkMNBgAAAAAAAAAkAAAAlAIAAGCR////////LgAAAAAAAAAAQQ4QhgJDDQYAAAAA
AAAAJAAAALwCAABokf///////y4AAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQAAADkAgAAcJH/////
//8uAAAAAAAAAABBDhCGAkMNBgAAAAAAAAAkAAAADAMAAHiR////////FwAAAAAAAAAAQQ4QhgJD
DQYAAAAAAAAAJAAAADQDAABwkf///////y4AAAAAAAAAAEEOEIYCQw0GAAAAAAAAACQAAABcAwAA
eJH///////+OAAAAAAAAAABBDhCGAkMNBkKDAwAAAAAkAAAAhAMAAOCR////////LwAAAAAAAAAA
QQ4QhgJDDQYAAAAAAAAALAAAAKwDAADokf///////xMBAAAAAAAAAEEOEIYCQw0GS4MGjAWOBI8D
AAAAAAAAJAAAANwDAADYkv///////x8AAAAAAAAAAEEOEIYCQw0GAAAAAAAAACwAAAAEBAAA0JL/
//////9DAQAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAAA0BAAA8JP///////87AgAA
AAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAABkBAAAAJb///////94AQAAAAAAAABBDhCG
AkMNBkqDB4wGjQWOBI8DAAAAACwAAACUBAAAUJf///////+JAAAAAAAAAABBDhCGAkMNBkeDBowF
jgSPAwAAAAAAACQAAADEBAAAsJf///////9wAAAAAAAAAABBDhCGAkMNBkODBI4DAAAkAAAA7AQA
APiX////////LQAAAAAAAAAAQQ4QhgJDDQYAAAAAAAAALAAAABQFAAAAmP///////98AAAAAAAAA
AEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAALAAAAEQFAACwmP///////0UFAAAAAAAAAEEOEIYCQw0G
TYMHjAaNBY4EjwMAAAAALAAAAHQFAADQnf///////1wAAAAAAAAAAEEOEIYCQw0GR4MGjAWOBI8D
AAAAAAAALAAAAKQFAAAAnv///////4gAAAAAAAAAAEEOEIYCQw0GR4MGjAWOBI8DAAAAAAAALAAA
ANQFAABgnv///////6IBAAAAAAAAAEEOEIYCQw0GTYMHjAaNBY4EjwMAAAAALAAAAAQGAADgn///
/////+0HAAAAAAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAAJAAAADQGAACgp////////zYAAAAA
AAAAAEEOEIYCQw0GAAAAAAAAABQAAAAAAAAAAXpSAAF4EAEQDAcIkAEAACwAAAAcAAAAoKf/////
///LAQAAAAAAAABBDhCGAkMNBlCDB4wGjQWOBI8DAAAAACQAAABMAAAAQKn///////9WAAAAAAAA
AABBDhCGAkMNBkODBI4DAAAkAAAAdAAAAHip////////rAAAAAAAAAAAQQ4QhgJDDQZGgwWOBI8D
JAAAAJwAAAAAqv///////3wBAAAAAAAAAEEOEIYCQw0GR4MEjgMAACwAAADEAAAAWKv///////+7
AAAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAAD0AAAA6Kv////////BAAAAAAAAAABB
DhCGAkMNBkqDB4wGjQWOBI8DAAAAACwAAAAkAQAAiKz///////+/AAAAAAAAAABBDhCGAkMNBkqD
B4wGjQWOBI8DAAAAACQAAABUAQAAGK3////////3AAAAAAAAAABBDhCGAkMNBkWDAwAAAAAkAAAA
fAEAAPCt////////TQAAAAAAAAAAQQ4QhgJDDQYAAAAAAAAALAAAAKQBAAAYrv///////3UAAAAA
AAAAAEEOEIYCQw0GSoMHjAaNBY4EjwMAAAAALAAAANQBAABorv///////4gBAAAAAAAAAEEOEIYC
Qw0GTYMHjAaNBY4EjwMAAAAALAAAAAQCAADIr/////////wBAAAAAAAAAEEOEIYCQw0GSoMHjAaN
BY4EjwMAAAAALAAAADQCAACYsf///////xUBAAAAAAAAAEEOEIYCQw0GR4MGjAWOBI8DAAAAAAAA
JAAAAGQCAACIsv///////5kAAAAAAAAAAEEOEIYCQw0GRoMFjgSPAywAAACMAgAAALP///////8D
AgAAAAAAAABBDhCGAkMNBkuDBowFjgSPAwAAAAAAACwAAAC8AgAA4LT///////+vAQAAAAAAAABB
DhCGAkMNBkuDBowFjgSPAwAAAAAAACwAAADsAgAAYLb///////9XAgAAAAAAAABBDhCGAkMNBkqD
B4wGjQWOBI8DAAAAACwAAAAcAwAAkLj/////////AQAAAAAAAABBDhCGAkMNBkqDB4wGjQWOBI8D
AAAAACwAAABMAwAAYLr////////7AgAAAAAAAABBDhCGAkMNBk2DB4wGjQWOBI8DAAAAACwAAAB8
AwAAML3///////9yAQAAAAAAAABBDhCGAkMNBkeDBowFjgSPAwAAAAAAAAAAAAAAAAAAABDAX/9/
AAAIEMBf/38AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAACcsAAAAAAAAKiwAAAAAAAAtLAAAAAAAADAsAAAAAAAAMyw
AAAAAAAA2LAAAAAAAADksAAAAAAAAPCwAAAAAAAA/LAAAAAAAAAIsQAAAAAAABSxAAAAAAAAILEA
AAAAAAAssQAAAAAAADixAAAAAAAARLEAAAAAAABQsQAAAAAAAFyxAAAAAAAAaLEAAAAAAAB0sQAA
AAAAAICxAAAAAAAAjLEAAAAAAACYsQAAAAAAAKSxAAAAAAAAsLEAAAAAAAC8sQAAAAAAAMixAAAA
AAAA1LEAAAAAAADgsQAAAAAAAOyxAAAAAAAA+LEAAAAAAAAEsgAAAAAAABCyAAAAAAAAHLIAAAAA
AAAosgAAAAAAADSyAAAAAAAAQLIAAAAAAABMsgAAAAAAAFiyAAAAAAAAZLIAAAAAAABwsgAAAAAA
AHyyAAAAAAAAiLIAAAAAAACUsgAAAAAAAKCyAAAAAAAArLIAAAAAAAC4sgAAAAAAAMSyAAAAAAAA
0LIAAAAAAADcsgAAAAAAAOiyAAAAAAAA9LIAAAAAAAAAswAAAAAAAAyzAAAAAAAAGLMAAAAAAAAk
swAAAAAAADCzAAAAAAAAPLMAAAAAAABIswAAAAAAAFSzAAAAAAAAYLMAAAAAAABsswAAAAAAAHiz
AAAAAAAAhLMAAAAAAACQswAAAAAAAJyzAAAAAAAAqLMAAAAAAAC0swAAAAAAAMCzAAAAAAAAzLMA
AAAAAADYswAAAAAAAOSzAAAAAAAA8LMAAAAAAAD8swAAAAAAAAi0AAAAAAAAFLQAAAAAAAAgtAAA
AAAAACy0AAAAAAAAOLQAAAAAAABEtAAAAAAAAFC0AAAAAAAAXLQAAAAAAABotAAAAAAAAHS0AAAA
AAAAgLQAAAAAAACMtAAAAAAAAJi0AAAAAAAApLQAAAAAAACwtAAAAAAAALy0AAAAAAAAyLQAAAAA
AADUtAAAAAAAAOC0AAAAAAAAAAAAAAAAAAAAvgAAAAAAAAe+AAAAAAAADr4AAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgAAAADAAAG0AAAAAMA
AAbYAAAAAwAABuAAAAADAAAG6AAAAAMAAAbwAAAAAwAABvgAAAADAAAGAAEAAAMAAAYIAQAAAwAA
BhABAAADAAAGGAEAAAMAAAYgAQAAAwAABigBAAADAAAGMAEAAAMAAAY4AQAAAwAABkABAAADAAAG
SAEAAAMAAAZQAQAAAwAABlgBAAADAAAGYAEAAAMAAAZoAQAAAwAABnABAAADAAAGeAEAAAMAAAaA
AQAAAwAABogBAAADAAAGkAEAAAMAAAaYAQAAAwAABqABAAADAAAGqAEAAAMAAAawAQAAAwAABrgB
AAADAAAGwAEAAAMAAAbIAQAAAwAABtABAAADAAAG2AEAAAMAAAbgAQAAAwAABugBAAADAAAG8AEA
AAMAAAb4AQAAAwAABgACAAADAAAGCAIAAAMAAAYQAgAAAwAABhgCAAADAAAGIAIAAAMAAAYoAgAA
AwAABjACAAADAAAGOAIAAAMAAAZAAgAAAwAABkgCAAADAAAGUAIAAAMAAAZYAgAAAwAABmACAAAD
AAAGaAIAAAMAAAZwAgAAAwAABngCAAADAAAGgAIAAAMAAAaIAgAAAwAABpACAAADAAAGmAIAAAMA
AAagAgAAAwAABqgCAAADAAAGsAIAAAMAAAa4AgAAAwAABsACAAADAAAGyAIAAAMAAAbQAgAAAwAA
BtgCAAADAAAG4AIAAAMAAAboAgAAAwAABvACAAADAAAG+AIAAAMAAAYAAwAAAwAABggDAAADAAAG
EAMAAAMAAAYYAwAAAwAABiADAAADAAAGKAMAAAMAAAYwAwAAAwAABjgDAAADAAAGQAMAAAMAAAZI
AwAAAwAABlADAAADAAAGWAMAAAMAAAZgAwAAAwAABmgDAAADAAAGcAMAAAMAAAZ4AwAAAwAABoAD
AAADAAAGiAMAAAMAAAaQAwAAAwAABpgDAAADAAAGoAMAAAMAAAbAAwAABAAABrgDAAAEAAAGsAMA
AAQAAAagFBQMYPABoAPQAqACoAiAAsACgAuQArACsASgAsABkALwApACwAXwCKAB0AGAD1DAAkBg
YHCQAWCAAaABoAPQBuACgALgAaAC0AKAApAC0AWwArACsAKAA4ADgALgBPAJgAOAA6Ab4AOwCuAD
wAEQ4AEwMEAQkAJQIJABsAUQQDAwMCAwkAEwoAIg0ALABIADkAFwMOAB0ApgkAGwA/APQNADYLAB
gAPAAdABwAGAAlCAAZADgASgAqABkASwA+AEgASABgAAAAIAAAAeAQAAIAoAAAAAAAAbAAAAHgEA
ADQKAAAAAAAALgAAAA4BAACgDwAAAAAAADwAAAAOAQAAwBQAAAAAAABNAAAADgEAAAAWAAAAAAAA
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
DxQAAAEAAP4AAAAAAAAAAB0UAAABAAD+AAAAAAAAAAAtFAAAAQAA/gAAAAAAAAAAOhQAAAEAAP4A
AAAAAAAAAFgUAAABAAD+AAAAAAAAAABzFAAAAQAAAQAAAAAAAAAAghQAAAEAAAEAAAAAAAAAAJQU
AAABAAABAAAAAAAAAACnFAAAAQAAAQAAAAAAAAAArxQAAAEAAAEAAAAAAAAAAJYAAACXAAAAmAAA
AJkAAACaAAAAmwAAAJwAAACdAAAAngAAAJ8AAACgAAAAoQAAAKIAAACjAAAApAAAAKUAAACmAAAA
pwAAAKgAAACpAAAAqgAAAKsAAACsAAAArQAAAK4AAACvAAAAsAAAALEAAACyAAAAswAAALQAAAC1
AAAAtgAAALcAAAC4AAAAuQAAALoAAAC7AAAAvAAAAL0AAAC+AAAAvwAAAMAAAADBAAAAwgAAAMMA
AADEAAAAxQAAAMYAAADHAAAAyAAAAMkAAADKAAAAywAAAMwAAADNAAAAzgAAAM8AAADQAAAA0QAA
ANIAAADTAAAA1AAAANUAAADWAAAA1wAAANgAAADZAAAA2gAAANsAAADcAAAA3QAAAN4AAADfAAAA
4AAAAOEAAADiAAAA4wAAAOQAAADlAAAA5gAAAOcAAADoAAAA6QAAAOoAAADrAAAA7AAAAO0AAADu
AAAA7wAAAPEAAADyAAAAgAAAAIEAAACCAAAAgwAAAIQAAACFAAAAhgAAAIcAAACIAAAAiQAAAIoA
AACLAAAAjAAAAI0AAACOAAAAjwAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAPAAAACWAAAAlwAA
AJgAAACZAAAAmgAAAJsAAACcAAAAnQAAAJ4AAACfAAAAoAAAAKEAAACiAAAAowAAAKQAAAClAAAA
pgAAAKcAAACoAAAAqQAAAKoAAACrAAAArAAAAK0AAACuAAAArwAAALAAAACxAAAAsgAAALMAAAC0
AAAAtQAAALYAAAC3AAAAuAAAALkAAAC6AAAAuwAAALwAAAC9AAAAvgAAAL8AAADAAAAAwQAAAMIA
AADDAAAAxAAAAMUAAADGAAAAxwAAAMgAAADJAAAAygAAAMsAAADMAAAAzQAAAM4AAADPAAAA0AAA
ANEAAADSAAAA0wAAANQAAADVAAAA1gAAANcAAADYAAAA2QAAANoAAADbAAAA3AAAAN0AAADeAAAA
3wAAAOAAAADhAAAA4gAAAOMAAADkAAAA5QAAAOYAAADnAAAA6AAAAOkAAADqAAAA6wAAAOwAAADt
AAAA7gAAAO8AAADxAAAA8gAAACAAZHlsZF9zdHViX2JpbmRpbmdfaGVscGVyAF9fZHlsZF9mdW5j
X2xvb2t1cABfbW91c2VfZ2V0X3hjAF9tb3VzZV9idWlsZGFyZ3MAX21vdXNlX2NsYXNzX2luaXRp
YWxpemVfb2JqZWN0AF9tb3VzZV9idWlsZGFsbABfbW91c2VfZ2V0X21vZGlmaWVyX3N0b3JhZ2UA
X1hTX01vdXNlX3ZhbHVlX2hvbGRlcgBfbW91c2VfZ2V0X3hjX3dvX2NoZWNrAF9tb3VzZV9hdHRy
X3NldABfbW91c2VfcHVzaF92YWx1ZQBfWFNfTW91c2VfY29uc3RyYWludF9jaGVjawBfbW91c2Vf
aXNfYW5faW5zdGFuY2Vfb2ZfdW5pdmVyc2FsAF9tb3VzZV9jYW5fbWV0aG9kcwBfbW91c2VfcGFy
YW1ldGVyaXplZF9BcnJheVJlZgBfbW91c2VfcGFyYW1ldGVyaXplZF9IYXNoUmVmAF9tb3VzZV9w
YXJhbWV0ZXJpemVkX01heWJlAF9tb3VzZV90eXBlc191bmlvbl9jaGVjawBfbW91c2VfdHlwZXNf
Y2hlY2sAX1hTX01vdXNlX1R5cGVDb25zdHJhaW50X2ZhbGxiYWNrAF9tb3VzZV9nZXRfbW9kaWZp
ZXJfc3RvcmFnZS5rZXlzAF9tb3VzZV94Y192dGJsAF9tb3VzZV9hY2Nlc3Nvcl92dGJsAF9tb3Vz
ZV94YV92dGJsAF9teV9jeHQAX21vdXNlX3V0aWxfdHlwZV9jb25zdHJhaW50c192dGJsAF9teV9j
eHQuMABfWFNfTW91c2VfX01ldGFfX0F0dHJpYnV0ZV9fcHJvY2Vzc19vcHRpb25zAF9YU19Nb3Vz
ZV9fTWV0YV9fQXR0cmlidXRlX2RlZmF1bHQAX1hTX01vdXNlX19NZXRhX19DbGFzc19faW5pdGlh
bGl6ZV9vYmplY3QAX1hTX01vdXNlX19NZXRhX19DbGFzc19faW52YWxpZGF0ZV9tZXRhY2xhc3Nf
Y2FjaGUAX1hTX01vdXNlX19NZXRhX19DbGFzc19jbG9uZV9vYmplY3QAX1hTX01vdXNlX19NZXRh
X19DbGFzc19nZXRfYWxsX2F0dHJpYnV0ZXMAX1hTX01vdXNlX19NZXRhX19DbGFzc19saW5lYXJp
emVkX2lzYQBfWFNfTW91c2VfX01ldGFfX0NsYXNzX25ld19vYmplY3QAX1hTX01vdXNlX19NZXRh
X19NZXRob2RfX0FjY2Vzc29yX19YU19fZ2VuZXJhdGVfYWNjZXNzb3IAX1hTX01vdXNlX19NZXRh
X19NZXRob2RfX0FjY2Vzc29yX19YU19fZ2VuZXJhdGVfY2xlYXJlcgBfWFNfTW91c2VfX01ldGFf
X01ldGhvZF9fQWNjZXNzb3JfX1hTX19nZW5lcmF0ZV9wcmVkaWNhdGUAX1hTX01vdXNlX19NZXRh
X19NZXRob2RfX0FjY2Vzc29yX19YU19fZ2VuZXJhdGVfcmVhZGVyAF9YU19Nb3VzZV9fTWV0YV9f
TWV0aG9kX19BY2Nlc3Nvcl9fWFNfX2dlbmVyYXRlX3dyaXRlcgBfWFNfTW91c2VfX01ldGFfX01v
ZHVsZV9hZGRfbWV0aG9kAF9YU19Nb3VzZV9fTWV0YV9fTW9kdWxlX25hbWVzcGFjZQBfWFNfTW91
c2VfX01ldGFfX1JvbGVfYWRkX2JlZm9yZV9tb2RpZmllcgBfWFNfTW91c2VfX01ldGFfX1JvbGVf
YWRkX21ldGFjbGFzc19hY2Nlc3NvcgBfWFNfTW91c2VfX01ldGFfX1JvbGVfZ2V0X2JlZm9yZV9t
b2RpZmllcnMAX1hTX01vdXNlX19NZXRhX19UeXBlQ29uc3RyYWludF9faWRlbnRpdHkAX1hTX01v
dXNlX19NZXRhX19UeXBlQ29uc3RyYWludF9jaGVjawBfWFNfTW91c2VfX01ldGFfX1R5cGVDb25z
dHJhaW50X2NvbXBpbGVfdHlwZV9jb25zdHJhaW50AF9YU19Nb3VzZV9fT2JqZWN0X0JVSUxEQUxM
AF9YU19Nb3VzZV9fT2JqZWN0X0JVSUxEQVJHUwBfWFNfTW91c2VfX09iamVjdF9ERVNUUk9ZAF9Y
U19Nb3VzZV9fT2JqZWN0X25ldwBfWFNfTW91c2VfX1V0aWxfX1R5cGVDb25zdHJhaW50c19fcGFy
YW1ldGVyaXplX0FycmF5UmVmX2ZvcgBfWFNfTW91c2VfX1V0aWxfX19yZWdpc3Rlcl9tZXRhY2xh
c3Nfc3RvcmFnZQBfWFNfTW91c2VfX1V0aWxfZ2VuZXJhdGVfaXNhX3ByZWRpY2F0ZV9mb3IAX1hT
X01vdXNlX19VdGlsX2dldF9jb2RlX2luZm8AX1hTX01vdXNlX19VdGlsX2dldF9jb2RlX3BhY2th
Z2UAX1hTX01vdXNlX19VdGlsX2dldF9jb2RlX3JlZgBfWFNfTW91c2VfX1V0aWxfaW5zdGFsbF9z
dWJyb3V0aW5lcwBfWFNfTW91c2VfX1V0aWxfaXNfY2xhc3NfbG9hZGVkAF9YU19Nb3VzZV9fVXRp
bF9pc192YWxpZF9jbGFzc19uYW1lAF9YU19Nb3VzZV9hY2Nlc3NvcgBfWFNfTW91c2VfaW5oZXJp
dGFibGVfY2xhc3NfYWNjZXNzb3IAX1hTX01vdXNlX3JlYWRlcgBfWFNfTW91c2Vfc2ltcGxlX2Ns
ZWFyZXIAX1hTX01vdXNlX3NpbXBsZV9wcmVkaWNhdGUAX1hTX01vdXNlX3NpbXBsZV9yZWFkZXIA
X1hTX01vdXNlX3NpbXBsZV93cml0ZXIAX1hTX01vdXNlX3dyaXRlcgBfYm9vdF9Nb3VzZQBfYm9v
dF9Nb3VzZV9fTWV0YV9fQXR0cmlidXRlAF9ib290X01vdXNlX19NZXRhX19NZXRob2RfX0FjY2Vz
c29yX19YUwBfYm9vdF9Nb3VzZV9fVXRpbABfYm9vdF9Nb3VzZV9fVXRpbF9fVHlwZUNvbnN0cmFp
bnRzAF9tb3VzZV9hY2Nlc3Nvcl9nZW5lcmF0ZQBfbW91c2VfY2FsbDAAX21vdXNlX2NhbGwxAF9t
b3VzZV9jb2VyY2UAX21vdXNlX2dlbmVyYXRlX2Nhbl9wcmVkaWNhdGVfZm9yAF9tb3VzZV9nZW5l
cmF0ZV9pc2FfcHJlZGljYXRlX2ZvcgBfbW91c2VfZ2V0X2F0dHJpYnV0ZQBfbW91c2VfZ2V0X2F0
dHJpYnV0ZV9saXN0AF9tb3VzZV9nZXRfbWV0YWNsYXNzAF9tb3VzZV9nZXRfbmFtZXNwYWNlAF9t
b3VzZV9nZXRfeGEAX21vdXNlX2luc3RhbGxfc3ViAF9tb3VzZV9pbnN0YW5jZV9jbG9uZQBfbW91
c2VfaW5zdGFuY2VfY3JlYXRlAF9tb3VzZV9pbnN0YW5jZV9kZWxldGVfc2xvdABfbW91c2VfaW5z
dGFuY2VfZ2V0X3Nsb3QAX21vdXNlX2luc3RhbmNlX2hhc19zbG90AF9tb3VzZV9pbnN0YW5jZV9z
ZXRfc2xvdABfbW91c2VfaW5zdGFuY2Vfd2Vha2VuX3Nsb3QAX21vdXNlX2lzX2FuX2luc3RhbmNl
X29mAF9tb3VzZV9pc19jbGFzc19sb2FkZWQAX21vdXNlX21ldGhvZHMAX21vdXNlX21nX2ZpbmQA
X21vdXNlX211c3RfZGVmaW5lZABfbW91c2VfbXVzdF9yZWYAX21vdXNlX25hbWUAX21vdXNlX25h
bWVzcGFjZQBfbW91c2VfcGFja2FnZQBfbW91c2VfcHJlZGljYXRlX2NhbGwAX21vdXNlX3NpbXBs
ZV9hY2Nlc3Nvcl9nZW5lcmF0ZQBfbW91c2Vfc3Rhc2hfZmV0Y2gAX21vdXNlX3RjX0FueQBfbW91
c2VfdGNfQXJyYXlSZWYAX21vdXNlX3RjX0Jvb2wAX21vdXNlX3RjX0NsYXNzTmFtZQBfbW91c2Vf
dGNfQ29kZVJlZgBfbW91c2VfdGNfRGVmaW5lZABfbW91c2VfdGNfRmlsZUhhbmRsZQBfbW91c2Vf
dGNfR2xvYlJlZgBfbW91c2VfdGNfSGFzaFJlZgBfbW91c2VfdGNfSW50AF9tb3VzZV90Y19OdW0A
X21vdXNlX3RjX09iamVjdABfbW91c2VfdGNfUmVmAF9tb3VzZV90Y19SZWdleHBSZWYAX21vdXNl
X3RjX1JvbGVOYW1lAF9tb3VzZV90Y19TY2FsYXJSZWYAX21vdXNlX3RjX1N0cgBfbW91c2VfdGNf
VW5kZWYAX21vdXNlX3RjX1ZhbHVlAF9tb3VzZV90Y19jaGVjawBfbW91c2VfdGhyb3dfZXJyb3IA
X21vdXNlX3hhX2FwcGx5X3R5cGVfY29uc3RyYWludABfbW91c2VfeGFfc2V0X2RlZmF1bHQAX1BM
X0RCc3ViAF9QTF9jaGFyY2xhc3MAX1BMX2N1cnBhZABfUExfZGVmZ3YAX1BMX2Vycmd2AF9QTF9t
YXJrc3RhY2tfbWF4AF9QTF9tYXJrc3RhY2tfcHRyAF9QTF9uYQBfUExfb3AAX1BMX3BlcmxkYgBf
UExfcGhhc2UAX1BMX3Njb3Blc3RhY2tfaXgAX1BMX3N0YWNrX2Jhc2UAX1BMX3N0YWNrX21heABf
UExfc3RhY2tfc3AAX1BMX3N0YXR1c3ZhbHVlAF9QTF9zdl9ubwBfUExfc3ZfdW5kZWYAX1BMX3N2
X3llcwBfUExfdG1wc19mbG9vcgBfUExfdG1wc19peABfUExfdW5pdGNoZWNrYXYAX1BlcmxfYW1h
Z2ljX2RlcmVmX2NhbGwAX1BlcmxfYXZfZGVsZXRlAF9QZXJsX2F2X2V4dGVuZABfUGVybF9hdl9m
ZXRjaABfUGVybF9hdl9sZW4AX1BlcmxfYXZfcHVzaABfUGVybF9hdl9zdG9yZQBfUGVybF9hdl91
bnNoaWZ0AF9QZXJsX2Jsb2NrX2dpbW1lAF9QZXJsX2NhbGxfbGlzdABfUGVybF9jYWxsX21ldGhv
ZABfUGVybF9jYWxsX3B2AF9QZXJsX2NhbGxfc3YAX1BlcmxfY2t3YXJuAF9QZXJsX2Nyb2FrAF9Q
ZXJsX2Nyb2FrX3hzX3VzYWdlAF9QZXJsX2N2Z3Zfc2V0AF9QZXJsX2Zvcm0AX1BlcmxfZnJlZV90
bXBzAF9QZXJsX2dldF9jdgBfUGVybF9nZXRfY3ZuX2ZsYWdzAF9QZXJsX2dldF9yZV9hcmcAX1Bl
cmxfZ2V0X3N2AF9QZXJsX2dyb2tfbnVtYmVyAF9QZXJsX2d2X2FkZF9ieV90eXBlAF9QZXJsX2d2
X2VmdWxsbmFtZTQAX1BlcmxfZ3ZfZmV0Y2htZXRoX3B2bgBfUGVybF9ndl9mZXRjaG1ldGhfcHZu
X2F1dG9sb2FkAF9QZXJsX2d2X2ZldGNocHYAX1BlcmxfZ3ZfZmV0Y2hwdm5fZmxhZ3MAX1Blcmxf
Z3ZfaW5pdF9wdm4AX1BlcmxfZ3Zfc3Rhc2hwdm4AX1BlcmxfZ3Zfc3Rhc2hzdgBfUGVybF9odl9j
b21tb24AX1BlcmxfaHZfY29tbW9uX2tleV9sZW4AX1BlcmxfaHZfaXRlcmluaXQAX1BlcmxfaHZf
aXRlcmtleXN2AF9QZXJsX2h2X2l0ZXJuZXh0X2ZsYWdzAF9QZXJsX2h2X2l0ZXJ2YWwAX1Blcmxf
aHZfcGxhY2Vob2xkZXJzX2dldABfUGVybF9sb29rc19saWtlX251bWJlcgBfUGVybF9tYXJrc3Rh
Y2tfZ3JvdwBfUGVybF9tZ19maW5kAF9QZXJsX21nX2dldABfUGVybF9tZ19zZXQAX1BlcmxfbXJv
X2dldF9saW5lYXJfaXNhAF9QZXJsX21yb19tZXRob2RfY2hhbmdlZF9pbgBfUGVybF9uZXdIVmh2
AF9QZXJsX25ld1JWAF9QZXJsX25ld1JWX25vaW5jAF9QZXJsX25ld1NWAF9QZXJsX25ld1NWX3R5
cGUAX1BlcmxfbmV3U1ZwdmYAX1BlcmxfbmV3U1Zwdm4AX1BlcmxfbmV3U1Zwdm5fZmxhZ3MAX1Bl
cmxfbmV3U1Zwdm5fc2hhcmUAX1BlcmxfbmV3U1ZzdgBfUGVybF9uZXdTVnV2AF9QZXJsX25ld1hT
AF9QZXJsX3BvcF9zY29wZQBfUGVybF9wdXNoX3Njb3BlAF9QZXJsX3NhdmVfSTMyAF9QZXJsX3Nh
dmVfZ2VuZXJpY19zdnJlZgBfUGVybF9zYXZlX3NwdHIAX1Blcmxfc2F2ZV9zdHJsZW4AX1Blcmxf
c3RhY2tfZ3JvdwBfUGVybF9zdl8yYm9vbF9mbGFncwBfUGVybF9zdl8yY3YAX1Blcmxfc3ZfMm1v
cnRhbABfUGVybF9zdl8ycHZfZmxhZ3MAX1Blcmxfc3ZfYmxlc3MAX1Blcmxfc3ZfY2F0cHZmAF9Q
ZXJsX3N2X2ZyZWUyAF9QZXJsX3N2X21hZ2ljZXh0AF9QZXJsX3N2X21vcnRhbGNvcHlfZmxhZ3MA
X1Blcmxfc3ZfbmV3bW9ydGFsAF9QZXJsX3N2X3J2d2Vha2VuAF9QZXJsX3N2X3NldGl2AF9QZXJs
X3N2X3NldHB2ZgBfUGVybF9zdl9zZXRwdm4AX1Blcmxfc3Zfc2V0c3ZfZmxhZ3MAX1Blcmxfc3Zf
c2V0c3ZfbWcAX1Blcmxfc3Zfc2V0dXYAX1Blcmxfc3ZfdHJ1ZQBfUGVybF92bmV3U1ZwdmYAX1Bl
cmxfd2FybmVyAF9QZXJsX3hzX2FwaXZlcnNpb25fYm9vdGNoZWNrAF9QZXJsX3hzX3ZlcnNpb25f
Ym9vdGNoZWNrAF9fX3NwcmludGZfY2hrAF9fX3N0YWNrX2Noa19mYWlsAF9fX3N0YWNrX2Noa19n
dWFyZABfc3RyY21wAF9zdHJuY21wAA==
...
use MIME::Base64 ();
use File::Path ();
use File::Basename ();
use Config ();
my $dir = "$ENV{HOME}/.perl-fatpack-xs";
my $identity = "5.$Config::Config{PERL_VERSION}/$Config::Config{archname}";
for my $path (sort keys %fatpack) {
    next if $path !~ /^$identity/;
    my $abs_path = "$dir/$path";
    next if -f $abs_path;
    File::Path::mkpath( "$dir/" . File::Basename::dirname($path) );
    open my $fh, ">:raw", $abs_path
        or die "Cannot open $abs_path: $!\n";
    print {$fh} MIME::Base64::decode_base64($fatpack{$path});
}
unshift @INC, "$dir/$identity";
} # END of fatpack xs

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Mouse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE';
  package Mouse;use 5.008_005;use Mouse::Exporter;our$VERSION='2.4.1';use Carp ();use Scalar::Util ();use Mouse::Util ();use Mouse::Meta::Module;use Mouse::Meta::Class;use Mouse::Meta::Role;use Mouse::Meta::Attribute;use Mouse::Object;use Mouse::Util::TypeConstraints ();Mouse::Exporter->setup_import_methods(as_is=>[qw(extends with has before after around override super augment inner),\&Scalar::Util::blessed,\&Carp::confess,],);sub extends {Mouse::Meta::Class->initialize(scalar caller)->superclasses(@_);return}sub with {Mouse::Util::apply_all_roles(scalar(caller),@_);return}sub has {my$meta=Mouse::Meta::Class->initialize(scalar caller);my$name=shift;$meta->throw_error(q{Usage: has 'name' => ( key => value, ... )})if @_ % 2;for my$n(ref($name)? @{$name}: $name){$meta->add_attribute($n=>@_)}return}sub before {my$meta=Mouse::Meta::Class->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_before_method_modifier($name=>$code)}return}sub after {my$meta=Mouse::Meta::Class->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_after_method_modifier($name=>$code)}return}sub around {my$meta=Mouse::Meta::Class->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_around_method_modifier($name=>$code)}return}our$SUPER_PACKAGE;our$SUPER_BODY;our@SUPER_ARGS;sub super {return if defined$SUPER_PACKAGE && $SUPER_PACKAGE ne caller();return if!defined$SUPER_BODY;$SUPER_BODY->(@SUPER_ARGS)}sub override {Mouse::Meta::Class->initialize(scalar caller)->add_override_method_modifier(@_)}our%INNER_BODY;our%INNER_ARGS;sub inner {my$pkg=caller();if (my$body=$INNER_BODY{$pkg}){my$args=$INNER_ARGS{$pkg};local$INNER_ARGS{$pkg};local$INNER_BODY{$pkg};return$body->(@{$args})}else {return}}sub augment {Mouse::Meta::Class->initialize(scalar caller)->add_augment_method_modifier(@_);return}sub init_meta {shift;my%args=@_;my$class=$args{for_class}or confess("Cannot call init_meta without specifying a for_class");my$base_class=$args{base_class}|| 'Mouse::Object';my$metaclass=$args{metaclass}|| 'Mouse::Meta::Class';my$meta=$metaclass->initialize($class);$meta->add_method(meta=>sub{return$metaclass->initialize(ref($_[0])|| $_[0])});$meta->superclasses($base_class)unless$meta->superclasses;Mouse::Util::TypeConstraints::class_type($class)unless Mouse::Util::TypeConstraints::find_type_constraint($class);return$meta}1;
MOUSE

$fatpacked{"Mouse/Exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_EXPORTER';
  package Mouse::Exporter;use strict;use warnings;use Carp ();my%SPEC;my$strict_bits;my$warnings_extra_bits;BEGIN{$strict_bits=strict::bits(qw(subs refs vars));$warnings_extra_bits=warnings::bits(FATAL=>'recursion')}require Mouse::Util;sub import{$^H |= $strict_bits;${^WARNING_BITS} |= $warnings::Bits{all};${^WARNING_BITS} |= $warnings_extra_bits;return}sub setup_import_methods{my($class,%args)=@_;my$exporting_package=$args{exporting_package}||= caller();my($import,$unimport)=$class->build_import_methods(%args);Mouse::Util::install_subroutines($exporting_package,import=>$import,unimport=>$unimport,export_to_level=>sub {my($package,$level,undef,@args)=@_;$package->import({into_level=>$level + 1 },@args)},export=>sub {my($package,$into,@args)=@_;$package->import({into=>$into },@args)},);return}sub build_import_methods{my($self,%args)=@_;my$exporting_package=$args{exporting_package}||= caller();$SPEC{$exporting_package}=\%args;my@export_from;if($args{also}){my%seen;my@stack=($exporting_package);while(my$current=shift@stack){push@export_from,$current;my$also=$SPEC{$current}{also}or next;push@stack,grep{!$seen{$_}++}ref($also)? @{$also}: $also}}else{@export_from=($exporting_package)}my%exports;my@removables;my@all;my@init_meta_methods;for my$package(@export_from){my$spec=$SPEC{$package}or next;if(my$as_is=$spec->{as_is}){for my$thingy (@{$as_is}){my($code_package,$code_name,$code);if(ref($thingy)){$code=$thingy;($code_package,$code_name)=Mouse::Util::get_code_info($code)}else{$code_package=$package;$code_name=$thingy;no strict 'refs';$code=\&{$code_package .'::' .$code_name}}push@all,$code_name;$exports{$code_name}=$code;if($code_package eq $package){push@removables,$code_name}}}if(my$init_meta=$package->can('init_meta')){if(!grep{$_==$init_meta}@init_meta_methods){push@init_meta_methods,$init_meta}}}$args{EXPORTS}=\%exports;$args{REMOVABLES}=\@removables;$args{groups}{all}||= \@all;if(my$default_list=$args{groups}{default}){my%default;for my$keyword(@{$default_list}){$default{$keyword}=$exports{$keyword}|| Carp::confess(qq{The $exporting_package package does not export "$keyword"})}$args{DEFAULT}=\%default}else{$args{groups}{default}||= \@all;$args{DEFAULT}=$args{EXPORTS}}if(@init_meta_methods){$args{INIT_META}=\@init_meta_methods}return (\&do_import,\&do_unimport)}sub do_import {my($package,@args)=@_;my$spec=$SPEC{$package}|| Carp::confess("The package $package package does not use Mouse::Exporter");my$into=_get_caller_package(ref($args[0])? shift@args : undef);my@exports;my@traits;while(@args){my$arg=shift@args;if($arg =~ s/^-//){if($arg eq 'traits'){push@traits,ref($args[0])? @{shift(@args)}: shift(@args)}else {Mouse::Util::not_supported("-$arg")}}elsif($arg =~ s/^://){my$group=$spec->{groups}{$arg}|| Carp::confess(qq{The $package package does not export the group "$arg"});push@exports,@{$group}}else{push@exports,$arg}}$^H |= $strict_bits;${^WARNING_BITS} |= $warnings::Bits{all};${^WARNING_BITS} |= $warnings_extra_bits;if($spec->{INIT_META}){my$meta;for my$init_meta(@{$spec->{INIT_META}}){$meta=$package->$init_meta(for_class=>$into)}if(@traits){my$type=(split /::/,ref$meta)[-1];@traits=map{ref($_)? $_ : Mouse::Util::resolve_metaclass_alias($type=>$_,trait=>1)}@traits;require Mouse::Util::MetaRole;Mouse::Util::MetaRole::apply_metaroles(for=>$into,Mouse::Util::is_a_metarole($into->meta)? (role_metaroles=>{role=>\@traits }): (class_metaroles=>{class=>\@traits }),)}}elsif(@traits){Carp::confess("Cannot provide traits when $package does not have an init_meta() method")}if(@exports){my@export_table;for my$keyword(@exports){push@export_table,$keyword=>($spec->{EXPORTS}{$keyword}|| Carp::confess(qq{The $package package does not export "$keyword"}))}Mouse::Util::install_subroutines($into,@export_table)}else{Mouse::Util::install_subroutines($into,%{$spec->{DEFAULT}})}return}sub do_unimport {my($package,$arg)=@_;my$spec=$SPEC{$package}|| Carp::confess("The package $package does not use Mouse::Exporter");my$from=_get_caller_package($arg);my$stash=do{no strict 'refs';\%{$from .'::'}};for my$keyword (@{$spec->{REMOVABLES}}){next if!exists$stash->{$keyword};my$gv=\$stash->{$keyword};if(ref($gv)eq 'GLOB' && *{$gv}{CODE}==$spec->{EXPORTS}{$keyword}){delete$stash->{$keyword}}}return}sub _get_caller_package {my($arg)=@_;if(ref$arg){return defined($arg->{into})? $arg->{into}: defined($arg->{into_level})? scalar caller(1 + $arg->{into_level}): scalar caller(1)}else{return scalar caller(1)}}1;
MOUSE_EXPORTER

$fatpacked{"Mouse/Meta/Attribute.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_ATTRIBUTE';
  package Mouse::Meta::Attribute;use Mouse::Util qw(:meta);use Carp ();use Mouse::Meta::TypeConstraint;my%valid_options=map {$_=>undef}('accessor','auto_deref','builder','clearer','coerce','default','documentation','does','handles','init_arg','insertion_order','is','isa','lazy','lazy_build','name','predicate','reader','required','traits','trigger','type_constraint','weak_ref','writer','associated_class','associated_methods','__METACLASS__','provides','curries',);our@CARP_NOT=qw(Mouse::Meta::Class);sub new {my$class=shift;my$name=shift;my$args=$class->Mouse::Object::BUILDARGS(@_);$class->_process_options($name,$args);$args->{name}=$name;my@bad=grep{!exists$valid_options{$_}}keys %{$args};if(@bad && $class ne __PACKAGE__){my%valid_attrs=(map {$_=>undef}grep {defined}map {$_->init_arg()}$class->meta->get_all_attributes());@bad=grep{!exists$valid_attrs{$_}}@bad}if(@bad){Carp::carp("Found unknown argument(s) passed to '$name' attribute constructor in '$class': " .Mouse::Util::english_list(@bad))}my$self=bless$args,$class;if($class ne __PACKAGE__){$class->meta->_initialize_object($self,$args)}return$self}sub has_read_method {$_[0]->has_reader || $_[0]->has_accessor}sub has_write_method {$_[0]->has_writer || $_[0]->has_accessor}sub get_read_method {$_[0]->reader || $_[0]->accessor}sub get_write_method {$_[0]->writer || $_[0]->accessor}sub get_read_method_ref{my($self)=@_;return$self->{_mouse_cache_read_method_ref}||= $self->_get_accessor_method_ref('get_read_method','_generate_reader')}sub get_write_method_ref{my($self)=@_;return$self->{_mouse_cache_write_method_ref}||= $self->_get_accessor_method_ref('get_write_method','_generate_writer')}sub interpolate_class{my($class,$args)=@_;if(my$metaclass=delete$args->{metaclass}){$class=Mouse::Util::resolve_metaclass_alias(Attribute=>$metaclass)}my@traits;if(my$traits_ref=delete$args->{traits}){for (my$i=0;$i < @{$traits_ref};$i++){my$trait=Mouse::Util::resolve_metaclass_alias(Attribute=>$traits_ref->[$i],trait=>1);next if$class->does($trait);push@traits,$trait;push@traits,$traits_ref->[++$i]if ref($traits_ref->[$i+1])}if (@traits){$class=Mouse::Meta::Class->create_anon_class(superclasses=>[$class ],roles=>\@traits,cache=>1,)->name}}return($class,@traits)}sub verify_against_type_constraint {my ($self,$value)=@_;my$type_constraint=$self->{type_constraint};return 1 if!$type_constraint;return 1 if$type_constraint->check($value);$self->_throw_type_constraint_error($value,$type_constraint)}sub _throw_type_constraint_error {my($self,$value,$type)=@_;$self->throw_error(sprintf q{Attribute (%s) does not pass the type constraint because: %s},$self->name,$type->get_message($value),)}sub illegal_options_for_inheritance {return qw(reader writer accessor clearer predicate)}sub clone_and_inherit_options{my$self=shift;my$args=$self->Mouse::Object::BUILDARGS(@_);for my$illegal($self->illegal_options_for_inheritance){if(exists$args->{$illegal}and exists$self->{$illegal}){$self->throw_error("Illegal inherited option: $illegal")}}for my$name(keys %{$self}){if(!exists$args->{$name}){$args->{$name}=$self->{$name}}}my($attribute_class,@traits)=ref($self)->interpolate_class($args);$args->{traits}=\@traits if@traits;for my$attr(keys %{$args}){if($attr =~ /\A _mouse_cache_/xms){delete$args->{$attr}}}if($args->{lazy_build}){delete$args->{default}}return$attribute_class->new($self->name,$args)}sub _get_accessor_method_ref {my($self,$type,$generator)=@_;my$metaclass=$self->associated_class || $self->throw_error('No asocciated class for ' .$self->name);my$accessor=$self->$type();if($accessor){return$metaclass->get_method_body($accessor)}else{return$self->accessor_metaclass->$generator($self,$metaclass)}}sub set_value {my($self,$object,$value)=@_;return$self->get_write_method_ref()->($object,$value)}sub get_value {my($self,$object)=@_;return$self->get_read_method_ref()->($object)}sub has_value {my($self,$object)=@_;my$accessor_ref=$self->{_mouse_cache_predicate_ref}||= $self->_get_accessor_method_ref('predicate','_generate_predicate');return$accessor_ref->($object)}sub clear_value {my($self,$object)=@_;my$accessor_ref=$self->{_mouse_cache_crealer_ref}||= $self->_get_accessor_method_ref('clearer','_generate_clearer');return$accessor_ref->($object)}sub associate_method{my($attribute)=@_;$attribute->{associated_methods}++;return}sub install_accessors{my($attribute)=@_;my$metaclass=$attribute->associated_class;my$accessor_class=$attribute->accessor_metaclass;for my$type(qw(accessor reader writer predicate clearer)){if(exists$attribute->{$type}){my$generator='_generate_' .$type;my$code=$accessor_class->$generator($attribute,$metaclass);my$name=$attribute->{$type};$metaclass->add_method($name=>$code);$attribute->associate_method($name)}}if(exists$attribute->{handles}){my%handles=$attribute->_canonicalize_handles();while(my($handle,$method_to_call)=each%handles){next if Mouse::Object->can($handle);if($metaclass->has_method($handle)){$attribute->throw_error("You cannot overwrite a locally defined method ($handle) with a delegation")}$metaclass->add_method($handle=>$attribute->_make_delegation_method($handle,$method_to_call));$attribute->associate_method($handle)}}return}sub delegation_metaclass() {'Mouse::Meta::Method::Delegation'}sub _canonicalize_handles {my($self)=@_;my$handles=$self->{handles};my$handle_type=ref$handles;if ($handle_type eq 'HASH'){return %$handles}elsif ($handle_type eq 'ARRAY'){return map {$_=>$_}@$handles}elsif ($handle_type eq 'Regexp'){my$meta=$self->_find_delegate_metaclass();return map {$_=>$_}grep {/$handles/}Mouse::Util::is_a_metarole($meta)? $meta->get_method_list : $meta->get_all_method_names}elsif ($handle_type eq 'CODE'){return$handles->($self,$self->_find_delegate_metaclass())}else {$self->throw_error("Unable to canonicalize the 'handles' option with $handles")}}sub _find_delegate_metaclass {my($self)=@_;my$meta;if($self->{isa}){$meta=Mouse::Meta::Class->initialize("$self->{isa}")}elsif($self->{does}){$meta=Mouse::Util::get_metaclass_by_name("$self->{does}")}defined($meta)or $self->throw_error("Cannot find delegate metaclass for attribute " .$self->name);return$meta}sub _make_delegation_method {my($self,$handle,$method_to_call)=@_;return Mouse::Util::load_class($self->delegation_metaclass)->_generate_delegation($self,$handle,$method_to_call)}1;
MOUSE_META_ATTRIBUTE

$fatpacked{"Mouse/Meta/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_CLASS';
  package Mouse::Meta::Class;use Mouse::Util qw/:meta/;use Scalar::Util ();use Mouse::Meta::Module;our@ISA=qw(Mouse::Meta::Module);our@CARP_NOT=qw(Mouse);sub attribute_metaclass;sub method_metaclass;sub constructor_class;sub destructor_class;sub _construct_meta {my($class,%args)=@_;$args{attributes}={};$args{methods}={};$args{roles}=[];$args{superclasses}=do {no strict 'refs';\@{$args{package}.'::ISA'}};my$self=bless \%args,ref($class)|| $class;if(ref($self)ne __PACKAGE__){$self->meta->_initialize_object($self,\%args)}return$self}sub create_anon_class{my$self=shift;return$self->create(undef,@_)}sub is_anon_class;sub roles;sub calculate_all_roles {my$self=shift;my%seen;return grep {!$seen{$_->name }++}map {$_->calculate_all_roles}@{$self->roles}}sub superclasses {my$self=shift;if (@_){for my$super(@_){Mouse::Util::load_class($super);my$meta=Mouse::Util::get_metaclass_by_name($super);next if$self->verify_superclass($super,$meta);$self->_reconcile_with_superclass_meta($meta)}return @{$self->{superclasses}}=@_}return @{$self->{superclasses}}}sub verify_superclass {my($self,$super,$super_meta)=@_;if(defined$super_meta){if(Mouse::Util::is_a_metarole($super_meta)){$self->throw_error("You cannot inherit from a Mouse Role ($super)")}}else {my$mm=$super->can('meta');if(!($mm && $mm==\&Mouse::Util::meta)){if($super->can('new')or $super->can('DESTROY')){$self->inherit_from_foreign_class($super)}}return 1}return$self->isa(ref$super_meta)}sub inherit_from_foreign_class {my($class,$super)=@_;if($ENV{PERL_MOUSE_STRICT}){Carp::carp("You inherit from non-Mouse class ($super)," ." but it is unlikely to work correctly." ." Please consider using MouseX::Foreign")}return}my@MetaClassTypes=('attribute','method','constructor','destructor',);sub _reconcile_with_superclass_meta {my($self,$other)=@_;my%metaroles;for my$metaclass_type(@MetaClassTypes){my$accessor=$self->can($metaclass_type .'_metaclass')|| $self->can($metaclass_type .'_class');my$other_c=$other->$accessor();my$self_c=$self->$accessor();if(!$self_c->isa($other_c)){$metaroles{$metaclass_type}=[$self_c->meta->_collect_roles($other_c->meta)]}}$metaroles{class}=[$self->meta->_collect_roles($other->meta)];require Mouse::Util::MetaRole;$_[0]=Mouse::Util::MetaRole::apply_metaroles(for=>$self,class_metaroles=>\%metaroles,);return}sub _collect_roles {my ($self,$other)=@_;my@self_lin_isa=$self->linearized_isa;my@other_lin_isa=$other->linearized_isa;my(@self_anon_supers,@other_anon_supers);push@self_anon_supers,shift@self_lin_isa while$self_lin_isa[0]->meta->is_anon_class;push@other_anon_supers,shift@other_lin_isa while$other_lin_isa[0]->meta->is_anon_class;my$common_ancestor=$self_lin_isa[0]eq $other_lin_isa[0]&& $self_lin_isa[0];if(!$common_ancestor){$self->throw_error(sprintf '%s cannot have %s as a super class because of their metaclass incompatibility',$self->name,$other->name)}my%seen;return sort grep {!$seen{$_}++}(map{$_->name}map{$_->meta->calculate_all_roles}@self_anon_supers),(map{$_->name}map{$_->meta->calculate_all_roles}@other_anon_supers),}sub find_method_by_name {my($self,$method_name)=@_;defined($method_name)or $self->throw_error('You must define a method name to find');for my$class($self->linearized_isa){my$method=$self->initialize($class)->get_method($method_name);return$method if defined$method}return undef}sub get_all_methods {my($self)=@_;return map{$self->find_method_by_name($_)}$self->get_all_method_names}sub get_all_method_names {my$self=shift;my%uniq;return grep {$uniq{$_}++==0}map {Mouse::Meta::Class->initialize($_)->get_method_list()}$self->linearized_isa}sub find_attribute_by_name {my($self,$name)=@_;defined($name)or $self->throw_error('You must define an attribute name to find');for my$attr($self->get_all_attributes){return$attr if$attr->name eq $name}return undef}sub add_attribute {my$self=shift;my($attr,$name);if(Scalar::Util::blessed($_[0])){$attr=$_[0];$attr->isa('Mouse::Meta::Attribute')|| $self->throw_error("Your attribute must be an instance of Mouse::Meta::Attribute (or a subclass)");$name=$attr->name}else{$name=shift;my%args=(@_==1)? %{$_[0]}: @_;defined($name)or $self->throw_error('You must provide a name for the attribute');if ($name =~ s/^\+//){my$inherited_attr=$self->find_attribute_by_name($name)or $self->throw_error("Could not find an attribute by the name of '$name' to inherit from in ".$self->name);$attr=$inherited_attr->clone_and_inherit_options(%args)}else{my($attribute_class,@traits)=$self->attribute_metaclass->interpolate_class(\%args);$args{traits}=\@traits if@traits;$attr=$attribute_class->new($name,%args)}}Scalar::Util::weaken($attr->{associated_class}=$self);$attr->install_accessors();$attr->{insertion_order}=keys %{$self->{attributes}};$self->{attributes}{$name}=$attr;$self->_invalidate_metaclass_cache();if(!$attr->{associated_methods}&& ($attr->{is}|| '')ne 'bare'){Carp::carp(qq{Attribute ($name) of class }.$self->name .qq{ has no associated methods (did you mean to provide an "is" argument?)})}return$attr}sub _calculate_all_attributes {my($self)=@_;my%seen;my@all_attrs;for my$class($self->linearized_isa){my$meta=Mouse::Util::get_metaclass_by_name($class)or next;my@attrs=grep {!$seen{$_->name}++}values %{$meta->{attributes}};@attrs=sort {$b->{insertion_order}<=> $a->{insertion_order}}@attrs;push@all_attrs,@attrs}return [reverse@all_attrs]}sub linearized_isa;sub new_object;sub clone_object;sub immutable_options {my ($self,@args)=@_;return (inline_constructor=>1,inline_destructor=>1,constructor_name=>'new',@args,)}sub make_immutable {my$self=shift;my%args=$self->immutable_options(@_);$self->{is_immutable}++;if ($args{inline_constructor}){$self->add_method($args{constructor_name}=>Mouse::Util::load_class($self->constructor_class)->_generate_constructor($self,\%args))}if ($args{inline_destructor}){$self->add_method(DESTROY=>Mouse::Util::load_class($self->destructor_class)->_generate_destructor($self,\%args))}return 1}sub make_mutable {my($self)=@_;$self->{is_immutable}=0;return}sub is_immutable;sub is_mutable {!$_[0]->is_immutable}sub _install_modifier {my($self,$type,$name,$code)=@_;my$into=$self->name;my$original=$into->can($name)or $self->throw_error("The method '$name' was not found in the inheritance hierarchy for $into");my$modifier_table=$self->{modifiers}{$name};if(!$modifier_table){my(@before,@after,@around);my$cache=$original;my$modified=sub {if(@before){for my$c (@before){$c->(@_)}}unless(@after){return$cache->(@_)}if(wantarray){my@rval=$cache->(@_);for my$c(@after){$c->(@_)}return@rval}elsif(defined wantarray){my$rval=$cache->(@_);for my$c(@after){$c->(@_)}return$rval}else{$cache->(@_);for my$c(@after){$c->(@_)}return}};$self->{modifiers}{$name}=$modifier_table={original=>$original,before=>\@before,after=>\@after,around=>\@around,cache=>\$cache,};$self->add_method($name=>$modified)}if($type eq 'before'){unshift @{$modifier_table->{before}},$code}elsif($type eq 'after'){push @{$modifier_table->{after}},$code}else{push @{$modifier_table->{around}},$code;my$next=${$modifier_table->{cache}};${$modifier_table->{cache}}=sub{$code->($next,@_)}}return}sub add_before_method_modifier {my ($self,$name,$code)=@_;$self->_install_modifier('before',$name,$code)}sub add_around_method_modifier {my ($self,$name,$code)=@_;$self->_install_modifier('around',$name,$code)}sub add_after_method_modifier {my ($self,$name,$code)=@_;$self->_install_modifier('after',$name,$code)}sub add_override_method_modifier {my ($self,$name,$code)=@_;if($self->has_method($name)){$self->throw_error("Cannot add an override method if a local method is already present")}my$package=$self->name;my$super_body=$package->can($name)or $self->throw_error("You cannot override '$name' because it has no super method");$self->add_method($name=>sub {local$Mouse::SUPER_PACKAGE=$package;local$Mouse::SUPER_BODY=$super_body;local@Mouse::SUPER_ARGS=@_;&{$code}});return}sub add_augment_method_modifier {my ($self,$name,$code)=@_;if($self->has_method($name)){$self->throw_error("Cannot add an augment method if a local method is already present")}my$super=$self->find_method_by_name($name)or $self->throw_error("You cannot augment '$name' because it has no super method");my$super_package=$super->package_name;my$super_body=$super->body;$self->add_method($name=>sub {local$Mouse::INNER_BODY{$super_package}=$code;local$Mouse::INNER_ARGS{$super_package}=[@_];&{$super_body}});return}sub does_role {my ($self,$role_name)=@_;(defined$role_name)|| $self->throw_error("You must supply a role name to look for");$role_name=$role_name->name if ref$role_name;for my$class ($self->linearized_isa){my$meta=Mouse::Util::get_metaclass_by_name($class)or next;for my$role (@{$meta->roles}){return 1 if$role->does_role($role_name)}}return 0}1;
MOUSE_META_CLASS

$fatpacked{"Mouse/Meta/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_METHOD';
  package Mouse::Meta::Method;use Mouse::Util qw(:meta);use Scalar::Util ();use overload '=='=>'_equal','eq'=>'_equal','&{}'=>sub{$_[0]->body},fallback=>1,;sub wrap {my$class=shift;unshift @_,'body' if @_ % 2!=0;return$class->_new(@_)}sub _new{my($class,%args)=@_;my$self=bless \%args,$class;if($class ne __PACKAGE__){$self->meta->_initialize_object($self,\%args)}return$self}sub body {$_[0]->{body}}sub name {$_[0]->{name}}sub package_name {$_[0]->{package}}sub associated_metaclass {$_[0]->{associated_metaclass}}sub fully_qualified_name {my($self)=@_;return$self->package_name .'::' .$self->name}sub _equal {my($l,$r)=@_;return Scalar::Util::blessed($r)&& $l->body==$r->body && $l->name eq $r->name && $l->package_name eq $r->package_name}1;
MOUSE_META_METHOD

$fatpacked{"Mouse/Meta/Method/Accessor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_METHOD_ACCESSOR';
  package Mouse::Meta::Method::Accessor;use Mouse::Util qw(:meta);use constant _MOUSE_DEBUG=>$ENV{MOUSE_DEBUG}? 1 : 0;sub _inline_slot{my(undef,$self_var,$attr_name)=@_;return sprintf '%s->{q{%s}}',$self_var,$attr_name}sub _generate_accessor_any{my($method_class,$type,$attribute,$class)=@_;my$name=$attribute->name;my$default=$attribute->default;my$constraint=$attribute->type_constraint;my$builder=$attribute->builder;my$trigger=$attribute->trigger;my$is_weak=$attribute->is_weak_ref;my$should_deref=$attribute->should_auto_deref;my$should_coerce=(defined($constraint)&& $constraint->has_coercion && $attribute->should_coerce);my$compiled_type_constraint=defined($constraint)? $constraint->_compiled_type_constraint : undef;my$self='$_[0]';my$slot=$method_class->_inline_slot($self,$name);;my$accessor=sprintf(qq{package %s;\n#line 1 "%s-accessor for %s (%s)"\n},$class->name,$type,$name,__FILE__)."sub {\n";if ($type eq 'rw' || $type eq 'wo'){if($type eq 'rw'){$accessor .= 'if (scalar(@_) >= 2) {' ."\n"}else{$accessor .= 'if(@_ < 2){ Carp::confess("Not enough arguments for the writer of $name") }'.'{' ."\n"}my$value='$_[1]';if (defined$constraint){if ($should_coerce){$accessor .= "\n".'my $val = $constraint->coerce('.$value.');';$value='$val'}$accessor .= "\n".'$compiled_type_constraint->('.$value.') or
                      $attribute->_throw_type_constraint_error('.$value.', $constraint);' ."\n"}$accessor .= 'return ' if!$is_weak &&!$trigger &&!$should_deref;$accessor .= "my \@old_value = exists $slot ? $slot : ();\n" if$trigger;$accessor .= "$slot = $value;\n";if ($is_weak){$accessor .= "Scalar::Util::weaken($slot) if ref $slot;\n"}if ($trigger){$accessor .= '$trigger->('.$self.', '.$value.', @old_value);' ."\n"}$accessor .= "}\n"}elsif($type eq 'ro'){$accessor .= 'Carp::confess("Cannot assign a value to a read-only accessor of $name") if scalar(@_) >= 2;' ."\n"}else{$class->throw_error("Unknown accessor type '$type'")}if ($attribute->is_lazy and $type ne 'wo'){my$value;if (defined$builder){$value="$self->\$builder()"}elsif (ref($default)eq 'CODE'){$value="$self->\$default()"}else{$value='$default'}$accessor .= "els" if$type eq 'rw';$accessor .= "if(!exists $slot){\n";if($should_coerce){$accessor .= "$slot = \$constraint->coerce($value)"}elsif(defined$constraint){$accessor .= "my \$tmp = $value;\n";$accessor .= "\$compiled_type_constraint->(\$tmp)";$accessor .= " || \$attribute->_throw_type_constraint_error(\$tmp, \$constraint);\n";$accessor .= "$slot = \$tmp;\n"}else{$accessor .= "$slot = $value;\n"}if ($is_weak){$accessor .= "Scalar::Util::weaken($slot) if ref $slot;\n"}$accessor .= "}\n"}if ($should_deref){if ($constraint->is_a_type_of('ArrayRef')){$accessor .= "return \@{ $slot || [] } if wantarray;\n"}elsif($constraint->is_a_type_of('HashRef')){$accessor .= "return \%{ $slot || {} } if wantarray;\n"}else{$class->throw_error("Can not auto de-reference the type constraint " .$constraint->name)}}$accessor .= "return $slot;\n}\n";warn$accessor if _MOUSE_DEBUG;my$code;my$e=do{local $@;$code=eval$accessor;$@};die$e if$e;return$code}sub _generate_accessor{my$self=shift;return$self->_generate_accessor_any(rw=>@_)}sub _generate_reader {my$self=shift;return$self->_generate_accessor_any(ro=>@_)}sub _generate_writer {my$self=shift;return$self->_generate_accessor_any(wo=>@_)}sub _generate_predicate {my(undef,$attribute)=@_;my$slot=$attribute->name;return sub{return exists $_[0]->{$slot}}}sub _generate_clearer {my(undef,$attribute)=@_;my$slot=$attribute->name;return sub{delete $_[0]->{$slot}}}1;
MOUSE_META_METHOD_ACCESSOR

$fatpacked{"Mouse/Meta/Method/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_METHOD_CONSTRUCTOR';
  package Mouse::Meta::Method::Constructor;use Mouse::Util qw(:meta);use constant _MOUSE_DEBUG=>$ENV{MOUSE_DEBUG}? 1 : 0;sub _inline_slot{my(undef,$self_var,$attr_name)=@_;return sprintf '%s->{q{%s}}',$self_var,$attr_name}sub _generate_constructor {my ($class,$metaclass,$args)=@_;my$associated_metaclass_name=$metaclass->name;my$buildall=$class->_generate_BUILDALL($metaclass);my$buildargs=$class->_generate_BUILDARGS($metaclass);my$initializer=$metaclass->{_mouse_cache}{_initialize_object}||= $class->_generate_initialize_object($metaclass);my$source=sprintf(<<'EOT',__FILE__,$metaclass->name,$buildargs,$buildall);warn$source if _MOUSE_DEBUG;my$body;my$e=do{local $@;$body=eval$source;$@};die$e if$e;return$body}sub _generate_initialize_object {my ($method_class,$metaclass)=@_;my@attrs=$metaclass->get_all_attributes;my@checks=map {$_ && $_->_compiled_type_constraint}map {$_->type_constraint}@attrs;my@res;my$has_triggers;my$strict=$metaclass->strict_constructor;if($strict){push@res,'my $used = 0;'}for my$index (0 .. @attrs - 1){my$code='';my$attr=$attrs[$index];my$key=$attr->name;my$init_arg=$attr->init_arg;my$type_constraint=$attr->type_constraint;my$is_weak_ref=$attr->is_weak_ref;my$need_coercion;my$instance_slot=$method_class->_inline_slot('$instance',$key);my$attr_var="\$attrs[$index]";my$constraint_var;if(defined$type_constraint){$constraint_var="$attr_var\->{type_constraint}";$need_coercion=($attr->should_coerce && $type_constraint->has_coercion)}$code .= "# initialize $key\n";my$post_process='';if(defined$type_constraint){$post_process .= "\$checks[$index]->($instance_slot)\n";$post_process .= "  or $attr_var->_throw_type_constraint_error($instance_slot, $constraint_var);\n"}if (defined$init_arg){my$value="\$args->{q{$init_arg}}";$code .= "if (exists $value) {\n";if($need_coercion){$value="$constraint_var->coerce($value)"}$code .= "$instance_slot = $value;\n";$code .= $post_process;if ($attr->has_trigger){$has_triggers++;$code .= "push \@triggers, [$attr_var\->{trigger}, $instance_slot];\n"}if ($strict){$code .= '++$used;' ."\n"}$code .= "\n} else {\n"}if ($attr->has_default || $attr->has_builder){unless ($attr->is_lazy){my$default=$attr->default;my$builder=$attr->builder;my$value;if (defined($builder)){$value="\$instance->$builder()"}elsif (ref($default)eq 'CODE'){$value="$attr_var\->{default}->(\$instance)"}elsif (defined($default)){$value="$attr_var\->{default}"}else {$value='undef'}if($need_coercion){$value="$constraint_var->coerce($value)"}$code .= "$instance_slot = $value;\n";$code .= $post_process}}elsif ($attr->is_required){$code .= "\$meta->throw_error('Attribute ($key) is required')";$code .= "    unless \$is_cloning;\n"}$code .= "}\n" if defined$init_arg;if($is_weak_ref){$code .= "Scalar::Util::weaken($instance_slot) " ."if ref $instance_slot and not Scalar::Util::isweak($instance_slot);\n"}push@res,$code}if($strict){push@res,q{if($used < keys %{$args})} .q{{ $meta->_report_unknown_args(\@attrs, $args) }}}if($metaclass->is_anon_class){push@res,q{$instance->{__METACLASS__} = $meta;}}if($has_triggers){unshift@res,q{my @triggers;};push@res,q{$_->[0]->($instance, $_->[1]) for @triggers;}}my$source=sprintf <<'EOT',__FILE__,$metaclass->name,join "\n",@res;warn$source if _MOUSE_DEBUG;my$body;my$e=do {local $@;$body=eval$source;$@};die$e if$e;return$body}sub _generate_BUILDARGS {my(undef,$metaclass)=@_;my$class=$metaclass->name;if ($class->can('BUILDARGS')&& $class->can('BUILDARGS')!=\&Mouse::Object::BUILDARGS){return 'my $args = $class->BUILDARGS(@_)'}return <<'...'}sub _generate_BUILDALL {my (undef,$metaclass)=@_;return '' unless$metaclass->name->can('BUILD');my@code;for my$class ($metaclass->linearized_isa){if (Mouse::Util::get_code_ref($class,'BUILD')){unshift@code,qq{${class}::BUILD(\$instance, \$args);}}}return join "\n",@code}1;
  #line 1 "%s"
          package %s;
          sub {
              my $class = shift;
              return $class->Mouse::Object::new(@_)
                  if $class ne __PACKAGE__;
              # BUILDARGS
              %s;
              my $instance = bless {}, $class;
              $metaclass->$initializer($instance, $args, 0);
              # BUILDALL
              %s;
              return $instance;
          }
  EOT
  #line 1 "%s"
      package %s;
      sub {
          my($meta, $instance, $args, $is_cloning) = @_;
          %s;
          return $instance;
      }
  EOT
          my $args;
          if ( scalar @_ == 1 ) {
              ( ref( $_[0] ) eq 'HASH' )
                  || Carp::confess "Single parameters to new() must be a HASH ref";
              $args = +{ %{ $_[0] } };
          }
          else {
              $args = +{@_};
          }
  ...
MOUSE_META_METHOD_CONSTRUCTOR

$fatpacked{"Mouse/Meta/Method/Delegation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_METHOD_DELEGATION';
  package Mouse::Meta::Method::Delegation;use Mouse::Util qw(:meta);use Scalar::Util;sub _generate_delegation{my (undef,$attr,$handle_name,$method_to_call)=@_;my@curried_args;if(ref($method_to_call)eq 'ARRAY'){($method_to_call,@curried_args)=@{$method_to_call}}my$reader=$attr->get_read_method()|| $attr->get_read_method_ref();my$can_be_optimized=$attr->{_mouse_cache_method_delegation_can_be_optimized};if(!defined$can_be_optimized){my$tc=$attr->type_constraint;$attr->{_mouse_cache_method_delegation_can_be_optimized}=(defined($tc)&& $tc->is_a_type_of('Object'))&& ($attr->is_required || $attr->has_default || $attr->has_builder)&& ($attr->is_lazy ||!$attr->has_clearer)}if($can_be_optimized){return sub {return shift()->$reader()->$method_to_call(@curried_args,@_)}}else {return sub {my$instance=shift;my$proxy=$instance->$reader();my$error=!defined($proxy)? ' is not defined' : ref($proxy)&&!Scalar::Util::blessed($proxy)? qq{ is not an object (got '$proxy')} : undef;if ($error){$instance->meta->throw_error("Cannot delegate $handle_name to $method_to_call because " ."the value of " .$attr->name .$error)}$proxy->$method_to_call(@curried_args,@_)}}}1;
MOUSE_META_METHOD_DELEGATION

$fatpacked{"Mouse/Meta/Method/Destructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_METHOD_DESTRUCTOR';
  package Mouse::Meta::Method::Destructor;use Mouse::Util qw(:meta);use constant _MOUSE_DEBUG=>$ENV{MOUSE_DEBUG}? 1 : 0;sub _generate_destructor{my (undef,$metaclass)=@_;my$demolishall='';for my$class ($metaclass->linearized_isa){if (Mouse::Util::get_code_ref($class,'DEMOLISH')){$demolishall .= '                ' .$class .'::DEMOLISH($self, Mouse::Util::in_global_destruction());' ."\n",}}if($demolishall){$demolishall=sprintf <<'EOT',$demolishall}my$name=$metaclass->name;my$source=sprintf(<<'EOT',__FILE__,$name,$demolishall);warn$source if _MOUSE_DEBUG;my$code;my$e=do{local $@;$code=eval$source;$@};die$e if$e;return$code}1;
          my $e = do{
              local $?;
              local $@;
              eval{
                  %s;
              };
              $@;
          };
          no warnings 'misc';
          die $e if $e; # rethrow
  EOT
  #line 1 "%s"
      package %s;
      sub {
          my($self) = @_;
          return $self->Mouse::Object::DESTROY()
              if ref($self) ne __PACKAGE__;
          # DEMOLISHALL
          %s;
          return;
      }
  EOT
MOUSE_META_METHOD_DESTRUCTOR

$fatpacked{"Mouse/Meta/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_MODULE';
  package Mouse::Meta::Module;use Mouse::Util qw/:meta/;use Carp ();use Scalar::Util ();my%METAS;if(Mouse::Util::MOUSE_XS){Mouse::Util::__register_metaclass_storage(\%METAS,0);*CLONE=sub {Mouse::Util::__register_metaclass_storage(\%METAS,1)}}sub initialize {my($class,$package_name,@args)=@_;($package_name &&!ref($package_name))|| $class->throw_error("You must pass a package name and it cannot be blessed");return$METAS{$package_name}||= $class->_construct_meta(package=>$package_name,@args)}sub reinitialize {my($class,$package_name,@args)=@_;$package_name=$package_name->name if ref$package_name;($package_name &&!ref($package_name))|| $class->throw_error("You must pass a package name and it cannot be blessed");if(exists$METAS{$package_name}){unshift@args,%{$METAS{$package_name}}}delete$METAS{$package_name};return$class->initialize($package_name,@args)}sub _class_of{my($class_or_instance)=@_;return undef unless defined$class_or_instance;return$METAS{ref($class_or_instance)|| $class_or_instance }}sub _get_all_metaclass_instances {values%METAS}sub _get_all_metaclass_names {keys%METAS}sub _get_metaclass_by_name {$METAS{$_[0]}}sub name;sub namespace;sub get_attribute_map {Carp::cluck('get_attribute_map() has been deprecated. Use get_attribute_list() and get_attribute() instead');return $_[0]->{attributes}}sub has_attribute {exists $_[0]->{attributes}->{$_[1]}}sub get_attribute {$_[0]->{attributes}->{$_[1]}}sub remove_attribute {delete $_[0]->{attributes}->{$_[1]}}sub get_attribute_list{keys %{$_[0]->{attributes}}}my%foreign=map{$_=>undef}qw(Mouse Mouse::Role Mouse::Util Mouse::Util::TypeConstraints Carp Scalar::Util List::Util);sub _get_method_body {my($self,$method_name)=@_;my$code=Mouse::Util::get_code_ref($self->{package},$method_name);return$code &&!exists$foreign{Mouse::Util::get_code_package($code)}? $code : undef}sub add_method;sub has_method {my($self,$method_name)=@_;defined($method_name)or $self->throw_error('You must define a method name');return defined($self->{methods}{$method_name})|| defined($self->_get_method_body($method_name))}sub get_method_body {my($self,$method_name)=@_;defined($method_name)or $self->throw_error('You must define a method name');return$self->{methods}{$method_name}||= $self->_get_method_body($method_name)}sub get_method {my($self,$method_name)=@_;if(my$code=$self->get_method_body($method_name)){return Mouse::Util::load_class($self->method_metaclass)->wrap(body=>$code,name=>$method_name,package=>$self->name,associated_metaclass=>$self,)}return undef}sub get_method_list {my($self)=@_;return grep {$self->has_method($_)}keys %{$self->namespace}}sub _collect_methods {my($meta,@args)=@_;my@methods;for my$arg(@args){if(my$type=ref$arg){if($type eq 'Regexp'){push@methods,grep {$_ =~ $arg}$meta->get_all_method_names}elsif($type eq 'ARRAY'){push@methods,@{$arg}}else{my$subname=(caller(1))[3];$meta->throw_error(sprintf('Methods passed to %s must be provided as a list,' .' ArrayRef or regular expression, not %s',$subname,$type,))}}else{push@methods,$arg}}return@methods}my$ANON_SERIAL=0;my%IMMORTALS;sub create {my($self,$package_name,%options)=@_;my$class=ref($self)|| $self;$self->throw_error('You must pass a package name')if @_ < 2;my$superclasses;if(exists$options{superclasses}){if(Mouse::Util::is_a_metarole($self)){delete$options{superclasses}}else{$superclasses=delete$options{superclasses};(ref$superclasses eq 'ARRAY')|| $self->throw_error("You must pass an ARRAY ref of superclasses")}}my$attributes=delete$options{attributes};if(defined$attributes){(ref$attributes eq 'ARRAY' || ref$attributes eq 'HASH')|| $self->throw_error("You must pass an ARRAY ref of attributes")}my$methods=delete$options{methods};if(defined$methods){(ref$methods eq 'HASH')|| $self->throw_error("You must pass a HASH ref of methods")}my$roles=delete$options{roles};if(defined$roles){(ref$roles eq 'ARRAY')|| $self->throw_error("You must pass an ARRAY ref of roles")}my$mortal;my$cache_key;if(!defined$package_name){$mortal=!$options{cache};if(!$mortal){$cache_key=join '='=>(join('|',@{$superclasses || []}),join('|',sort @{$roles || []}),);return$IMMORTALS{$cache_key}if exists$IMMORTALS{$cache_key}}$options{anon_serial_id}=++$ANON_SERIAL;$package_name=$class .'::__ANON__::' .$ANON_SERIAL}{no strict 'refs';${$package_name .'::VERSION'}=delete$options{version}if exists$options{version};${$package_name .'::AUTHORITY'}=delete$options{authority}if exists$options{authority}}my$meta=$self->initialize($package_name,%options);Scalar::Util::weaken($METAS{$package_name})if$mortal;$meta->add_method(meta=>sub {$self->initialize(ref($_[0])|| $_[0])});$meta->superclasses(@{$superclasses})if defined$superclasses;if (defined$attributes){if(ref($attributes)eq 'ARRAY'){for my$attr (@{$attributes}){$meta->add_attribute($attr)}}else{while(my($name,$attr)=each %{$attributes}){$meta->add_attribute($name=>$attr)}}}if (defined$methods){while(my($method_name,$method_body)=each %{$methods}){$meta->add_method($method_name,$method_body)}}if (defined$roles and!$options{in_application_to_instance}){Mouse::Util::apply_all_roles($package_name,@{$roles})}if($cache_key){$IMMORTALS{$cache_key}=$meta}return$meta}sub DESTROY{my($self)=@_;return if Mouse::Util::in_global_destruction();my$serial_id=$self->{anon_serial_id};return if!$serial_id;if(exists$INC{'threads.pm'}){return if((caller)[2]==0)}@{$self->{superclasses}}=()if exists$self->{superclasses};%{$self->namespace}=();my$name=$self->name;delete$METAS{$name};$name =~ s/ $serial_id \z//xms;no strict 'refs';delete ${$name}{$serial_id .'::' };return}1;
MOUSE_META_MODULE

$fatpacked{"Mouse/Meta/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_ROLE';
  package Mouse::Meta::Role;use Mouse::Util qw(:meta);use Mouse::Meta::Module;our@ISA=qw(Mouse::Meta::Module);sub method_metaclass;sub _construct_meta {my$class=shift;my%args=@_;$args{methods}={};$args{attributes}={};$args{required_methods}=[];$args{roles}=[];my$self=bless \%args,ref($class)|| $class;if($class ne __PACKAGE__){$self->meta->_initialize_object($self,\%args)}return$self}sub create_anon_role{my$self=shift;return$self->create(undef,@_)}sub is_anon_role;sub get_roles;sub calculate_all_roles {my$self=shift;my%seen;return grep {!$seen{$_->name }++}($self,map {$_->calculate_all_roles}@{$self->get_roles})}sub get_required_method_list{return @{$_[0]->{required_methods}}}sub add_required_methods {my($self,@methods)=@_;my%required=map{$_=>1}@{$self->{required_methods}};push @{$self->{required_methods}},grep{!$required{$_}++ &&!$self->has_method($_)}@methods;return}sub requires_method {my($self,$name)=@_;return scalar(grep{$_ eq $name}@{$self->{required_methods}})!=0}sub add_attribute {my$self=shift;my$name=shift;$self->{attributes}->{$name}=(@_==1)? $_[0]: {@_ };return}sub apply {my$self=shift;my$consumer=shift;require 'Mouse/Meta/Role/Application.pm';return Mouse::Meta::Role::Application->new(@_)->apply($self,$consumer)}sub combine {my($self,@role_specs)=@_;require 'Mouse/Meta/Role/Composite.pm';return Mouse::Meta::Role::Composite->new(roles=>\@role_specs)}sub add_before_method_modifier;sub add_around_method_modifier;sub add_after_method_modifier;sub get_before_method_modifiers;sub get_around_method_modifiers;sub get_after_method_modifiers;sub add_override_method_modifier{my($self,$method_name,$method)=@_;if($self->has_method($method_name)){$self->throw_error("Cannot add an override of method '$method_name' " ."because there is a local version of '$method_name'" ."(A local method of the same name as been found)")}$self->{override_method_modifiers}->{$method_name}=$method}sub get_override_method_modifier {my ($self,$method_name)=@_;return$self->{override_method_modifiers}->{$method_name}}sub does_role {my ($self,$role_name)=@_;(defined$role_name)|| $self->throw_error("You must supply a role name to look for");$role_name=$role_name->name if ref$role_name;return 1 if$role_name eq $self->name;for my$role (@{$self->get_roles}){return 1 if$role->does_role($role_name)}return 0}1;
MOUSE_META_ROLE

$fatpacked{"Mouse/Meta/Role/Application.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_ROLE_APPLICATION';
  package Mouse::Meta::Role::Application;use Mouse::Util qw(:meta);sub new {my$class=shift;my$args=$class->Mouse::Object::BUILDARGS(@_);if(exists$args->{exclude}or exists$args->{alias}){warnings::warnif(deprecated=>'The alias and excludes options for role application have been' .' renamed -alias and -exclude');if($args->{alias}&&!exists$args->{-alias}){$args->{-alias}=$args->{alias}}if($args->{excludes}&&!exists$args->{-excludes}){$args->{-excludes}=$args->{excludes}}}$args->{aliased_methods}={};if(my$alias=$args->{-alias}){@{$args->{aliased_methods}}{values %{$alias}}=()}if(my$excludes=$args->{-excludes}){$args->{-excludes}={};if(ref$excludes){%{$args->{-excludes}}=(map{$_=>undef}@{$excludes})}else{$args->{-excludes}{$excludes}=undef}}my$self=bless$args,$class;if($class ne __PACKAGE__){$self->meta->_initialize_object($self,$args)}return$self}sub apply {my($self,$role,$consumer,@extra)=@_;my$instance;if(Mouse::Util::is_a_metaclass($consumer)){$self->{_to}='class'}elsif(Mouse::Util::is_a_metarole($consumer)){$self->{_to}='role'}else {$self->{_to}='instance';$instance=$consumer;my$meta=Mouse::Util::class_of($instance);$consumer=($meta || 'Mouse::Meta::Class')->create_anon_class(superclasses=>[ref$instance],roles=>[$role],cache=>0,in_application_to_instance=>1,)}$self->check_required_methods($role,$consumer,@extra);$self->apply_attributes($role,$consumer,@extra);$self->apply_methods($role,$consumer,@extra);$self->apply_modifiers($role,$consumer,@extra);$self->_append_roles($role,$consumer);if(defined$instance){bless$instance,$consumer->name;$consumer->_initialize_object($instance,$instance,1)}return}sub check_required_methods {my($self,$role,$consumer)=@_;if($self->{_to}eq 'role'){$consumer->add_required_methods($role->get_required_method_list)}else{my$consumer_class_name=$consumer->name;my@missing;for my$method_name(@{$role->{required_methods}}){next if exists$self->{aliased_methods}{$method_name};next if exists$role->{methods}{$method_name};next if$consumer_class_name->can($method_name);push@missing,$method_name}if(@missing){$role->throw_error(sprintf "'%s' requires the method%s %s to be implemented by '%s'",$role->name,(@missing==1 ? '' : 's'),Mouse::Util::quoted_english_list(@missing),$consumer_class_name)}}return}sub apply_methods {my($self,$role,$consumer)=@_;my$alias=$self->{-alias};my$excludes=$self->{-excludes};for my$method_name($role->get_method_list){next if$method_name eq 'meta';my$code=$role->get_method_body($method_name);if(!exists$excludes->{$method_name}){if(!$consumer->has_method($method_name)){$consumer->add_method($method_name=>$code,$role)}}if(exists$alias->{$method_name}){my$dstname=$alias->{$method_name};my$dstcode=$consumer->get_method_body($dstname);if(defined($dstcode)&& $dstcode!=$code){$role->throw_error("Cannot create a method alias if a local method of the same name exists")}else{$consumer->add_method($dstname=>$code,$role)}}}return}sub apply_attributes {my($self,$role,$consumer)=@_;for my$attr_name ($role->get_attribute_list){next if$consumer->has_attribute($attr_name);$consumer->add_attribute($attr_name =>$role->get_attribute($attr_name))}return}sub apply_modifiers {my($self,$role,$consumer)=@_;if(my$modifiers=$role->{override_method_modifiers}){for my$method_name (keys %{$modifiers}){$consumer->add_override_method_modifier($method_name=>$modifiers->{$method_name})}}for my$modifier_type (qw/before around after/){my$table=$role->{"${modifier_type}_method_modifiers"}or next;my$add_modifier="add_${modifier_type}_method_modifier";while(my($method_name,$modifiers)=each %{$table}){for my$code(@{$modifiers}){next if$consumer->{"_applied_$modifier_type"}{$method_name,$code}++;$consumer->$add_modifier($method_name=>$code)}}}return}sub _append_roles {my($self,$role,$metaclass_or_role)=@_;my$roles=$metaclass_or_role->{roles};for my$r($role,@{$role->get_roles}){if(!$metaclass_or_role->does_role($r)){push @{$roles},$r}}return}1;
MOUSE_META_ROLE_APPLICATION

$fatpacked{"Mouse/Meta/Role/Composite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_ROLE_COMPOSITE';
  package Mouse::Meta::Role::Composite;use Carp ();use Mouse::Util;use Mouse::Meta::Role;use Mouse::Meta::Role::Application;our@ISA=qw(Mouse::Meta::Role);sub new {my$class=shift;my$args=$class->Mouse::Object::BUILDARGS(@_);my$roles=delete$args->{roles};my$self=$class->create_anon_role(%{$args});for my$role_spec(@{$roles}){my($role,$args)=ref($role_spec)eq 'ARRAY' ? @{$role_spec}: ($role_spec,{});$role->apply($self,%{$args})}return$self}sub get_method_list {my($self)=@_;return grep {!$self->{conflicting_methods}{$_}}keys %{$self->{methods}}}sub add_method {my($self,$method_name,$code,$role)=@_;if(($self->{methods}{$method_name}|| 0)==$code){return}if($method_name eq 'meta'){$self->SUPER::add_method($method_name=>$code)}else{my$roles=$self->{composed_roles_by_method}{$method_name}||= [];push @{$roles},$role;if(@{$roles}> 1){$self->{conflicting_methods}{$method_name}++}$self->{methods}{$method_name}=$code}return}sub get_method_body {my($self,$method_name)=@_;return$self->{methods}{$method_name}}sub has_method {return 0}sub has_attribute {return 0}sub has_override_method_modifier {return 0}sub add_attribute {my$self=shift;my$attr_name=shift;my$spec=(@_==1 ? $_[0]: {@_});my$existing=$self->{attributes}{$attr_name};if($existing && $existing!=$spec){$self->throw_error("We have encountered an attribute conflict with '$attr_name' " ."during composition. This is fatal error and cannot be disambiguated.")}$self->SUPER::add_attribute($attr_name,$spec);return}sub add_override_method_modifier {my($self,$method_name,$code)=@_;my$existing=$self->{override_method_modifiers}{$method_name};if($existing && $existing!=$code){$self->throw_error("We have encountered an 'override' method conflict with '$method_name' during " ."composition (Two 'override' methods of the same name encountered). " ."This is fatal error.")}$self->SUPER::add_override_method_modifier($method_name,$code);return}sub apply {my$self=shift;my$consumer=shift;Mouse::Meta::Role::Application::RoleSummation->new(@_)->apply($self,$consumer);return}package Mouse::Meta::Role::Application::RoleSummation;our@ISA=qw(Mouse::Meta::Role::Application);sub apply_methods {my($self,$role,$consumer,@extra)=@_;if(exists$role->{conflicting_methods}){my$consumer_class_name=$consumer->name;my@conflicting=grep{!$consumer_class_name->can($_)}keys %{$role->{conflicting_methods}};if(@conflicting){my$method_name_conflict=(@conflicting==1 ? 'a method name conflict' : 'method name conflicts');my%seen;my$roles=Mouse::Util::quoted_english_list(grep{!$seen{$_}++}map {$_->name}map {@{$_}}@{$role->{composed_roles_by_method}}{@conflicting});$self->throw_error(sprintf q{Due to %s in roles %s,} .q{ the method%s %s must be implemented or excluded by '%s'},$method_name_conflict,$roles,(@conflicting > 1 ? 's' : ''),Mouse::Util::quoted_english_list(@conflicting),$consumer_class_name)}my@changed_in_v2_0_0=grep {$consumer_class_name->can($_)&&!$consumer->has_method($_)}keys %{$role->{conflicting_methods}};if (@changed_in_v2_0_0){my$method_name_conflict=(@changed_in_v2_0_0==1 ? 'a method name conflict' : 'method name conflicts');my%seen;my$roles=Mouse::Util::quoted_english_list(grep{!$seen{$_}++}map {$_->name}map {@{$_}}@{$role->{composed_roles_by_method}}{@changed_in_v2_0_0});Carp::cluck(sprintf q{Due to %s in roles %s,} .q{ the behavior of method%s %s might be changed} .q{ in Mouse-2.00, check it out},$method_name_conflict,$roles,(@changed_in_v2_0_0 > 1 ? 's' : ''),Mouse::Util::quoted_english_list(@changed_in_v2_0_0),$consumer_class_name)}}$self->SUPER::apply_methods($role,$consumer,@extra);return}package Mouse::Meta::Role::Composite;1;
MOUSE_META_ROLE_COMPOSITE

$fatpacked{"Mouse/Meta/Role/Method.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_ROLE_METHOD';
  package Mouse::Meta::Role::Method;use Mouse::Util;use Mouse::Meta::Method;our@ISA=qw(Mouse::Meta::Method);sub _new{my($class,%args)=@_;my$self=bless \%args,$class;if($class ne __PACKAGE__){$self->meta->_initialize_object($self,\%args)}return$self}1;
MOUSE_META_ROLE_METHOD

$fatpacked{"Mouse/Meta/TypeConstraint.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_META_TYPECONSTRAINT';
  package Mouse::Meta::TypeConstraint;use Mouse::Util qw(:meta);sub new {my$class=shift;my%args=@_==1 ? %{$_[0]}: @_;$args{name}='__ANON__' if!defined$args{name};my$type_parameter;if(defined$args{parent}){%args=(%{$args{parent}},%args);delete$args{compiled_type_constraint};delete$args{hand_optimized_type_constraint};$type_parameter=$args{type_parameter};if(defined(my$parent_tp=$args{parent}{type_parameter})){if($parent_tp!=$type_parameter){$type_parameter->is_a_type_of($parent_tp)or $class->throw_error("$type_parameter is not a subtype of $parent_tp",)}else {$type_parameter=undef}}}my$check;if($check=delete$args{optimized}){$args{hand_optimized_type_constraint}=$check;$args{compiled_type_constraint}=$check}elsif(defined$type_parameter){my$generator=$args{constraint_generator}|| $class->throw_error("The $args{name} constraint cannot be used," ." because $type_parameter doesn't subtype" ." from a parameterizable type");my$parameterized_check=$generator->($type_parameter);if(defined(my$my_check=$args{constraint})){$check=sub {return$parameterized_check->($_)&& $my_check->($_)}}else {$check=$parameterized_check}$args{constraint}=$check}else {$check=$args{constraint}}if(defined($check)&& ref($check)ne 'CODE'){$class->throw_error("Constraint for $args{name} is not a CODE reference")}my$self=bless \%args,$class;$self->compile_type_constraint()if!$args{hand_optimized_type_constraint};if($args{type_constraints}){for my$type(@{$self->{type_constraints}}){if($type->has_coercion){$self->{_compiled_type_coercion}=undef;last}}}return$self}sub create_child_type {my$self=shift;return ref($self)->new(@_,parent=>$self)}sub name;sub parent;sub message;sub has_coercion;sub check;sub type_parameter;sub __is_parameterized;sub _compiled_type_constraint;sub _compiled_type_coercion;sub compile_type_constraint;sub _add_type_coercions {my$self=shift;if(exists$self->{type_constraints}){$self->throw_error("Cannot add additional type coercions to Union types '$self'")}my$coercion_map=($self->{coercion_map}||= []);my%has=map{$_->[0]->name=>undef}@{$coercion_map};for(my$i=0;$i < @_;$i++){my$from=$_[$i];my$action=$_[++$i];if(exists$has{$from}){$self->throw_error("A coercion action already exists for '$from'")}my$type=Mouse::Util::TypeConstraints::find_or_parse_type_constraint($from)or $self->throw_error("Could not find the type constraint ($from) to coerce from");push @{$coercion_map},[$type=>$action ]}$self->{_compiled_type_coercion}=undef;return}sub _compiled_type_coercion {my($self)=@_;my$coercion=$self->{_compiled_type_coercion};return$coercion if defined$coercion;if(!$self->{type_constraints}){my@coercions;for my$pair(@{$self->{coercion_map}}){push@coercions,[$pair->[0]->_compiled_type_constraint,$pair->[1]]}$coercion=sub {my($thing)=@_;for my$pair (@coercions){if ($pair->[0]->($thing)){return$pair->[1]->($thing)for$thing}}return$thing}}else {my@coercions;for my$type(@{$self->{type_constraints}}){if($type->has_coercion){push@coercions,$type}}if(@coercions){$coercion=sub {my($thing)=@_;for my$type(@coercions){my$value=$type->coerce($thing);return$value if$self->check($value)}return$thing}}}return($self->{_compiled_type_coercion}=$coercion)}sub coerce {my$self=shift;return $_[0]if$self->check(@_);my$coercion=$self->_compiled_type_coercion or $self->throw_error("Cannot coerce without a type coercion");return$coercion->(@_)}sub get_message {my ($self,$value)=@_;if (my$msg=$self->message){return$msg->($value)for$value}else {if(not defined$value){$value='undef'}elsif(ref($value)&& defined(&overload::StrVal)){$value=overload::StrVal($value)}return "Validation failed for '$self' with value $value"}}sub is_a_type_of {my($self,$other)=@_;return 0 if!ref($other)&& $other eq '__ANON__';(my$other_name=$other)=~ s/\s+//g;return 1 if$self->name eq $other_name;if(exists$self->{type_constraints}){for my$type(@{$self->{type_constraints}}){return 1 if$type->name eq $other_name}}for(my$p=$self->parent;defined$p;$p=$p->parent){return 1 if$p->name eq $other_name}return 0}sub parameterize {my($self,$param,$name)=@_;if(!ref$param){require Mouse::Util::TypeConstraints;$param=Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($param)}$name ||= sprintf '%s[%s]',$self->name,$param->name;return Mouse::Meta::TypeConstraint->new(name=>$name,parent=>$self,type_parameter=>$param,)}sub assert_valid {my ($self,$value)=@_;if(!$self->check($value)){$self->throw_error($self->get_message($value))}return 1}sub _as_string {$_[0]->name}sub _identity;sub _unite {my($lhs,$rhs)=@_;require Mouse::Util::TypeConstraints;return Mouse::Util::TypeConstraints::_find_or_create_union_type($lhs,Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($rhs),)}1;
MOUSE_META_TYPECONSTRAINT

$fatpacked{"Mouse/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_OBJECT';
  package Mouse::Object;use Mouse::Util qw(does dump meta);sub DOES {my($self,$class_or_role_name)=@_;return$self->isa($class_or_role_name)|| $self->does($class_or_role_name)}1;
MOUSE_OBJECT

$fatpacked{"Mouse/PurePerl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_PUREPERL';
  package Mouse::PurePerl;package Mouse::Util;use strict;use warnings;use warnings FATAL=>'redefine';use Scalar::Util ();use B ();require Mouse::Util;sub is_valid_class_name {my$class=shift;return 0 if ref($class);return 0 unless defined($class);return 1 if$class =~ /\A \w+ (?: :: \w+ )* \z/xms;return 0}sub is_class_loaded {my$class=shift;return 0 if ref($class)||!defined($class)||!length($class);my$pack=\%::;for my$part (split('::',$class)){$part .= '::';return 0 if!exists$pack->{$part};my$entry=\$pack->{$part};return 0 if ref($entry)ne 'GLOB';$pack=*{$entry}{HASH}}return 0 if!%{$pack};return 1 if exists$pack->{VERSION}&& defined *{$pack->{VERSION}}{SCALAR}&& defined ${$pack->{VERSION}};return 1 if exists$pack->{ISA}&& defined *{$pack->{ISA}}{ARRAY}&& @{$pack->{ISA}}!=0;for my$name(keys %{$pack}){my$entry=\$pack->{$name};return 1 if ref($entry)ne 'GLOB' || defined *{$entry}{CODE}}return 0}sub get_code_info {my ($coderef)=@_;ref($coderef)or return;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return;my$gv=$cv->GV;$gv->isa('B::GV')or return;return ($gv->STASH->NAME,$gv->NAME)}sub get_code_package{my($coderef)=@_;my$cv=B::svref_2object($coderef);$cv->isa('B::CV')or return '';my$gv=$cv->GV;$gv->isa('B::GV')or return '';return$gv->STASH->NAME}sub get_code_ref{my($package,$name)=@_;no strict 'refs';no warnings 'once';use warnings FATAL=>'uninitialized';return *{$package .'::' .$name}{CODE}}sub generate_isa_predicate_for {my($for_class,$name)=@_;my$predicate=sub{Scalar::Util::blessed($_[0])&& $_[0]->isa($for_class)};if(defined$name){Mouse::Util::install_subroutines(scalar caller,$name=>$predicate);return}return$predicate}sub generate_can_predicate_for {my($methods_ref,$name)=@_;my@methods=@{$methods_ref};my$predicate=sub{my($instance)=@_;if(Scalar::Util::blessed($instance)){for my$method(@methods){if(!$instance->can($method)){return 0}}return 1}return 0};if(defined$name){Mouse::Util::install_subroutines(scalar caller,$name=>$predicate);return}return$predicate}package Mouse::Util::TypeConstraints;sub Any {1}sub Item {1}sub Bool {!$_[0]|| $_[0]eq '1'}sub Undef {!defined($_[0])}sub Defined {defined($_[0])}sub Value {defined($_[0])&&!ref($_[0])}sub Num {Scalar::Util::looks_like_number($_[0])}sub Str {my($value)=@_;return defined($value)&& ref(\$value)eq 'SCALAR'}sub Int {my($value)=@_;return defined($value)&& $value =~ /\A -? [0-9]+  \z/xms}sub Ref {ref($_[0])}sub ScalarRef {my($value)=@_;return ref($value)eq 'SCALAR' || ref($value)eq 'REF'}sub ArrayRef {ref($_[0])eq 'ARRAY'}sub HashRef {ref($_[0])eq 'HASH'}sub CodeRef {ref($_[0])eq 'CODE'}sub RegexpRef {ref($_[0])eq 'Regexp'}sub GlobRef {ref($_[0])eq 'GLOB'}sub FileHandle {my($value)=@_;return Scalar::Util::openhandle($value)|| (Scalar::Util::blessed($value)&& $value->isa("IO::Handle"))}sub Object {Scalar::Util::blessed($_[0])&& ref($_[0])ne 'Regexp'}sub ClassName {Mouse::Util::is_class_loaded($_[0])}sub RoleName {(Mouse::Util::class_of($_[0])|| return 0)->isa('Mouse::Meta::Role')}sub _parameterize_ArrayRef_for {my($type_parameter)=@_;my$check=$type_parameter->_compiled_type_constraint;return sub {for my$value (@{$_}){return undef unless$check->($value)}return 1}}sub _parameterize_HashRef_for {my($type_parameter)=@_;my$check=$type_parameter->_compiled_type_constraint;return sub {for my$value(values %{$_}){return undef unless$check->($value)}return 1}}sub _parameterize_Maybe_for {my($type_parameter)=@_;my$check=$type_parameter->_compiled_type_constraint;return sub{return!defined($_)|| $check->($_)}}package Mouse::Meta::Module;sub name {$_[0]->{package}}sub _method_map {$_[0]->{methods}}sub _attribute_map{$_[0]->{attributes}}sub namespace{my$name=$_[0]->{package};no strict 'refs';return \%{$name .'::'}}sub add_method {my($self,$name,$code)=@_;if(!defined$name){$self->throw_error('You must pass a defined name')}if(!defined$code){$self->throw_error('You must pass a defined code')}if(ref($code)ne 'CODE'){$code=\&{$code}}$self->{methods}->{$name}=$code;Mouse::Util::install_subroutines($self->name,$name=>$code,);return}my$generate_class_accessor=sub {my($name)=@_;return sub {my$self=shift;if(@_){return$self->{$name}=shift}for my$class($self->linearized_isa){my$meta=Mouse::Util::get_metaclass_by_name($class)or next;if(exists$meta->{$name}){return$meta->{$name}}}return undef}};package Mouse::Meta::Class;use Mouse::Meta::Method::Constructor;use Mouse::Meta::Method::Destructor;sub method_metaclass {$_[0]->{method_metaclass}|| 'Mouse::Meta::Method'}sub attribute_metaclass {$_[0]->{attribute_metaclass}|| 'Mouse::Meta::Attribute'}sub constructor_class {$_[0]->{constructor_class}|| 'Mouse::Meta::Method::Constructor'}sub destructor_class {$_[0]->{destructor_class}|| 'Mouse::Meta::Method::Destructor'}sub is_anon_class{return exists $_[0]->{anon_serial_id}}sub roles {$_[0]->{roles}}sub linearized_isa {@{Mouse::Util::get_linear_isa($_[0]->{package})}}sub new_object {my$meta=shift;my%args=(@_==1 ? %{$_[0]}: @_);my$object=bless {},$meta->name;$meta->_initialize_object($object,\%args,0);if($object->can('BUILD')){for my$class (reverse$meta->linearized_isa){my$build=Mouse::Util::get_code_ref($class,'BUILD')|| next;$object->$build(\%args)}}return$object}sub clone_object {my$class=shift;my$object=shift;my$args=$object->Mouse::Object::BUILDARGS(@_);(Scalar::Util::blessed($object)&& $object->isa($class->name))|| $class->throw_error("You must pass an instance of the metaclass (" .$class->name ."), not ($object)");my$cloned=bless {%$object },ref$object;$class->_initialize_object($cloned,$args,1);return$cloned}sub _initialize_object{my($self,$object,$args,$is_cloning)=@_;my$initializer=$self->{_mouse_cache}{_initialize_object}||= Mouse::Util::load_class($self->constructor_class)->_generate_initialize_object($self);goto &{$initializer}}sub get_all_attributes {my($self)=@_;return @{$self->{_mouse_cache}{all_attributes}||= $self->_calculate_all_attributes}}sub is_immutable {$_[0]->{is_immutable}}sub strict_constructor;*strict_constructor=$generate_class_accessor->('strict_constructor');sub _invalidate_metaclass_cache {my($self)=@_;delete$self->{_mouse_cache};return}sub _report_unknown_args {my($metaclass,$attrs,$args)=@_;my@unknowns;my%init_args;for my$attr(@{$attrs}){my$init_arg=$attr->init_arg;if(defined$init_arg){$init_args{$init_arg}++}}while(my$key=each %{$args}){if(!exists$init_args{$key}){push@unknowns,$key}}$metaclass->throw_error(sprintf "Unknown attribute passed to the constructor of %s: %s",$metaclass->name,Mouse::Util::english_list(@unknowns),)}package Mouse::Meta::Role;sub method_metaclass{$_[0]->{method_metaclass}|| 'Mouse::Meta::Role::Method'}sub is_anon_role{return exists $_[0]->{anon_serial_id}}sub get_roles {$_[0]->{roles}}sub add_before_method_modifier {my ($self,$method_name,$method)=@_;push @{$self->{before_method_modifiers}{$method_name}||= []},$method;return}sub add_around_method_modifier {my ($self,$method_name,$method)=@_;push @{$self->{around_method_modifiers}{$method_name}||= []},$method;return}sub add_after_method_modifier {my ($self,$method_name,$method)=@_;push @{$self->{after_method_modifiers}{$method_name}||= []},$method;return}sub get_before_method_modifiers {my ($self,$method_name)=@_;return @{$self->{before_method_modifiers}{$method_name}||= []}}sub get_around_method_modifiers {my ($self,$method_name)=@_;return @{$self->{around_method_modifiers}{$method_name}||= []}}sub get_after_method_modifiers {my ($self,$method_name)=@_;return @{$self->{after_method_modifiers}{$method_name}||= []}}sub add_metaclass_accessor {my($meta,$name)=@_;$meta->add_method($name=>$generate_class_accessor->($name));return}package Mouse::Meta::Attribute;require Mouse::Meta::Method::Accessor;sub accessor_metaclass{$_[0]->{accessor_metaclass}|| 'Mouse::Meta::Method::Accessor'}sub name {$_[0]->{name}}sub associated_class {$_[0]->{associated_class}}sub accessor {$_[0]->{accessor}}sub reader {$_[0]->{reader}}sub writer {$_[0]->{writer}}sub predicate {$_[0]->{predicate}}sub clearer {$_[0]->{clearer}}sub handles {$_[0]->{handles}}sub _is_metadata {$_[0]->{is}}sub is_required {$_[0]->{required}}sub default {my($self,$instance)=@_;my$value=$self->{default};$value=$value->($instance)if defined($instance)and ref($value)eq "CODE";return$value}sub is_lazy {$_[0]->{lazy}}sub is_lazy_build {$_[0]->{lazy_build}}sub is_weak_ref {$_[0]->{weak_ref}}sub init_arg {$_[0]->{init_arg}}sub type_constraint {$_[0]->{type_constraint}}sub trigger {$_[0]->{trigger}}sub builder {$_[0]->{builder}}sub should_auto_deref {$_[0]->{auto_deref}}sub should_coerce {$_[0]->{coerce}}sub documentation {$_[0]->{documentation}}sub insertion_order {$_[0]->{insertion_order}}sub has_accessor {exists $_[0]->{accessor}}sub has_reader {exists $_[0]->{reader}}sub has_writer {exists $_[0]->{writer}}sub has_predicate {exists $_[0]->{predicate}}sub has_clearer {exists $_[0]->{clearer}}sub has_handles {exists $_[0]->{handles}}sub has_default {exists $_[0]->{default}}sub has_type_constraint {exists $_[0]->{type_constraint}}sub has_trigger {exists $_[0]->{trigger}}sub has_builder {exists $_[0]->{builder}}sub has_documentation {exists $_[0]->{documentation}}sub _process_options{my($class,$name,$args)=@_;defined($name)or $class->throw_error('You must provide a name for the attribute');if(!exists$args->{init_arg}){$args->{init_arg}=$name}my$can_be_required=defined($args->{init_arg});if(exists$args->{builder}){$class->throw_error('builder must be a defined scalar value which is a method name')if!defined$args->{builder};$can_be_required++}elsif(exists$args->{default}){if(ref$args->{default}&& ref($args->{default})ne 'CODE'){$class->throw_error("References are not allowed as default values, you must " ."wrap the default of '$name' in a CODE reference (ex: sub { [] } and not [])")}$can_be_required++}if($args->{required}&&!$can_be_required){$class->throw_error("You cannot have a required attribute ($name) without a default, builder, or an init_arg")}if(exists$args->{is}){my$is=$args->{is};if($is eq 'ro'){$args->{reader}||= $name}elsif($is eq 'rw'){if(exists$args->{writer}){$args->{reader}||= $name}else{$args->{accessor}||= $name}}elsif($is eq 'bare'){}else{$is='undef' if!defined$is;$class->throw_error("I do not understand this option (is => $is) on attribute ($name)")}}my$tc;if(exists$args->{isa}){$tc=$args->{type_constraint}=Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($args->{isa})}if(exists$args->{does}){if(defined$tc){my$does_ok=do{local $@;eval{"$tc"->does($args->{does})}};if(!$does_ok){$class->throw_error("Cannot have both an isa option and a does option because '$tc' does not do '$args->{does}' on attribute ($name)")}}else {$tc=$args->{type_constraint}=Mouse::Util::TypeConstraints::find_or_create_does_type_constraint($args->{does})}}if($args->{coerce}){defined($tc)|| $class->throw_error("You cannot have coercion without specifying a type constraint on attribute ($name)");$args->{weak_ref}&& $class->throw_error("You cannot have a weak reference to a coerced value on attribute ($name)")}if ($args->{lazy_build}){exists($args->{default})&& $class->throw_error("You can not use lazy_build and default for the same attribute ($name)");$args->{lazy}=1;$args->{builder}||= "_build_${name}";if ($name =~ /^_/){$args->{clearer}||= "_clear${name}";$args->{predicate}||= "_has${name}"}else {$args->{clearer}||= "clear_${name}";$args->{predicate}||= "has_${name}"}}if ($args->{auto_deref}){defined($tc)|| $class->throw_error("You cannot auto-dereference without specifying a type constraint on attribute ($name)");($tc->is_a_type_of('ArrayRef')|| $tc->is_a_type_of('HashRef'))|| $class->throw_error("You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute ($name)")}if (exists$args->{trigger}){('CODE' eq ref$args->{trigger})|| $class->throw_error("Trigger must be a CODE ref on attribute ($name)")}if ($args->{lazy}){(exists$args->{default}|| defined$args->{builder})|| $class->throw_error("You cannot have a lazy attribute ($name) without specifying a default value for it")}return}package Mouse::Meta::TypeConstraint;use overload '""'=>'_as_string','0+'=>'_identity','|'=>'_unite',fallback=>1;sub name {$_[0]->{name}}sub parent {$_[0]->{parent}}sub message {$_[0]->{message}}sub _identity {Scalar::Util::refaddr($_[0])}sub type_parameter {$_[0]->{type_parameter}}sub _compiled_type_constraint{$_[0]->{compiled_type_constraint}}sub __is_parameterized {exists $_[0]->{type_parameter}}sub has_coercion {exists $_[0]->{_compiled_type_coercion}}sub compile_type_constraint{my($self)=@_;my@checks;for(my$parent=$self->{parent};defined$parent;$parent=$parent->{parent}){if($parent->{hand_optimized_type_constraint}){unshift@checks,$parent->{hand_optimized_type_constraint};last}elsif($parent->{constraint}){unshift@checks,$parent->{constraint}}}if($self->{constraint}){push@checks,$self->{constraint}}if($self->{type_constraints}){my@types=map{$_->{compiled_type_constraint}}@{$self->{type_constraints}};push@checks,sub{for my$c(@types){return 1 if$c->($_[0])}return 0}}if(@checks==0){$self->{compiled_type_constraint}=\&Mouse::Util::TypeConstraints::Any}else{$self->{compiled_type_constraint}=sub{my(@args)=@_;for ($args[0]){for my$c(@checks){return undef if!$c->(@args)}}return 1}}return}sub check {my$self=shift;return$self->_compiled_type_constraint->(@_)}package Mouse::Object;sub BUILDARGS {my$class=shift;if (scalar @_==1){(ref($_[0])eq 'HASH')|| $class->meta->throw_error("Single parameters to new() must be a HASH ref");return {%{$_[0]}}}else {return {@_}}}sub new {my$class=shift;my$args=$class->BUILDARGS(@_);return$class->meta->new_object($args)}sub DESTROY {my$self=shift;return unless$self->can('DEMOLISH');my$e=do{local $?;local $@;eval{for my$class (@{Mouse::Util::get_linear_isa(ref$self)}){my$demolish=Mouse::Util::get_code_ref($class,'DEMOLISH')|| next;$self->$demolish(Mouse::Util::in_global_destruction())}};$@};no warnings 'misc';die$e if$e}sub BUILDALL {my$self=shift;return unless$self->can('BUILD');for my$class (reverse$self->meta->linearized_isa){my$build=Mouse::Util::get_code_ref($class,'BUILD')|| next;$self->$build(@_)}return}sub DEMOLISHALL;*DEMOLISHALL=\&DESTROY;1;
MOUSE_PUREPERL

$fatpacked{"Mouse/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_ROLE';
  package Mouse::Role;use Mouse::Exporter;our$VERSION='2.4.1';use Carp ();use Scalar::Util ();use Mouse ();Mouse::Exporter->setup_import_methods(as_is=>[qw(extends with has before after around override super augment inner requires excludes),\&Scalar::Util::blessed,\&Carp::confess,],);sub extends {Carp::croak "Roles do not support 'extends'"}sub with {Mouse::Util::apply_all_roles(scalar(caller),@_);return}sub has {my$meta=Mouse::Meta::Role->initialize(scalar caller);my$name=shift;$meta->throw_error(q{Usage: has 'name' => ( key => value, ... )})if @_ % 2;for my$n(ref($name)? @{$name}: $name){$meta->add_attribute($n=>@_)}return}sub before {my$meta=Mouse::Meta::Role->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_before_method_modifier($name=>$code)}return}sub after {my$meta=Mouse::Meta::Role->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_after_method_modifier($name=>$code)}return}sub around {my$meta=Mouse::Meta::Role->initialize(scalar caller);my$code=pop;for my$name($meta->_collect_methods(@_)){$meta->add_around_method_modifier($name=>$code)}return}sub super {return if!defined$Mouse::SUPER_BODY;$Mouse::SUPER_BODY->(@Mouse::SUPER_ARGS)}sub override {Mouse::Meta::Role->initialize(scalar caller)->add_override_method_modifier(@_);return}sub inner {Carp::croak "Roles cannot support 'inner'"}sub augment {Carp::croak "Roles cannot support 'augment'"}sub requires {my$meta=Mouse::Meta::Role->initialize(scalar caller);$meta->throw_error("Must specify at least one method")unless @_;$meta->add_required_methods(@_);return}sub excludes {Mouse::Util::not_supported()}sub init_meta{shift;my%args=@_;my$class=$args{for_class}or Carp::confess("Cannot call init_meta without specifying a for_class");my$metaclass=$args{metaclass}|| 'Mouse::Meta::Role';my$meta=$metaclass->initialize($class);$meta->add_method(meta=>sub{$metaclass->initialize(ref($_[0])|| $_[0])});Mouse::Util::TypeConstraints::role_type($class)unless Mouse::Util::TypeConstraints::find_type_constraint($class);return$meta}1;
MOUSE_ROLE

$fatpacked{"Mouse/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_SPEC';
  package Mouse::Spec;use strict;use warnings;our$VERSION='2.4.1';our$MouseVersion=$VERSION;our$MooseVersion='1.13';sub MouseVersion{$MouseVersion}sub MooseVersion{$MooseVersion}1;
MOUSE_SPEC

$fatpacked{"Mouse/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_TINY';
  use strict;use warnings;unless ($INC{'Mouse.pm'}){$INC{'Mouse.pm'}=__FILE__;$INC{'Mouse/Exporter.pm'}=__FILE__;$INC{'Mouse/Object.pm'}=__FILE__;$INC{'Mouse/PurePerl.pm'}=__FILE__;$INC{'Mouse/Role.pm'}=__FILE__;$INC{'Mouse/Util.pm'}=__FILE__;$INC{'Mouse/Meta/Attribute.pm'}=__FILE__;$INC{'Mouse/Meta/Class.pm'}=__FILE__;$INC{'Mouse/Meta/Method.pm'}=__FILE__;$INC{'Mouse/Meta/Module.pm'}=__FILE__;$INC{'Mouse/Meta/Role.pm'}=__FILE__;$INC{'Mouse/Meta/TypeConstraint.pm'}=__FILE__;$INC{'Mouse/Meta/Method/Accessor.pm'}=__FILE__;$INC{'Mouse/Meta/Method/Constructor.pm'}=__FILE__;$INC{'Mouse/Meta/Method/Delegation.pm'}=__FILE__;$INC{'Mouse/Meta/Method/Destructor.pm'}=__FILE__;$INC{'Mouse/Meta/Role/Application.pm'}=__FILE__;$INC{'Mouse/Meta/Role/Composite.pm'}=__FILE__;$INC{'Mouse/Meta/Role/Method.pm'}=__FILE__;$INC{'Mouse/Util/MetaRole.pm'}=__FILE__;$INC{'Mouse/Util/TypeConstraints.pm'}=__FILE__;eval sprintf("#line %d %s\n",__LINE__,__FILE__).<<'END_OF_TINY';die $@ if $@}package Mouse::Tiny;our$VERSION='2.4.1';Mouse::Exporter->setup_import_methods(also=>'Mouse');1;
  
  # and now their contents
  
  BEGIN{ # lib/Mouse/PurePerl.pm
  package Mouse::PurePerl;
  # The pure Perl backend for Mouse
  package Mouse::Util;
  use strict;
  use warnings;
  use warnings FATAL => 'redefine'; # to avoid to load Mouse::PurePerl twice
  
  use Scalar::Util ();
  use B ();
  
  require Mouse::Util;
  
  # taken from Class/MOP.pm
  sub is_valid_class_name {
  	my $class = shift;
  
  	return 0 if ref($class);
  	return 0 unless defined($class);
  
  	return 1 if $class =~ /\A \w+ (?: :: \w+ )* \z/xms;
  
  	return 0;
  }
  
  sub is_class_loaded {
  	my $class = shift;
  
  	return 0 if ref($class) || !defined($class) || !length($class);
  
  	# walk the symbol table tree to avoid autovififying
  	# \*{${main::}{"Foo::"}{"Bar::"}} == \*main::Foo::Bar::
  
  	my $pack = \%::;
  	foreach my $part (split('::', $class)) {
  		$part .= '::';
  		return 0 if !exists $pack->{$part};
  
  		my $entry = \$pack->{$part};
  		return 0 if ref($entry) ne 'GLOB';
  		$pack = *{$entry}{HASH};
  	}
  
  	return 0 if !%{$pack};
  
  	# check for $VERSION or @ISA
  	return 1 if exists $pack->{VERSION}
  			 && defined *{$pack->{VERSION}}{SCALAR} && defined ${ $pack->{VERSION} };
  	return 1 if exists $pack->{ISA}
  			 && defined *{$pack->{ISA}}{ARRAY} && @{ $pack->{ISA} } != 0;
  
  	# check for any method
  	foreach my $name( keys %{$pack} ) {
  		my $entry = \$pack->{$name};
  		return 1 if ref($entry) ne 'GLOB' || defined *{$entry}{CODE};
  	}
  
  	# fail
  	return 0;
  }
  
  
  # taken from Sub::Identify
  sub get_code_info {
  	my ($coderef) = @_;
  	ref($coderef) or return;
  
  	my $cv = B::svref_2object($coderef);
  	$cv->isa('B::CV') or return;
  
  	my $gv = $cv->GV;
  	$gv->isa('B::GV') or return;
  
  	return ($gv->STASH->NAME, $gv->NAME);
  }
  
  sub get_code_package{
  	my($coderef) = @_;
  
  	my $cv = B::svref_2object($coderef);
  	$cv->isa('B::CV') or return '';
  
  	my $gv = $cv->GV;
  	$gv->isa('B::GV') or return '';
  
  	return $gv->STASH->NAME;
  }
  
  sub get_code_ref{
  	my($package, $name) = @_;
  	no strict 'refs';
  	no warnings 'once';
  	use warnings FATAL => 'uninitialized';
  	return *{$package . '::' . $name}{CODE};
  }
  
  sub generate_isa_predicate_for {
  	my($for_class, $name) = @_;
  
  	my $predicate = sub{ Scalar::Util::blessed($_[0]) && $_[0]->isa($for_class) };
  
  	if(defined $name){
  		Mouse::Util::install_subroutines(scalar caller, $name => $predicate);
  		return;
  	}
  
  	return $predicate;
  }
  
  sub generate_can_predicate_for {
  	my($methods_ref, $name) = @_;
  
  	my @methods = @{$methods_ref};
  
  	my $predicate = sub{
  		my($instance) = @_;
  		if(Scalar::Util::blessed($instance)){
  			foreach my $method(@methods){
  				if(!$instance->can($method)){
  					return 0;
  				}
  			}
  			return 1;
  		}
  		return 0;
  	};
  
  	if(defined $name){
  		Mouse::Util::install_subroutines(scalar caller, $name => $predicate);
  		return;
  	}
  
  	return $predicate;
  }
  
  package Mouse::Util::TypeConstraints;
  
  
  sub Any        { 1 }
  sub Item       { 1 }
  
  sub Bool       { !$_[0] || $_[0] eq '1' }
  sub Undef      { !defined($_[0]) }
  sub Defined    {  defined($_[0])  }
  sub Value      {  defined($_[0]) && !ref($_[0]) }
  sub Num        {  Scalar::Util::looks_like_number($_[0]) }
  sub Str        {
  	# We need to use a copy here to flatten MAGICs, for instance as in
  	# Str( substr($_, 0, 42) ).
  	my($value) = @_;
  	return defined($value) && ref(\$value) eq 'SCALAR';
  }
  sub Int        {
  	# We need to use a copy here to save the original internal SV flags.
  	my($value) = @_;
  	return defined($value) && $value =~ /\A -? [0-9]+  \z/xms;
  }
  
  sub Ref        { ref($_[0]) }
  sub ScalarRef  {
  	my($value) = @_;
  	return ref($value) eq 'SCALAR' || ref($value) eq 'REF';
  }
  sub ArrayRef   { ref($_[0]) eq 'ARRAY'  }
  sub HashRef    { ref($_[0]) eq 'HASH'   }
  sub CodeRef    { ref($_[0]) eq 'CODE'   }
  sub RegexpRef  { ref($_[0]) eq 'Regexp' }
  sub GlobRef    { ref($_[0]) eq 'GLOB'   }
  
  sub FileHandle {
  	my($value) = @_;
  	return Scalar::Util::openhandle($value)
  		|| (Scalar::Util::blessed($value) && $value->isa("IO::Handle"))
  }
  
  sub Object     { Scalar::Util::blessed($_[0]) && ref($_[0]) ne 'Regexp' }
  
  sub ClassName  { Mouse::Util::is_class_loaded($_[0]) }
  sub RoleName   { (Mouse::Util::class_of($_[0]) || return 0)->isa('Mouse::Meta::Role') }
  
  sub _parameterize_ArrayRef_for {
  	my($type_parameter) = @_;
  	my $check = $type_parameter->_compiled_type_constraint;
  
  	return sub {
  		foreach my $value (@{$_}) {
  			return undef unless $check->($value);
  		}
  		return 1;
  	}
  }
  
  sub _parameterize_HashRef_for {
  	my($type_parameter) = @_;
  	my $check = $type_parameter->_compiled_type_constraint;
  
  	return sub {
  		foreach my $value(values %{$_}){
  			return undef unless $check->($value);
  		}
  		return 1;
  	};
  }
  
  # 'Maybe' type accepts 'Any', so it requires parameters
  sub _parameterize_Maybe_for {
  	my($type_parameter) = @_;
  	my $check = $type_parameter->_compiled_type_constraint;
  
  	return sub{
  		return !defined($_) || $check->($_);
  	};
  }
  
  package Mouse::Meta::Module;
  
  sub name          { $_[0]->{package} }
  
  sub _method_map   { $_[0]->{methods} }
  sub _attribute_map{ $_[0]->{attributes} }
  
  sub namespace{
  	my $name = $_[0]->{package};
  	no strict 'refs';
  	return \%{ $name . '::' };
  }
  
  sub add_method {
  	my($self, $name, $code) = @_;
  
  	if(!defined $name){
  		$self->throw_error('You must pass a defined name');
  	}
  	if(!defined $code){
  		$self->throw_error('You must pass a defined code');
  	}
  
  	if(ref($code) ne 'CODE'){
  		$code = \&{$code}; # coerce
  	}
  
  	$self->{methods}->{$name} = $code; # Moose stores meta object here.
  
  	Mouse::Util::install_subroutines($self->name,
  		$name => $code,
  	);
  	return;
  }
  
  my $generate_class_accessor = sub {
  	my($name) = @_;
  	return sub {
  		my $self = shift;
  		if(@_) {
  			return $self->{$name} = shift;
  		}
  
  		foreach my $class($self->linearized_isa) {
  			my $meta = Mouse::Util::get_metaclass_by_name($class)
  				or next;
  
  			if(exists $meta->{$name}) {
  				return $meta->{$name};
  			}
  		}
  		return undef;
  	};
  };
  
  
  package Mouse::Meta::Class;
  
  use Mouse::Meta::Method::Constructor;
  use Mouse::Meta::Method::Destructor;
  
  sub method_metaclass    { $_[0]->{method_metaclass}    || 'Mouse::Meta::Method'    }
  sub attribute_metaclass { $_[0]->{attribute_metaclass} || 'Mouse::Meta::Attribute' }
  
  sub constructor_class { $_[0]->{constructor_class} || 'Mouse::Meta::Method::Constructor' }
  sub destructor_class  { $_[0]->{destructor_class}  || 'Mouse::Meta::Method::Destructor'  }
  
  sub is_anon_class{
  	return exists $_[0]->{anon_serial_id};
  }
  
  sub roles { $_[0]->{roles} }
  
  sub linearized_isa { @{ Mouse::Util::get_linear_isa($_[0]->{package}) } }
  
  sub new_object {
  	my $meta = shift;
  	my %args = (@_ == 1 ? %{$_[0]} : @_);
  
  	my $object = bless {}, $meta->name;
  
  	$meta->_initialize_object($object, \%args, 0);
  	# BUILDALL
  	if( $object->can('BUILD') ) {
  		for my $class (reverse $meta->linearized_isa) {
  			my $build = Mouse::Util::get_code_ref($class, 'BUILD')
  				|| next;
  
  			$object->$build(\%args);
  		}
  	}
  	return $object;
  }
  
  sub clone_object {
  	my $class  = shift;
  	my $object = shift;
  	my $args   = $object->Mouse::Object::BUILDARGS(@_);
  
  	(Scalar::Util::blessed($object) && $object->isa($class->name))
  		|| $class->throw_error("You must pass an instance of the metaclass (" . $class->name . "), not ($object)");
  
  	my $cloned = bless { %$object }, ref $object;
  	$class->_initialize_object($cloned, $args, 1);
  	return $cloned;
  }
  
  sub _initialize_object{
  	my($self, $object, $args, $is_cloning) = @_;
  	# The initializer, which is used everywhere, must be clear
  	# when an attribute is added. See Mouse::Meta::Class::add_attribute.
  	my $initializer = $self->{_mouse_cache}{_initialize_object} ||=
  		Mouse::Util::load_class($self->constructor_class)
  			->_generate_initialize_object($self);
  	goto &{$initializer};
  }
  
  sub get_all_attributes {
  	my($self) = @_;
  	return @{ $self->{_mouse_cache}{all_attributes}
  		||= $self->_calculate_all_attributes };
  }
  
  sub is_immutable {  $_[0]->{is_immutable} }
  
  sub strict_constructor;
  *strict_constructor = $generate_class_accessor->('strict_constructor');
  
  sub _invalidate_metaclass_cache {
  	my($self) = @_;
  	delete $self->{_mouse_cache};
  	return;
  }
  
  sub _report_unknown_args {
  	my($metaclass, $attrs, $args) = @_;
  
  	my @unknowns;
  	my %init_args;
  	foreach my $attr(@{$attrs}){
  		my $init_arg = $attr->init_arg;
  		if(defined $init_arg){
  			$init_args{$init_arg}++;
  		}
  	}
  
  	while(my $key = each %{$args}){
  		if(!exists $init_args{$key}){
  			push @unknowns, $key;
  		}
  	}
  
  	$metaclass->throw_error( sprintf
  		"Unknown attribute passed to the constructor of %s: %s",
  		$metaclass->name, Mouse::Util::english_list(@unknowns),
  	);
  }
  
  package Mouse::Meta::Role;
  
  sub method_metaclass{ $_[0]->{method_metaclass} || 'Mouse::Meta::Role::Method' }
  
  sub is_anon_role{
  	return exists $_[0]->{anon_serial_id};
  }
  
  sub get_roles { $_[0]->{roles} }
  
  sub add_before_method_modifier {
  	my ($self, $method_name, $method) = @_;
  
  	push @{ $self->{before_method_modifiers}{$method_name} ||= [] }, $method;
  	return;
  }
  sub add_around_method_modifier {
  	my ($self, $method_name, $method) = @_;
  
  	push @{ $self->{around_method_modifiers}{$method_name} ||= [] }, $method;
  	return;
  }
  sub add_after_method_modifier {
  	my ($self, $method_name, $method) = @_;
  
  	push @{ $self->{after_method_modifiers}{$method_name} ||= [] }, $method;
  	return;
  }
  
  sub get_before_method_modifiers {
  	my ($self, $method_name) = @_;
  	return @{ $self->{before_method_modifiers}{$method_name} ||= [] }
  }
  sub get_around_method_modifiers {
  	my ($self, $method_name) = @_;
  	return @{ $self->{around_method_modifiers}{$method_name} ||= [] }
  }
  sub get_after_method_modifiers {
  	my ($self, $method_name) = @_;
  	return @{ $self->{after_method_modifiers}{$method_name} ||= [] }
  }
  
  sub add_metaclass_accessor { # for meta roles (a.k.a. traits)
  	my($meta, $name) = @_;
  	$meta->add_method($name => $generate_class_accessor->($name));
  	return;
  }
  
  package Mouse::Meta::Attribute;
  
  require Mouse::Meta::Method::Accessor;
  
  sub accessor_metaclass{ $_[0]->{accessor_metaclass} || 'Mouse::Meta::Method::Accessor' }
  
  # readers
  
  sub name                 { $_[0]->{name}                   }
  sub associated_class     { $_[0]->{associated_class}       }
  
  sub accessor             { $_[0]->{accessor}               }
  sub reader               { $_[0]->{reader}                 }
  sub writer               { $_[0]->{writer}                 }
  sub predicate            { $_[0]->{predicate}              }
  sub clearer              { $_[0]->{clearer}                }
  sub handles              { $_[0]->{handles}                }
  
  sub _is_metadata         { $_[0]->{is}                     }
  sub is_required          { $_[0]->{required}               }
  sub default {
  	my($self, $instance) = @_;
  	my $value = $self->{default};
  	$value = $value->($instance) if defined($instance) and ref($value) eq "CODE";
  	return $value;
  }
  sub is_lazy              { $_[0]->{lazy}                   }
  sub is_lazy_build        { $_[0]->{lazy_build}             }
  sub is_weak_ref          { $_[0]->{weak_ref}               }
  sub init_arg             { $_[0]->{init_arg}               }
  sub type_constraint      { $_[0]->{type_constraint}        }
  
  sub trigger              { $_[0]->{trigger}                }
  sub builder              { $_[0]->{builder}                }
  sub should_auto_deref    { $_[0]->{auto_deref}             }
  sub should_coerce        { $_[0]->{coerce}                 }
  
  sub documentation        { $_[0]->{documentation}          }
  sub insertion_order      { $_[0]->{insertion_order}        }
  
  # predicates
  
  sub has_accessor         { exists $_[0]->{accessor}        }
  sub has_reader           { exists $_[0]->{reader}          }
  sub has_writer           { exists $_[0]->{writer}          }
  sub has_predicate        { exists $_[0]->{predicate}       }
  sub has_clearer          { exists $_[0]->{clearer}         }
  sub has_handles          { exists $_[0]->{handles}         }
  
  sub has_default          { exists $_[0]->{default}         }
  sub has_type_constraint  { exists $_[0]->{type_constraint} }
  sub has_trigger          { exists $_[0]->{trigger}         }
  sub has_builder          { exists $_[0]->{builder}         }
  
  sub has_documentation    { exists $_[0]->{documentation}   }
  
  sub _process_options{
  	my($class, $name, $args) = @_;
  
  	# taken from Class::MOP::Attribute::new
  
  	defined($name)
  		or $class->throw_error('You must provide a name for the attribute');
  
  	if(!exists $args->{init_arg}){
  		$args->{init_arg} = $name;
  	}
  
  	# 'required' requires either 'init_arg', 'builder', or 'default'
  	my $can_be_required = defined( $args->{init_arg} );
  
  	if(exists $args->{builder}){
  		# XXX:
  		# Moose refuses a CODE ref builder, but Mouse doesn't for backward compatibility
  		# This feature will be changed in a future. (gfx)
  		$class->throw_error('builder must be a defined scalar value which is a method name')
  			#if ref $args->{builder} || !defined $args->{builder};
  			if !defined $args->{builder};
  
  		$can_be_required++;
  	}
  	elsif(exists $args->{default}){
  		if(ref $args->{default} && ref($args->{default}) ne 'CODE'){
  			$class->throw_error("References are not allowed as default values, you must "
  							  . "wrap the default of '$name' in a CODE reference (ex: sub { [] } and not [])");
  		}
  		$can_be_required++;
  	}
  
  	if( $args->{required} && !$can_be_required ) {
  		$class->throw_error("You cannot have a required attribute ($name) without a default, builder, or an init_arg");
  	}
  
  	# taken from Mouse::Meta::Attribute->new and ->_process_args
  
  	if(exists $args->{is}){
  		my $is = $args->{is};
  
  		if($is eq 'ro'){
  			$args->{reader} ||= $name;
  		}
  		elsif($is eq 'rw'){
  			if(exists $args->{writer}){
  				$args->{reader} ||= $name;
  			 }
  			 else{
  				$args->{accessor} ||= $name;
  			 }
  		}
  		elsif($is eq 'bare'){
  			# do nothing, but don't complain (later) about missing methods
  		}
  		else{
  			$is = 'undef' if !defined $is;
  			$class->throw_error("I do not understand this option (is => $is) on attribute ($name)");
  		}
  	}
  
  	my $tc;
  	if(exists $args->{isa}){
  		$tc = $args->{type_constraint} = Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($args->{isa});
  	}
  
  	if(exists $args->{does}){
  		if(defined $tc){ # both isa and does supplied
  			my $does_ok = do{
  				local $@;
  				eval{ "$tc"->does($args->{does}) };
  			};
  			if(!$does_ok){
  				$class->throw_error("Cannot have both an isa option and a does option because '$tc' does not do '$args->{does}' on attribute ($name)");
  			}
  		}
  		else {
  			$tc = $args->{type_constraint} = Mouse::Util::TypeConstraints::find_or_create_does_type_constraint($args->{does});
  		}
  	}
  
  	if($args->{coerce}){
  		defined($tc)
  			|| $class->throw_error("You cannot have coercion without specifying a type constraint on attribute ($name)");
  
  		$args->{weak_ref}
  			&& $class->throw_error("You cannot have a weak reference to a coerced value on attribute ($name)");
  	}
  
  	if ($args->{lazy_build}) {
  		exists($args->{default})
  			&& $class->throw_error("You can not use lazy_build and default for the same attribute ($name)");
  
  		$args->{lazy}      = 1;
  		$args->{builder} ||= "_build_${name}";
  		if ($name =~ /^_/) {
  			$args->{clearer}   ||= "_clear${name}";
  			$args->{predicate} ||= "_has${name}";
  		}
  		else {
  			$args->{clearer}   ||= "clear_${name}";
  			$args->{predicate} ||= "has_${name}";
  		}
  	}
  
  	if ($args->{auto_deref}) {
  		defined($tc)
  			|| $class->throw_error("You cannot auto-dereference without specifying a type constraint on attribute ($name)");
  
  		( $tc->is_a_type_of('ArrayRef') || $tc->is_a_type_of('HashRef') )
  			|| $class->throw_error("You cannot auto-dereference anything other than a ArrayRef or HashRef on attribute ($name)");
  	}
  
  	if (exists $args->{trigger}) {
  		('CODE' eq ref $args->{trigger})
  			|| $class->throw_error("Trigger must be a CODE ref on attribute ($name)");
  	}
  
  	if ($args->{lazy}) {
  		(exists $args->{default} || defined $args->{builder})
  			|| $class->throw_error("You cannot have a lazy attribute ($name) without specifying a default value for it");
  	}
  
  	return;
  }
  
  
  package Mouse::Meta::TypeConstraint;
  
  use overload
  	'""' => '_as_string',
  	'0+' => '_identity',
  	'|'  => '_unite',
  
  	fallback => 1;
  
  sub name    { $_[0]->{name}    }
  sub parent  { $_[0]->{parent}  }
  sub message { $_[0]->{message} }
  
  sub _identity  { Scalar::Util::refaddr($_[0]) } # overload 0+
  
  sub type_parameter           { $_[0]->{type_parameter} }
  sub _compiled_type_constraint{ $_[0]->{compiled_type_constraint} }
  
  sub __is_parameterized { exists $_[0]->{type_parameter} }
  sub has_coercion {       exists $_[0]->{_compiled_type_coercion} }
  
  
  sub compile_type_constraint{
  	my($self) = @_;
  
  	# add parents first
  	my @checks;
  	for(my $parent = $self->{parent}; defined $parent; $parent = $parent->{parent}){
  		 if($parent->{hand_optimized_type_constraint}){
  			unshift @checks, $parent->{hand_optimized_type_constraint};
  			last; # a hand optimized constraint must include all the parents
  		}
  		elsif($parent->{constraint}){
  			unshift @checks, $parent->{constraint};
  		}
  	}
  
  	# then add child
  	if($self->{constraint}){
  		push @checks, $self->{constraint};
  	}
  
  	if($self->{type_constraints}){ # Union
  		my @types = map{ $_->{compiled_type_constraint} } @{ $self->{type_constraints} };
  		push @checks, sub{
  			foreach my $c(@types){
  				return 1 if $c->($_[0]);
  			}
  			return 0;
  		};
  	}
  
  	if(@checks == 0){
  		$self->{compiled_type_constraint} = \&Mouse::Util::TypeConstraints::Any;
  	}
  	else{
  		$self->{compiled_type_constraint} =  sub{
  		  my(@args) = @_;
  		  for ($args[0]) { # local $_ will cancel tie-ness due to perl's bug
  			  foreach my $c(@checks){
  				  return undef if !$c->(@args);
  			  }
  		  }
  		  return 1;
  		};
  	}
  	return;
  }
  
  sub check {
  	my $self = shift;
  	return $self->_compiled_type_constraint->(@_);
  }
  
  
  package Mouse::Object;
  
  sub BUILDARGS {
  	my $class = shift;
  
  	if (scalar @_ == 1) {
  		(ref($_[0]) eq 'HASH')
  			|| $class->meta->throw_error("Single parameters to new() must be a HASH ref");
  
  		return {%{$_[0]}};
  	}
  	else {
  		return {@_};
  	}
  }
  
  sub new {
  	my $class = shift;
  	my $args  = $class->BUILDARGS(@_);
  	return $class->meta->new_object($args);
  }
  
  sub DESTROY {
  	my $self = shift;
  
  	return unless $self->can('DEMOLISH'); # short circuit
  
  	my $e = do{
  		local $?;
  		local $@;
  		eval{
  			# DEMOLISHALL
  
  			# We cannot count on being able to retrieve a previously made
  			# metaclass, _or_ being able to make a new one during global
  			# destruction. However, we should still be able to use mro at
  			# that time (at least tests suggest so ;)
  
  			foreach my $class (@{ Mouse::Util::get_linear_isa(ref $self) }) {
  				my $demolish = Mouse::Util::get_code_ref($class, 'DEMOLISH')
  					|| next;
  
  				$self->$demolish(Mouse::Util::in_global_destruction());
  			}
  		};
  		$@;
  	};
  
  	no warnings 'misc';
  	die $e if $e; # rethrow
  }
  
  sub BUILDALL {
  	my $self = shift;
  
  	# short circuit
  	return unless $self->can('BUILD');
  
  	for my $class (reverse $self->meta->linearized_isa) {
  		my $build = Mouse::Util::get_code_ref($class, 'BUILD')
  			|| next;
  
  		$self->$build(@_);
  	}
  	return;
  }
  
  sub DEMOLISHALL;
  *DEMOLISHALL = \&DESTROY;
  
  }
  BEGIN{ # lib/Mouse/Exporter.pm
  package Mouse::Exporter;
  use strict;
  use warnings;
  use Carp ();
  
  my %SPEC;
  
  my $strict_bits;
  my $warnings_extra_bits;
  BEGIN{
  	$strict_bits         = strict::bits(qw(subs refs vars));
  	$warnings_extra_bits = warnings::bits(FATAL => 'recursion');
  }
  
  # it must be "require", because Mouse::Util depends on Mouse::Exporter,
  # which depends on Mouse::Util::import()
  require Mouse::Util;
  
  sub import{
  	## no critic ProhibitBitwiseOperators
  
  	# strict->import;
  	$^H              |= $strict_bits;
  	# warnings->import('all', FATAL => 'recursion');
  	${^WARNING_BITS} |= $warnings::Bits{all};
  	${^WARNING_BITS} |= $warnings_extra_bits;
  	return;
  }
  
  
  sub setup_import_methods{
  	my($class, %args) = @_;
  
  	my $exporting_package = $args{exporting_package} ||= caller();
  
  	my($import, $unimport) = $class->build_import_methods(%args);
  
  	Mouse::Util::install_subroutines($exporting_package,
  		import   => $import,
  		unimport => $unimport,
  
  		export_to_level => sub {
  			my($package, $level, undef, @args) = @_; # the third argument is redundant
  			$package->import({ into_level => $level + 1 }, @args);
  		},
  		export => sub {
  			my($package, $into, @args) = @_;
  			$package->import({ into => $into }, @args);
  		},
  	);
  	return;
  }
  
  sub build_import_methods{
  	my($self, %args) = @_;
  
  	my $exporting_package = $args{exporting_package} ||= caller();
  
  	$SPEC{$exporting_package} = \%args;
  
  	# canonicalize args
  	my @export_from;
  	if($args{also}){
  		my %seen;
  		my @stack = ($exporting_package);
  
  		while(my $current = shift @stack){
  			push @export_from, $current;
  
  			my $also = $SPEC{$current}{also} or next;
  			push @stack, grep{ !$seen{$_}++ } ref($also) ? @{ $also } : $also;
  		}
  	}
  	else{
  		@export_from = ($exporting_package);
  	}
  
  	my %exports;
  	my @removables;
  	my @all;
  
  	my @init_meta_methods;
  
  	foreach my $package(@export_from){
  		my $spec = $SPEC{$package} or next;
  
  		if(my $as_is = $spec->{as_is}){
  			foreach my $thingy (@{$as_is}){
  				my($code_package, $code_name, $code);
  
  				if(ref($thingy)){
  					$code = $thingy;
  					($code_package, $code_name) = Mouse::Util::get_code_info($code);
  				}
  				else{
  					$code_package = $package;
  					$code_name    = $thingy;
  					no strict 'refs';
  					$code         = \&{ $code_package . '::' . $code_name };
  			   }
  
  				push @all, $code_name;
  				$exports{$code_name} = $code;
  				if($code_package eq $package){
  					push @removables, $code_name;
  				}
  			}
  		}
  
  		if(my $init_meta = $package->can('init_meta')){
  			if(!grep{ $_ == $init_meta } @init_meta_methods){
  				push @init_meta_methods, $init_meta;
  			}
  		}
  	}
  	$args{EXPORTS}    = \%exports;
  	$args{REMOVABLES} = \@removables;
  
  	$args{groups}{all} ||= \@all;
  
  	if(my $default_list = $args{groups}{default}){
  		my %default;
  		foreach my $keyword(@{$default_list}){
  			$default{$keyword} = $exports{$keyword}
  				|| Carp::confess(qq{The $exporting_package package does not export "$keyword"});
  		}
  		$args{DEFAULT} = \%default;
  	}
  	else{
  		$args{groups}{default} ||= \@all;
  		$args{DEFAULT}           = $args{EXPORTS};
  	}
  
  	if(@init_meta_methods){
  		$args{INIT_META} = \@init_meta_methods;
  	}
  
  	return (\&do_import, \&do_unimport);
  }
  
  # the entity of general import()
  sub do_import {
  	my($package, @args) = @_;
  
  	my $spec = $SPEC{$package}
  		|| Carp::confess("The package $package package does not use Mouse::Exporter");
  
  	my $into = _get_caller_package(ref($args[0]) ? shift @args : undef);
  
  	my @exports;
  	my @traits;
  
  	while(@args){
  		my $arg = shift @args;
  		if($arg =~ s/^-//){
  			if($arg eq 'traits'){
  				push @traits, ref($args[0]) ? @{shift(@args)} : shift(@args);
  			}
  			else {
  				Mouse::Util::not_supported("-$arg");
  			}
  		}
  		elsif($arg =~ s/^://){
  			my $group = $spec->{groups}{$arg}
  				|| Carp::confess(qq{The $package package does not export the group "$arg"});
  			push @exports, @{$group};
  		}
  		else{
  			push @exports, $arg;
  		}
  	}
  
  	# strict->import;
  	$^H              |= $strict_bits;                   ## no critic ProhibitBitwiseOperators
  	# warnings->import('all', FATAL => 'recursion');
  	${^WARNING_BITS} |= $warnings::Bits{all};           ## no critic ProhibitBitwiseOperators
  	${^WARNING_BITS} |= $warnings_extra_bits;           ## no critic ProhibitBitwiseOperators
  
  	if($spec->{INIT_META}){
  		my $meta;
  		foreach my $init_meta(@{$spec->{INIT_META}}){
  			$meta = $package->$init_meta(for_class => $into);
  		}
  
  		if(@traits){
  			my $type = (split /::/, ref $meta)[-1]; # e.g. "Class" for "My::Meta::Class"
  			@traits = map{
  			  ref($_)
  				? $_
  				: Mouse::Util::resolve_metaclass_alias($type => $_, trait => 1)
  			} @traits;
  
  			require Mouse::Util::MetaRole;
  			Mouse::Util::MetaRole::apply_metaroles(
  				for => $into,
  				Mouse::Util::is_a_metarole($into->meta)
  					? (role_metaroles  => { role  => \@traits })
  					: (class_metaroles => { class => \@traits }),
  			);
  		}
  	}
  	elsif(@traits){
  		Carp::confess("Cannot provide traits when $package does not have an init_meta() method");
  	}
  
  	if(@exports){
  		my @export_table;
  		foreach my $keyword(@exports){
  			push @export_table,
  				$keyword => ($spec->{EXPORTS}{$keyword}
  					|| Carp::confess(qq{The $package package does not export "$keyword"})
  				);
  		}
  		Mouse::Util::install_subroutines($into, @export_table);
  	}
  	else{
  		Mouse::Util::install_subroutines($into, %{$spec->{DEFAULT}});
  	}
  	return;
  }
  
  # the entity of general unimport()
  sub do_unimport {
  	my($package, $arg) = @_;
  
  	my $spec = $SPEC{$package}
  		|| Carp::confess("The package $package does not use Mouse::Exporter");
  
  	my $from = _get_caller_package($arg);
  
  	my $stash = do{
  		no strict 'refs';
  		\%{$from . '::'}
  	};
  
  	for my $keyword (@{ $spec->{REMOVABLES} }) {
  		next if !exists $stash->{$keyword};
  		my $gv = \$stash->{$keyword};
  
  		# remove what is from us
  		if(ref($gv) eq 'GLOB' && *{$gv}{CODE} == $spec->{EXPORTS}{$keyword}){
  			delete $stash->{$keyword};
  		}
  	}
  	return;
  }
  
  sub _get_caller_package {
  	my($arg) = @_;
  
  	# We need one extra level because it's called by import so there's a layer
  	# of indirection
  	if(ref $arg){
  		return defined($arg->{into})       ? $arg->{into}
  			 : defined($arg->{into_level}) ? scalar caller(1 + $arg->{into_level})
  			 :                               scalar caller(1);
  	}
  	else{
  		return scalar caller(1);
  	}
  }
  
  }
  BEGIN{ # lib/Mouse/Util.pm
  package Mouse::Util;
  use Mouse::Exporter; # enables strict and warnings
  
  # Note that those which don't exist here are defined in XS or Mouse::PurePerl
  
  # must be here because it will be referred by other modules loaded
  sub get_linear_isa($;$); ## no critic
  
  # must be here because it will called in Mouse::Exporter
  sub install_subroutines {
  	my $into = shift;
  
  	while(my($name, $code) = splice @_, 0, 2){
  		no strict 'refs';
  		no warnings 'once', 'redefine';
  		use warnings FATAL => 'uninitialized';
  		*{$into . '::' . $name} = \&{$code};
  	}
  	return;
  }
  
  BEGIN{
  	# This is used in Mouse::PurePerl
  	Mouse::Exporter->setup_import_methods(
  		as_is => [qw(
  			find_meta
  			does_role
  			resolve_metaclass_alias
  			apply_all_roles
  			english_list
  
  			load_class
  			is_class_loaded
  
  			get_linear_isa
  			get_code_info
  
  			get_code_package
  			get_code_ref
  
  			not_supported
  
  			does meta throw_error dump
  		)],
  		groups => {
  			default => [], # export no functions by default
  
  			# The ':meta' group is 'use metaclass' for Mouse
  			meta    => [qw(does meta dump throw_error)],
  		},
  	);
  
  	our $VERSION = '2.4.1';
  
  	my $xs = !(defined(&is_valid_class_name) || $ENV{MOUSE_PUREPERL} || $ENV{PERL_ONLY});
  
  	# Because Mouse::Util is loaded first in all the Mouse sub-modules,
  	# XSLoader must be placed here, not in Mouse.pm.
  	if($xs){
  		# XXX: XSLoader tries to get the object path from caller's file name
  		#      $hack_mouse_file fools its mechanism
  		(my $hack_mouse_file = __FILE__) =~ s/.Util//; # .../Mouse/Util.pm -> .../Mouse.pm
  		$xs = eval sprintf("#line %d %s\n", __LINE__, $hack_mouse_file) . q{
  			local $^W = 0; # workaround 'redefine' warning to &install_subroutines
  			require XSLoader;
  			XSLoader::load('Mouse', $VERSION);
  			Mouse::Util->import({ into => 'Mouse::Meta::Method::Constructor::XS' }, ':meta');
  			Mouse::Util->import({ into => 'Mouse::Meta::Method::Destructor::XS'  }, ':meta');
  			Mouse::Util->import({ into => 'Mouse::Meta::Method::Accessor::XS'    }, ':meta');
  			return 1;
  		} || 0;
  		warn $@ if $@ && $ENV{MOUSE_XS};
  	}
  
  	if(!$xs){
  		require 'Mouse/PurePerl.pm'; # we don't want to create its namespace
  	}
  
  	*MOUSE_XS = sub(){ $xs };
  
  	# definition of mro::get_linear_isa()
  	my $get_linear_isa;
  	if ($] >= 5.010_000) {
  		require 'mro.pm';
  		$get_linear_isa = \&mro::get_linear_isa;
  	}
  	else {
  		# this code is based on MRO::Compat::__get_linear_isa
  		my $_get_linear_isa_dfs; # this recurses so it isn't pretty
  		$_get_linear_isa_dfs = sub {
  			my($classname) = @_;
  
  			my @lin = ($classname);
  			my %stored;
  
  			no strict 'refs';
  			foreach my $parent (@{"$classname\::ISA"}) {
  				foreach  my $p(@{ $_get_linear_isa_dfs->($parent) }) {
  					next if exists $stored{$p};
  					push(@lin, $p);
  					$stored{$p} = 1;
  				}
  			}
  			return \@lin;
  		};
  
  		{
  			package # hide from PAUSE
  				Class::C3;
  			our %MRO; # avoid 'once' warnings
  		}
  
  		# MRO::Compat::__get_linear_isa has no prototype, so
  		# we define a prototyped version for compatibility with core's
  		# See also MRO::Compat::__get_linear_isa.
  		$get_linear_isa = sub ($;$){
  			my($classname, $type) = @_;
  
  			if(!defined $type){
  				$type = exists $Class::C3::MRO{$classname} ? 'c3' : 'dfs';
  			}
  			if($type eq 'c3'){
  				require Class::C3;
  				return [Class::C3::calculateMRO($classname)];
  			}
  			else{
  				return $_get_linear_isa_dfs->($classname);
  			}
  		};
  	}
  
  	*get_linear_isa = $get_linear_isa;
  }
  
  use Carp         ();
  use Scalar::Util ();
  
  # aliases as public APIs
  # it must be 'require', not 'use', because Mouse::Meta::Module depends on Mouse::Util
  require Mouse::Meta::Module; # for the entities of metaclass cache utilities
  
  # aliases
  {
  	*class_of                    = \&Mouse::Meta::Module::_class_of;
  	*get_metaclass_by_name       = \&Mouse::Meta::Module::_get_metaclass_by_name;
  	*get_all_metaclass_instances = \&Mouse::Meta::Module::_get_all_metaclass_instances;
  	*get_all_metaclass_names     = \&Mouse::Meta::Module::_get_all_metaclass_names;
  
  	*Mouse::load_class           = \&load_class;
  	*Mouse::is_class_loaded      = \&is_class_loaded;
  
  	# is-a predicates
  	#generate_isa_predicate_for('Mouse::Meta::TypeConstraint' => 'is_a_type_constraint');
  	#generate_isa_predicate_for('Mouse::Meta::Class'          => 'is_a_metaclass');
  	#generate_isa_predicate_for('Mouse::Meta::Role'           => 'is_a_metarole');
  
  	# duck type predicates
  	generate_can_predicate_for(['_compiled_type_constraint']  => 'is_a_type_constraint');
  	generate_can_predicate_for(['create_anon_class']          => 'is_a_metaclass');
  	generate_can_predicate_for(['create_anon_role']           => 'is_a_metarole');
  }
  
  sub in_global_destruction;
  
  if (defined ${^GLOBAL_PHASE}) {
  	*in_global_destruction = sub {
  		return ${^GLOBAL_PHASE} eq 'DESTRUCT';
  	};
  }
  else {
  	my $in_global_destruction = 0;
  	END { $in_global_destruction = 1 }
  	*in_global_destruction = sub {
  		return $in_global_destruction;
  	};
  }
  
  # Moose::Util compatible utilities
  
  sub find_meta{
  	return class_of( $_[0] );
  }
  
  sub _does_role_impl {
  	my ($class_or_obj, $role_name) = @_;
  
  	my $meta = class_of($class_or_obj);
  
  	(defined $role_name)
  		|| ($meta || 'Mouse::Meta::Class')->throw_error("You must supply a role name to does()");
  
  	return defined($meta) && $meta->does_role($role_name);
  }
  
  sub does_role {
  	my($thing, $role_name) = @_;
  
  	if( (Scalar::Util::blessed($thing) || is_class_loaded($thing))
  			&& $thing->can('does')) {
  		return $thing->does($role_name);
  	}
  	goto &_does_role_impl;
  }
  
  # taken from Mouse::Util (0.90)
  {
  	my %cache;
  
  	sub resolve_metaclass_alias {
  		my ( $type, $metaclass_name, %options ) = @_;
  
  		my $cache_key = $type . q{ } . ( $options{trait} ? '-Trait' : '' );
  
  		return $cache{$cache_key}{$metaclass_name} ||= do{
  
  			my $possible_full_name = join '::',
  				'Mouse::Meta', $type, 'Custom', ($options{trait} ? 'Trait' : ()), $metaclass_name
  			;
  
  			my $loaded_class = load_first_existing_class(
  				$possible_full_name,
  				$metaclass_name
  			);
  
  			$loaded_class->can('register_implementation')
  				? $loaded_class->register_implementation
  				: $loaded_class;
  		};
  	}
  }
  
  # Utilities from Class::MOP
  
  sub get_code_info;
  sub get_code_package;
  
  sub is_valid_class_name;
  sub is_class_loaded;
  
  # taken from Class/MOP.pm
  sub load_first_existing_class {
  	my @classes = @_
  	  or return;
  
  	my %exceptions;
  	for my $class (@classes) {
  		my $e = _try_load_one_class($class);
  
  		if ($e) {
  			$exceptions{$class} = $e;
  		}
  		else {
  			return $class;
  		}
  	}
  
  	# not found
  	Carp::confess join(
  		"\n",
  		map {
  			sprintf( "Could not load class (%s) because : %s",
  				$_, $exceptions{$_} )
  		  } @classes
  	);
  }
  
  # taken from Class/MOP.pm
  sub _try_load_one_class {
  	my $class = shift;
  
  	unless ( is_valid_class_name($class) ) {
  		my $display = defined($class) ? $class : 'undef';
  		Carp::confess "Invalid class name ($display)";
  	}
  
  	return '' if is_class_loaded($class);
  
  	$class  =~ s{::}{/}g;
  	$class .= '.pm';
  
  	return do {
  		local $@;
  		eval { require $class };
  		$@;
  	};
  }
  
  
  sub load_class {
  	my $class = shift;
  	my $e = _try_load_one_class($class);
  	Carp::confess "Could not load class ($class) because : $e" if $e;
  
  	return $class;
  }
  
  
  sub apply_all_roles {
  	my $consumer = Scalar::Util::blessed($_[0])
  		?                                $_[0]   # instance
  		: Mouse::Meta::Class->initialize($_[0]); # class or role name
  
  	my @roles;
  
  	# Basis of Data::OptList
  	my $max = scalar(@_);
  	for (my $i = 1; $i < $max ; $i++) {
  		my $role = $_[$i];
  		my $role_name;
  		if(ref $role) {
  			$role_name = $role->name;
  		}
  		else {
  			$role_name = $role;
  			load_class($role_name);
  			$role = get_metaclass_by_name($role_name);
  		}
  
  		if ($i + 1 < $max && ref($_[$i + 1]) eq 'HASH') {
  			push @roles, [ $role => $_[++$i] ];
  		} else {
  			push @roles, [ $role => undef ];
  		}
  		is_a_metarole($role)
  			|| $consumer->meta->throw_error("You can only consume roles, $role_name is not a Mouse role");
  	}
  
  	if ( scalar @roles == 1 ) {
  		my ( $role, $params ) = @{ $roles[0] };
  		$role->apply( $consumer, defined $params ? $params : () );
  	}
  	else {
  		Mouse::Meta::Role->combine(@roles)->apply($consumer);
  	}
  	return;
  }
  
  # taken from Moose::Util 0.90
  sub english_list {
  	return $_[0] if @_ == 1;
  
  	my @items = sort @_;
  
  	return "$items[0] and $items[1]" if @items == 2;
  
  	my $tail = pop @items;
  
  	return join q{, }, @items, "and $tail";
  }
  
  sub quoted_english_list {
  	return english_list(map { qq{'$_'} } @_);
  }
  
  # common utilities
  
  sub not_supported{
  	my($feature) = @_;
  
  	$feature ||= ( caller(1) )[3] . '()'; # subroutine name
  
  	local $Carp::CarpLevel = $Carp::CarpLevel + 1;
  	Carp::confess("Mouse does not currently support $feature");
  }
  
  # general meta() method
  sub meta :method{
  	return Mouse::Meta::Class->initialize(ref($_[0]) || $_[0]);
  }
  
  # general throw_error() method
  # $o->throw_error($msg, depth => $leve, longmess => $croak_or_confess)
  sub throw_error :method {
  	my($self, $message, %args) = @_;
  
  	local $Carp::CarpLevel  = $Carp::CarpLevel + 1 + ($args{depth} || 0);
  	local $Carp::MaxArgNums = 20; # default is 8, usually we use named args which gets messier though
  
  	if(exists $args{longmess} && !$args{longmess}) {
  		Carp::croak($message);
  	}
  	else{
  		Carp::confess($message);
  	}
  }
  
  # general dump() method
  sub dump :method {
  	my($self, $maxdepth) = @_;
  
  	require 'Data/Dumper.pm'; # we don't want to create its namespace
  	my $dd = Data::Dumper->new([$self]);
  	$dd->Maxdepth(defined($maxdepth) ? $maxdepth : 3);
  	$dd->Indent(1);
  	$dd->Sortkeys(1);
  	$dd->Quotekeys(0);
  	return $dd->Dump();
  }
  
  # general does() method
  sub does :method {
  	goto &_does_role_impl;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/TypeConstraint.pm
  package Mouse::Meta::TypeConstraint;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  sub new {
  	my $class = shift;
  	my %args  = @_ == 1 ? %{$_[0]} : @_;
  
  	$args{name} = '__ANON__' if !defined $args{name};
  
  	my $type_parameter;
  	if(defined $args{parent}) { # subtyping
  		%args = (%{$args{parent}}, %args);
  
  		# a child type must not inherit 'compiled_type_constraint'
  		# and 'hand_optimized_type_constraint' from the parent
  		delete $args{compiled_type_constraint};       # don't inherit it
  		delete $args{hand_optimized_type_constraint}; # don't inherit it
  
  		$type_parameter = $args{type_parameter};
  		if(defined(my $parent_tp = $args{parent}{type_parameter})) {
  			if($parent_tp != $type_parameter) {
  				$type_parameter->is_a_type_of($parent_tp)
  					or $class->throw_error(
  						"$type_parameter is not a subtype of $parent_tp",
  					);
  			}
  			else {
  				$type_parameter = undef;
  			}
  		}
  	}
  
  	my $check;
  
  	if($check = delete $args{optimized}) { # likely to be builtins
  		$args{hand_optimized_type_constraint} = $check;
  		$args{compiled_type_constraint}       = $check;
  	}
  	elsif(defined $type_parameter) { # parameterizing
  		my $generator = $args{constraint_generator}
  			|| $class->throw_error(
  				  "The $args{name} constraint cannot be used,"
  				. " because $type_parameter doesn't subtype"
  				. " from a parameterizable type");
  
  		my $parameterized_check = $generator->($type_parameter);
  		if(defined(my $my_check = $args{constraint})) {
  			$check = sub {
  				return $parameterized_check->($_) && $my_check->($_);
  			};
  		}
  		else {
  			$check = $parameterized_check;
  		}
  		$args{constraint} = $check;
  	}
  	else { # common cases
  		$check = $args{constraint};
  	}
  
  	if(defined($check) && ref($check) ne 'CODE'){
  		$class->throw_error(
  			"Constraint for $args{name} is not a CODE reference");
  	}
  
  	my $self = bless \%args, $class;
  	$self->compile_type_constraint()
  		if !$args{hand_optimized_type_constraint};
  
  	if($args{type_constraints}) { # union types
  		foreach my $type(@{$self->{type_constraints}}){
  			if($type->has_coercion){
  				# set undef for has_coercion()
  				$self->{_compiled_type_coercion} = undef;
  				last;
  			}
  		}
  	}
  
  	return $self;
  }
  
  sub create_child_type {
  	my $self = shift;
  	return ref($self)->new(@_, parent => $self);
  }
  
  sub name;
  sub parent;
  sub message;
  sub has_coercion;
  
  sub check;
  
  sub type_parameter;
  sub __is_parameterized;
  
  sub _compiled_type_constraint;
  sub _compiled_type_coercion;
  
  sub compile_type_constraint;
  
  
  sub _add_type_coercions { # ($self, @pairs)
  	my $self = shift;
  
  	if(exists $self->{type_constraints}){ # union type
  		$self->throw_error(
  			"Cannot add additional type coercions to Union types '$self'");
  	}
  
  	my $coercion_map = ($self->{coercion_map} ||= []);
  	my %has          = map{ $_->[0]->name => undef } @{$coercion_map};
  
  	for(my $i = 0; $i < @_; $i++){
  		my $from   = $_[  $i];
  		my $action = $_[++$i];
  
  		if(exists $has{$from}){
  			$self->throw_error("A coercion action already exists for '$from'");
  		}
  
  		my $type = Mouse::Util::TypeConstraints::find_or_parse_type_constraint($from)
  			or $self->throw_error(
  				"Could not find the type constraint ($from) to coerce from");
  
  		push @{$coercion_map}, [ $type => $action ];
  	}
  
  	$self->{_compiled_type_coercion} = undef;
  	return;
  }
  
  sub _compiled_type_coercion {
  	my($self) = @_;
  
  	my $coercion = $self->{_compiled_type_coercion};
  	return $coercion if defined $coercion;
  
  	if(!$self->{type_constraints}) {
  		my @coercions;
  		foreach my $pair(@{$self->{coercion_map}}) {
  			push @coercions,
  				[ $pair->[0]->_compiled_type_constraint, $pair->[1] ];
  		}
  
  		$coercion = sub {
  		   my($thing) = @_;
  		   foreach my $pair (@coercions) {
  				#my ($constraint, $converter) = @$pair;
  				if ($pair->[0]->($thing)) {
  					return $pair->[1]->($thing) for $thing; # local $_ will cancel tie-ness due to perl's bug
  				}
  		   }
  		   return $thing;
  		};
  	}
  	else { # for union type
  		my @coercions;
  		foreach my $type(@{$self->{type_constraints}}){
  			if($type->has_coercion){
  				push @coercions, $type;
  			}
  		}
  		if(@coercions){
  			$coercion = sub {
  				my($thing) = @_;
  				foreach my $type(@coercions){
  					my $value = $type->coerce($thing);
  					return $value if $self->check($value);
  				}
  				return $thing;
  			};
  		}
  	}
  
  	return( $self->{_compiled_type_coercion} = $coercion );
  }
  
  sub coerce {
  	my $self = shift;
  	return $_[0] if $self->check(@_);
  
  	my $coercion = $self->_compiled_type_coercion
  		or $self->throw_error("Cannot coerce without a type coercion");
  	return  $coercion->(@_);
  }
  
  sub get_message {
  	my ($self, $value) = @_;
  	if ( my $msg = $self->message ) {
  		return $msg->($value) for $value; # local $_ will cancel tie-ness due to perl's bug
  	}
  	else {
  		if(not defined $value) {
  			$value = 'undef';
  		}
  		elsif( ref($value) && defined(&overload::StrVal) ) {
  			$value = overload::StrVal($value);
  		}
  		return "Validation failed for '$self' with value $value";
  	}
  }
  
  sub is_a_type_of {
  	my($self, $other) = @_;
  
  	# ->is_a_type_of('__ANON__') is always false
  	return 0 if !ref($other) && $other eq '__ANON__';
  
  	(my $other_name = $other) =~ s/\s+//g;
  
  	return 1 if $self->name eq $other_name;
  
  	if(exists $self->{type_constraints}){ # union
  		foreach my $type(@{$self->{type_constraints}}) {
  			return 1 if $type->name eq $other_name;
  		}
  	}
  
  	for(my $p = $self->parent; defined $p; $p = $p->parent) {
  		return 1 if $p->name eq $other_name;
  	}
  
  	return 0;
  }
  
  # See also Moose::Meta::TypeConstraint::Parameterizable
  sub parameterize {
  	my($self, $param, $name) = @_;
  
  	if(!ref $param){
  		require Mouse::Util::TypeConstraints;
  		$param = Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($param);
  	}
  
  	$name ||= sprintf '%s[%s]', $self->name, $param->name;
  	return Mouse::Meta::TypeConstraint->new(
  		name           => $name,
  		parent         => $self,
  		type_parameter => $param,
  	);
  }
  
  sub assert_valid {
  	my ($self, $value) = @_;
  
  	if(!$self->check($value)){
  		$self->throw_error($self->get_message($value));
  	}
  	return 1;
  }
  
  # overloading stuff
  
  sub _as_string { $_[0]->name } # overload ""
  sub _identity;                 # overload 0+
  
  sub _unite { # overload infix:<|>
  	my($lhs, $rhs) = @_;
  	require Mouse::Util::TypeConstraints;
  	return Mouse::Util::TypeConstraints::_find_or_create_union_type(
  		$lhs,
  		Mouse::Util::TypeConstraints::find_or_create_isa_type_constraint($rhs),
  	);
  }
  
  }
  BEGIN{ # lib/Mouse/Util/TypeConstraints.pm
  package Mouse::Util::TypeConstraints;
  use Mouse::Util; # enables strict and warnings
  
  use Mouse::Meta::TypeConstraint;
  use Mouse::Exporter;
  
  use Carp         ();
  use Scalar::Util ();
  
  Mouse::Exporter->setup_import_methods(
  	as_is => [qw(
  		as where message optimize_as
  		from via
  
  		type subtype class_type role_type maybe_type duck_type
  		enum
  		coerce
  
  		find_type_constraint
  		register_type_constraint
  	)],
  );
  
  our @CARP_NOT = qw(Mouse::Meta::Attribute);
  
  my %TYPE;
  
  # The root type
  $TYPE{Any} = Mouse::Meta::TypeConstraint->new(
  	name => 'Any',
  );
  
  my @builtins = (
  	# $name    => $parent,   $code,
  
  	# the base type
  	Item       => 'Any',     undef,
  
  	# the maybe[] type
  	Maybe      => 'Item',    undef,
  
  	# value types
  	Undef      => 'Item',    \&Undef,
  	Defined    => 'Item',    \&Defined,
  	Bool       => 'Item',    \&Bool,
  	Value      => 'Defined', \&Value,
  	Str        => 'Value',   \&Str,
  	Num        => 'Str',     \&Num,
  	Int        => 'Num',     \&Int,
  
  	# ref types
  	Ref        => 'Defined', \&Ref,
  	ScalarRef  => 'Ref',     \&ScalarRef,
  	ArrayRef   => 'Ref',     \&ArrayRef,
  	HashRef    => 'Ref',     \&HashRef,
  	CodeRef    => 'Ref',     \&CodeRef,
  	RegexpRef  => 'Ref',     \&RegexpRef,
  	GlobRef    => 'Ref',     \&GlobRef,
  
  	# object types
  	FileHandle => 'GlobRef', \&FileHandle,
  	Object     => 'Ref',     \&Object,
  
  	# special string types
  	ClassName  => 'Str',       \&ClassName,
  	RoleName   => 'ClassName', \&RoleName,
  );
  
  while (my ($name, $parent, $code) = splice @builtins, 0, 3) {
  	$TYPE{$name} = Mouse::Meta::TypeConstraint->new(
  		name      => $name,
  		parent    => $TYPE{$parent},
  		optimized => $code,
  	);
  }
  
  # parametarizable types
  $TYPE{Maybe}   {constraint_generator} = \&_parameterize_Maybe_for;
  $TYPE{ArrayRef}{constraint_generator} = \&_parameterize_ArrayRef_for;
  $TYPE{HashRef} {constraint_generator} = \&_parameterize_HashRef_for;
  
  # sugars
  sub as          ($) { (as          => $_[0]) } ## no critic
  sub where       (&) { (where       => $_[0]) } ## no critic
  sub message     (&) { (message     => $_[0]) } ## no critic
  sub optimize_as (&) { (optimize_as => $_[0]) } ## no critic
  
  sub from    { @_ }
  sub via (&) { $_[0] } ## no critic
  
  # type utilities
  
  sub optimized_constraints { # DEPRECATED
  	Carp::cluck('optimized_constraints() has been deprecated');
  	return \%TYPE;
  }
  
  undef @builtins;        # free the allocated memory
  @builtins = keys %TYPE; # reuse it
  sub list_all_builtin_type_constraints { @builtins }
  sub list_all_type_constraints         { keys %TYPE }
  
  sub _define_type {
  	my $is_subtype = shift;
  	my $name;
  	my %args;
  
  	if(@_ == 1 && ref $_[0] ){    # @_ : { name => $name, where => ... }
  		%args = %{$_[0]};
  	}
  	elsif(@_ == 2 && ref $_[1]) { # @_ : $name => { where => ... }
  		$name = $_[0];
  		%args = %{$_[1]};
  	}
  	elsif(@_ % 2) {               # @_ : $name => ( where => ... )
  		($name, %args) = @_;
  	}
  	else{                         # @_ : (name => $name, where => ...)
  		%args = @_;
  	}
  
  	if(!defined $name){
  		$name = $args{name};
  	}
  
  	$args{name} = $name;
  
  	my $parent = delete $args{as};
  	if($is_subtype && !$parent){
  		$parent = delete $args{name};
  		$name   = undef;
  	}
  
  	if(defined $parent) {
  		$args{parent} = find_or_create_isa_type_constraint($parent);
  	}
  
  	if(defined $name){
  		# set 'package_defined_in' only if it is not a core package
  		my $this = $args{package_defined_in};
  		if(!$this){
  			$this = caller(1);
  			if($this !~ /\A Mouse \b/xms){
  				$args{package_defined_in} = $this;
  			}
  		}
  
  		if(defined $TYPE{$name}){
  			my $that = $TYPE{$name}->{package_defined_in} || __PACKAGE__;
  			if($this ne $that) {
  				my $note = '';
  				if($that eq __PACKAGE__) {
  					$note = sprintf " ('%s' is %s type constraint)",
  						$name,
  						scalar(grep { $name eq $_ } list_all_builtin_type_constraints())
  							? 'a builtin'
  							: 'an implicitly created';
  				}
  				Carp::croak("The type constraint '$name' has already been created in $that"
  						  . " and cannot be created again in $this" . $note);
  			}
  		}
  	}
  
  	$args{constraint} = delete $args{where}        if exists $args{where};
  	$args{optimized}  = delete $args{optimized_as} if exists $args{optimized_as};
  
  	my $constraint = Mouse::Meta::TypeConstraint->new(%args);
  
  	if(defined $name){
  		return $TYPE{$name} = $constraint;
  	}
  	else{
  		return $constraint;
  	}
  }
  
  sub type {
  	return _define_type 0, @_;
  }
  
  sub subtype {
  	return _define_type 1, @_;
  }
  
  sub coerce { # coerce $type, from $from, via { ... }, ...
  	my $type_name = shift;
  	my $type = find_type_constraint($type_name)
  		or Carp::croak("Cannot find type '$type_name', perhaps you forgot to load it");
  
  	$type->_add_type_coercions(@_);
  	return;
  }
  
  sub class_type {
  	my($name, $options) = @_;
  	my $class = $options->{class} || $name;
  
  	# ClassType
  	return subtype $name => (
  		as           => 'Object',
  		optimized_as => Mouse::Util::generate_isa_predicate_for($class),
  		class        => $class,
  	);
  }
  
  sub role_type {
  	my($name, $options) = @_;
  	my $role = $options->{role} || $name;
  
  	# RoleType
  	return subtype $name => (
  		as           => 'Object',
  		optimized_as => sub {
  			return Scalar::Util::blessed($_[0])
  				&& Mouse::Util::does_role($_[0], $role);
  		},
  		role         => $role,
  	);
  }
  
  sub maybe_type {
  	my $param = shift;
  	return _find_or_create_parameterized_type($TYPE{Maybe}, $param);
  }
  
  sub duck_type {
  	my($name, @methods);
  
  	if(ref($_[0]) ne 'ARRAY'){
  		$name = shift;
  	}
  
  	@methods = (@_ == 1 && ref($_[0]) eq 'ARRAY') ? @{$_[0]} : @_;
  
  	# DuckType
  	return _define_type 1, $name => (
  		as           => 'Object',
  		optimized_as => Mouse::Util::generate_can_predicate_for(\@methods),
  		message      => sub {
  			my($object) = @_;
  			my @missing = grep { !$object->can($_) } @methods;
  			return ref($object)
  				. ' is missing methods '
  				. Mouse::Util::quoted_english_list(@missing);
  		},
  		methods      => \@methods,
  	);
  }
  
  sub enum {
  	my($name, %valid);
  
  	if(!(@_ == 1 && ref($_[0]) eq 'ARRAY')){
  		$name = shift;
  	}
  
  	%valid = map{ $_ => undef }
  		(@_ == 1 && ref($_[0]) eq 'ARRAY' ? @{$_[0]} : @_);
  
  	# EnumType
  	return _define_type 1, $name => (
  		as            => 'Str',
  		optimized_as  => sub{
  			return defined($_[0]) && !ref($_[0]) && exists $valid{$_[0]};
  		},
  	);
  }
  
  sub _find_or_create_regular_type{
  	my($spec, $create)  = @_;
  
  	return $TYPE{$spec} if exists $TYPE{$spec};
  
  	my $meta = Mouse::Util::get_metaclass_by_name($spec);
  
  	if(!defined $meta){
  		return $create ? class_type($spec) : undef;
  	}
  
  	if(Mouse::Util::is_a_metarole($meta)){
  		return role_type($spec);
  	}
  	else{
  		return class_type($spec);
  	}
  }
  
  sub _find_or_create_parameterized_type{
  	my($base, $param) = @_;
  
  	my $name = sprintf '%s[%s]', $base->name, $param->name;
  
  	$TYPE{$name} ||= $base->parameterize($param, $name);
  }
  
  sub _find_or_create_union_type{
  	return if grep{ not defined } @_; # all things must be defined
  	my @types = sort
  		map{ $_->{type_constraints} ? @{$_->{type_constraints}} : $_ } @_;
  
  	my $name = join '|', @types;
  
  	# UnionType
  	$TYPE{$name} ||= Mouse::Meta::TypeConstraint->new(
  		name              => $name,
  		type_constraints  => \@types,
  	);
  }
  
  # The type parser
  
  # param : '[' type ']' | NOTHING
  sub _parse_param {
  	my($c) = @_;
  
  	if($c->{spec} =~ s/^\[//){
  		my $type = _parse_type($c, 1);
  
  		if($c->{spec} =~ s/^\]//){
  			return $type;
  		}
  		Carp::croak("Syntax error in type: missing right square bracket in '$c->{orig}'");
  	}
  
  	return undef;
  }
  
  # name : [\w.:]+
  sub _parse_name {
  	my($c, $create) = @_;
  
  	if($c->{spec} =~ s/\A ([\w.:]+) //xms){
  		return _find_or_create_regular_type($1, $create);
  	}
  	Carp::croak("Syntax error in type: expect type name near '$c->{spec}' in '$c->{orig}'");
  }
  
  # single_type : name param
  sub _parse_single_type {
  	my($c, $create) = @_;
  
  	my $type  = _parse_name($c, $create);
  	my $param = _parse_param($c);
  
  	if(defined $type){
  		if(defined $param){
  			return _find_or_create_parameterized_type($type, $param);
  		}
  		else {
  			return $type;
  		}
  	}
  	elsif(defined $param){
  		Carp::croak("Undefined type with parameter [$param] in '$c->{orig}'");
  	}
  	else{
  		return undef;
  	}
  }
  
  # type : single_type  ('|' single_type)*
  sub _parse_type {
  	my($c, $create) = @_;
  
  	my $type = _parse_single_type($c, $create);
  	if($c->{spec}){ # can be an union type
  		my @types;
  		while($c->{spec} =~ s/^\|//){
  			push @types, _parse_single_type($c, $create);
  		}
  		if(@types){
  			return _find_or_create_union_type($type, @types);
  		}
  	}
  	return $type;
  }
  
  
  sub find_type_constraint {
  	my($spec) = @_;
  	return $spec if Mouse::Util::is_a_type_constraint($spec) or not defined $spec;
  
  	$spec =~ s/\s+//g;
  	return $TYPE{$spec};
  }
  
  sub register_type_constraint {
  	my($constraint) = @_;
  	Carp::croak("No type supplied / type is not a valid type constraint")
  		unless Mouse::Util::is_a_type_constraint($constraint);
  	return $TYPE{$constraint->name} = $constraint;
  }
  
  sub find_or_parse_type_constraint {
  	my($spec) = @_;
  	return $spec if Mouse::Util::is_a_type_constraint($spec) or not defined $spec;
  
  	$spec =~ tr/ \t\r\n//d;
  
  	my $tc = $TYPE{$spec};
  	if(defined $tc) {
  		return $tc;
  	}
  
  	my %context = (
  		spec => $spec,
  		orig => $spec,
  	);
  	$tc = _parse_type(\%context);
  
  	if($context{spec}){
  		Carp::croak("Syntax error: extra elements '$context{spec}' in '$context{orig}'");
  	}
  
  	return $TYPE{$spec} = $tc;
  }
  
  sub find_or_create_does_type_constraint{
  	# XXX: Moose does not register a new role_type, but Mouse does.
  	my $tc = find_or_parse_type_constraint(@_);
  	return defined($tc) ? $tc : role_type(@_);
  }
  
  sub find_or_create_isa_type_constraint {
  	# XXX: Moose does not register a new class_type, but Mouse does.
  	my $tc = find_or_parse_type_constraint(@_);
  	return defined($tc) ? $tc : class_type(@_);
  }
  
  }
  BEGIN{ # lib/Mouse.pm
  package Mouse;
  use 5.008_005;
  
  use Mouse::Exporter; # enables strict and warnings
  
  our $VERSION = '2.4.1';
  
  use Carp         ();
  use Scalar::Util ();
  
  use Mouse::Util ();
  
  use Mouse::Meta::Module;
  use Mouse::Meta::Class;
  use Mouse::Meta::Role;
  use Mouse::Meta::Attribute;
  use Mouse::Object;
  use Mouse::Util::TypeConstraints ();
  
  Mouse::Exporter->setup_import_methods(
  	as_is => [qw(
  		extends with
  		has
  		before after around
  		override super
  		augment  inner
  	),
  		\&Scalar::Util::blessed,
  		\&Carp::confess,
     ],
  );
  
  
  sub extends {
  	Mouse::Meta::Class->initialize(scalar caller)->superclasses(@_);
  	return;
  }
  
  sub with {
  	Mouse::Util::apply_all_roles(scalar(caller), @_);
  	return;
  }
  
  sub has {
  	my $meta = Mouse::Meta::Class->initialize(scalar caller);
  	my $name = shift;
  
  	$meta->throw_error(q{Usage: has 'name' => ( key => value, ... )})
  		if @_ % 2; # odd number of arguments
  
  	for my $n(ref($name) ? @{$name} : $name){
  		$meta->add_attribute($n => @_);
  	}
  	return;
  }
  
  sub before {
  	my $meta = Mouse::Meta::Class->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_before_method_modifier($name => $code);
  	}
  	return;
  }
  
  sub after {
  	my $meta = Mouse::Meta::Class->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_after_method_modifier($name => $code);
  	}
  	return;
  }
  
  sub around {
  	my $meta = Mouse::Meta::Class->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_around_method_modifier($name => $code);
  	}
  	return;
  }
  
  our $SUPER_PACKAGE;
  our $SUPER_BODY;
  our @SUPER_ARGS;
  
  sub super {
  	# This check avoids a recursion loop - see
  	# t/100_bugs/020_super_recursion.t
  	return if  defined $SUPER_PACKAGE && $SUPER_PACKAGE ne caller();
  	return if !defined $SUPER_BODY;
  	$SUPER_BODY->(@SUPER_ARGS);
  }
  
  sub override {
  	# my($name, $method) = @_;
  	Mouse::Meta::Class->initialize(scalar caller)->add_override_method_modifier(@_);
  }
  
  our %INNER_BODY;
  our %INNER_ARGS;
  
  sub inner {
  	my $pkg = caller();
  	if ( my $body = $INNER_BODY{$pkg} ) {
  		my $args = $INNER_ARGS{$pkg};
  		local $INNER_ARGS{$pkg};
  		local $INNER_BODY{$pkg};
  		return $body->(@{$args});
  	}
  	else {
  		return;
  	}
  }
  
  sub augment {
  	#my($name, $method) = @_;
  	Mouse::Meta::Class->initialize(scalar caller)->add_augment_method_modifier(@_);
  	return;
  }
  
  sub init_meta {
  	shift;
  	my %args = @_;
  
  	my $class = $args{for_class}
  		or confess("Cannot call init_meta without specifying a for_class");
  
  	my $base_class = $args{base_class} || 'Mouse::Object';
  	my $metaclass  = $args{metaclass}  || 'Mouse::Meta::Class';
  
  	my $meta = $metaclass->initialize($class);
  
  	$meta->add_method(meta => sub{
  		return $metaclass->initialize(ref($_[0]) || $_[0]);
  	});
  
  	$meta->superclasses($base_class)
  		unless $meta->superclasses;
  
  	# make a class type for each Mouse class
  	Mouse::Util::TypeConstraints::class_type($class)
  		unless Mouse::Util::TypeConstraints::find_type_constraint($class);
  
  	return $meta;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Attribute.pm
  package Mouse::Meta::Attribute;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  use Carp ();
  
  use Mouse::Meta::TypeConstraint;
  
  my %valid_options = map { $_ => undef } (
    'accessor',
    'auto_deref',
    'builder',
    'clearer',
    'coerce',
    'default',
    'documentation',
    'does',
    'handles',
    'init_arg',
    'insertion_order',
    'is',
    'isa',
    'lazy',
    'lazy_build',
    'name',
    'predicate',
    'reader',
    'required',
    'traits',
    'trigger',
    'type_constraint',
    'weak_ref',
    'writer',
  
    # internally used
    'associated_class',
    'associated_methods',
    '__METACLASS__',
  
    # Moose defines, but Mouse doesn't
    #'definition_context',
    #'initializer',
  
    # special case for AttributeHelpers
    'provides',
    'curries',
  );
  
  our @CARP_NOT = qw(Mouse::Meta::Class);
  
  sub new {
  	my $class = shift;
  	my $name  = shift;
  
  	my $args  = $class->Mouse::Object::BUILDARGS(@_);
  
  	$class->_process_options($name, $args);
  
  	$args->{name} = $name;
  
  	# check options
  	# (1) known by core
  	my @bad = grep{ !exists $valid_options{$_} } keys %{$args};
  
  	# (2) known by subclasses
  	if(@bad && $class ne __PACKAGE__){
  		my %valid_attrs = (
  			map { $_ => undef }
  			grep { defined }
  			map { $_->init_arg() }
  			$class->meta->get_all_attributes()
  		);
  		@bad = grep{ !exists $valid_attrs{$_} } @bad;
  	}
  
  	# (3) bad options found
  	if(@bad){
  		Carp::carp(
  			"Found unknown argument(s) passed to '$name' attribute constructor in '$class': "
  			. Mouse::Util::english_list(@bad));
  	}
  
  	my $self = bless $args, $class;
  	if($class ne __PACKAGE__){
  		$class->meta->_initialize_object($self, $args);
  	}
  	return $self;
  }
  
  sub has_read_method   { $_[0]->has_reader || $_[0]->has_accessor }
  sub has_write_method  { $_[0]->has_writer || $_[0]->has_accessor }
  
  sub get_read_method   { $_[0]->reader || $_[0]->accessor }
  sub get_write_method  { $_[0]->writer || $_[0]->accessor }
  
  sub get_read_method_ref{
  	my($self) = @_;
  	return $self->{_mouse_cache_read_method_ref}
  		||= $self->_get_accessor_method_ref('get_read_method', '_generate_reader');
  }
  
  sub get_write_method_ref{
  	my($self) = @_;
  	return $self->{_mouse_cache_write_method_ref}
  		||= $self->_get_accessor_method_ref('get_write_method', '_generate_writer');
  }
  
  sub interpolate_class{
  	my($class, $args) = @_;
  
  	if(my $metaclass = delete $args->{metaclass}){
  		$class = Mouse::Util::resolve_metaclass_alias( Attribute => $metaclass );
  	}
  
  	my @traits;
  	if(my $traits_ref = delete $args->{traits}){
  
  		for (my $i = 0; $i < @{$traits_ref}; $i++) {
  			my $trait = Mouse::Util::resolve_metaclass_alias(Attribute => $traits_ref->[$i], trait => 1);
  
  			next if $class->does($trait);
  
  			push @traits, $trait;
  
  			# are there options?
  			push @traits, $traits_ref->[++$i]
  				if ref($traits_ref->[$i+1]);
  		}
  
  		if (@traits) {
  			$class = Mouse::Meta::Class->create_anon_class(
  				superclasses => [ $class ],
  				roles        => \@traits,
  				cache        => 1,
  			)->name;
  		}
  	}
  
  	return( $class, @traits );
  }
  
  sub verify_against_type_constraint {
  	my ($self, $value) = @_;
  
  	my $type_constraint = $self->{type_constraint};
  	return 1 if !$type_constraint;
  	return 1 if $type_constraint->check($value);
  
  	$self->_throw_type_constraint_error($value, $type_constraint);
  }
  
  sub _throw_type_constraint_error {
  	my($self, $value, $type) = @_;
  
  	$self->throw_error(
  		sprintf q{Attribute (%s) does not pass the type constraint because: %s},
  			$self->name,
  			$type->get_message($value),
  	);
  }
  
  sub illegal_options_for_inheritance {
  	return qw(reader writer accessor clearer predicate);
  }
  
  sub clone_and_inherit_options{
  	my $self = shift;
  	my $args = $self->Mouse::Object::BUILDARGS(@_);
  
  	foreach my $illegal($self->illegal_options_for_inheritance) {
  		if(exists $args->{$illegal} and exists $self->{$illegal}) {
  			$self->throw_error("Illegal inherited option: $illegal");
  		}
  	}
  
  	foreach my $name(keys %{$self}){
  		if(!exists $args->{$name}){
  			$args->{$name} = $self->{$name}; # inherit from self
  		}
  	}
  
  	my($attribute_class, @traits) = ref($self)->interpolate_class($args);
  	$args->{traits} = \@traits if @traits;
  
  	# remove temporary caches
  	foreach my $attr(keys %{$args}){
  		if($attr =~ /\A _mouse_cache_/xms){
  			delete $args->{$attr};
  		}
  	}
  
  	# remove default if lazy_build => 1
  	if($args->{lazy_build}) {
  		delete $args->{default};
  	}
  
  	return $attribute_class->new($self->name, $args);
  }
  
  
  sub _get_accessor_method_ref {
  	my($self, $type, $generator) = @_;
  
  	my $metaclass = $self->associated_class
  		|| $self->throw_error('No asocciated class for ' . $self->name);
  
  	my $accessor = $self->$type();
  	if($accessor){
  		return $metaclass->get_method_body($accessor);
  	}
  	else{
  		return $self->accessor_metaclass->$generator($self, $metaclass);
  	}
  }
  
  sub set_value {
  	my($self, $object, $value) = @_;
  	return $self->get_write_method_ref()->($object, $value);
  }
  
  sub get_value {
  	my($self, $object) = @_;
  	return $self->get_read_method_ref()->($object);
  }
  
  sub has_value {
  	my($self, $object) = @_;
  	my $accessor_ref = $self->{_mouse_cache_predicate_ref}
  		||= $self->_get_accessor_method_ref('predicate', '_generate_predicate');
  
  	return $accessor_ref->($object);
  }
  
  sub clear_value {
  	my($self, $object) = @_;
  	my $accessor_ref = $self->{_mouse_cache_crealer_ref}
  		||= $self->_get_accessor_method_ref('clearer', '_generate_clearer');
  
  	return $accessor_ref->($object);
  }
  
  sub associate_method{
  	#my($attribute, $method_name) = @_;
  	my($attribute) = @_;
  	$attribute->{associated_methods}++;
  	return;
  }
  
  sub install_accessors{
  	my($attribute) = @_;
  
  	my $metaclass      = $attribute->associated_class;
  	my $accessor_class = $attribute->accessor_metaclass;
  
  	foreach my $type(qw(accessor reader writer predicate clearer)){
  		if(exists $attribute->{$type}){
  			my $generator = '_generate_' . $type;
  			my $code      = $accessor_class->$generator($attribute, $metaclass);
  			my $name      = $attribute->{$type};
  # TODO: do something for compatibility
  #            if( $metaclass->name->can($name) ) {
  #                my $t = $metaclass->has_method($name) ? 'method' : 'function';
  #                Carp::cluck("You are overwriting a locally defined $t"
  #                    . " ($name) with an accessor");
  #            }
  			$metaclass->add_method($name => $code);
  			$attribute->associate_method($name);
  		}
  	}
  
  	# install delegation
  	if(exists $attribute->{handles}){
  		my %handles = $attribute->_canonicalize_handles();
  		while(my($handle, $method_to_call) = each %handles){
  			next if Mouse::Object->can($handle);
  
  			if($metaclass->has_method($handle)) {
  				$attribute->throw_error("You cannot overwrite a locally defined method ($handle) with a delegation");
  			}
  
  			$metaclass->add_method($handle =>
  				$attribute->_make_delegation_method(
  					$handle, $method_to_call));
  
  			$attribute->associate_method($handle);
  		}
  	}
  
  	return;
  }
  
  sub delegation_metaclass() { ## no critic
  	'Mouse::Meta::Method::Delegation'
  }
  
  sub _canonicalize_handles {
  	my($self) = @_;
  	my $handles = $self->{handles};
  
  	my $handle_type = ref $handles;
  	if ($handle_type eq 'HASH') {
  		return %$handles;
  	}
  	elsif ($handle_type eq 'ARRAY') {
  		return map { $_ => $_ } @$handles;
  	}
  	elsif ($handle_type eq 'Regexp') {
  		my $meta = $self->_find_delegate_metaclass();
  		return map  { $_ => $_ }
  			   grep { /$handles/ }
  				   Mouse::Util::is_a_metarole($meta)
  						? $meta->get_method_list
  						: $meta->get_all_method_names;
  	}
  	elsif ($handle_type eq 'CODE') {
  		return $handles->( $self, $self->_find_delegate_metaclass() );
  	}
  	else {
  		$self->throw_error("Unable to canonicalize the 'handles' option with $handles");
  	}
  }
  
  sub _find_delegate_metaclass {
  	my($self) = @_;
  	my $meta;
  	if($self->{isa}) {
  		$meta = Mouse::Meta::Class->initialize("$self->{isa}");
  	}
  	elsif($self->{does}) {
  		$meta = Mouse::Util::get_metaclass_by_name("$self->{does}");
  	}
  	defined($meta) or $self->throw_error(
  		"Cannot find delegate metaclass for attribute " . $self->name);
  	return $meta;
  }
  
  
  sub _make_delegation_method {
  	my($self, $handle, $method_to_call) = @_;
  	return Mouse::Util::load_class($self->delegation_metaclass)
  		->_generate_delegation($self, $handle, $method_to_call);
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Class.pm
  package Mouse::Meta::Class;
  use Mouse::Util qw/:meta/; # enables strict and warnings
  
  use Scalar::Util ();
  
  use Mouse::Meta::Module;
  our @ISA = qw(Mouse::Meta::Module);
  
  our @CARP_NOT = qw(Mouse); # trust Mouse
  
  sub attribute_metaclass;
  sub method_metaclass;
  
  sub constructor_class;
  sub destructor_class;
  
  
  sub _construct_meta {
  	my($class, %args) = @_;
  
  	$args{attributes} = {};
  	$args{methods}    = {};
  	$args{roles}      = [];
  
  	$args{superclasses} = do {
  		no strict 'refs';
  		\@{ $args{package} . '::ISA' };
  	};
  
  	my $self = bless \%args, ref($class) || $class;
  	if(ref($self) ne __PACKAGE__){
  		$self->meta->_initialize_object($self, \%args);
  	}
  	return $self;
  }
  
  sub create_anon_class{
  	my $self = shift;
  	return $self->create(undef, @_);
  }
  
  sub is_anon_class;
  
  sub roles;
  
  sub calculate_all_roles {
  	my $self = shift;
  	my %seen;
  	return grep { !$seen{ $_->name }++ }
  		   map  { $_->calculate_all_roles } @{ $self->roles };
  }
  
  sub superclasses {
  	my $self = shift;
  
  	if (@_) {
  		foreach my $super(@_){
  			Mouse::Util::load_class($super);
  			my $meta = Mouse::Util::get_metaclass_by_name($super);
  			next if $self->verify_superclass($super, $meta);
  			$self->_reconcile_with_superclass_meta($meta);
  		}
  		return @{ $self->{superclasses} } = @_;
  	}
  
  	return @{ $self->{superclasses} };
  }
  
  sub verify_superclass {
  	my($self, $super, $super_meta) = @_;
  
  	if(defined $super_meta) {
  		if(Mouse::Util::is_a_metarole($super_meta)){
  			$self->throw_error("You cannot inherit from a Mouse Role ($super)");
  		}
  	}
  	else {
  		# The metaclass of $super is not initialized.
  		# i.e. it might be Mouse::Object, a mixin package (e.g. Exporter),
  		# or a foreign class including Moose classes.
  		# See also Mouse::Foreign::Meta::Role::Class.
  		my $mm = $super->can('meta');
  		if(!($mm && $mm == \&Mouse::Util::meta)) {
  			if($super->can('new') or $super->can('DESTROY')) {
  				$self->inherit_from_foreign_class($super);
  			}
  		}
  		return 1; # always ok
  	}
  
  	return $self->isa(ref $super_meta); # checks metaclass compatibility
  }
  
  sub inherit_from_foreign_class {
  	my($class, $super) = @_;
  	if($ENV{PERL_MOUSE_STRICT}) {
  		Carp::carp("You inherit from non-Mouse class ($super),"
  			. " but it is unlikely to work correctly."
  			. " Please consider using MouseX::Foreign");
  	}
  	return;
  }
  
  my @MetaClassTypes = (
  	'attribute',   # Mouse::Meta::Attribute
  	'method',      # Mouse::Meta::Method
  	'constructor', # Mouse::Meta::Method::Constructor
  	'destructor',  # Mouse::Meta::Method::Destructor
  );
  
  sub _reconcile_with_superclass_meta {
  	my($self, $other) = @_;
  
  	# find incompatible traits
  	my %metaroles;
  	foreach my $metaclass_type(@MetaClassTypes){
  		my $accessor = $self->can($metaclass_type . '_metaclass')
  			|| $self->can($metaclass_type . '_class');
  
  		my $other_c = $other->$accessor();
  		my $self_c  = $self->$accessor();
  
  		if(!$self_c->isa($other_c)){
  			$metaroles{$metaclass_type}
  				= [ $self_c->meta->_collect_roles($other_c->meta) ];
  		}
  	}
  
  	$metaroles{class} = [$self->meta->_collect_roles($other->meta)];
  
  	#use Data::Dumper; print Data::Dumper->new([\%metaroles], ['*metaroles'])->Indent(1)->Dump;
  
  	require Mouse::Util::MetaRole;
  	$_[0] = Mouse::Util::MetaRole::apply_metaroles(
  		for             => $self,
  		class_metaroles => \%metaroles,
  	);
  	return;
  }
  
  sub _collect_roles {
  	my ($self, $other) = @_;
  
  	# find common ancestor
  	my @self_lin_isa  = $self->linearized_isa;
  	my @other_lin_isa = $other->linearized_isa;
  
  	my(@self_anon_supers, @other_anon_supers);
  	push @self_anon_supers,  shift @self_lin_isa  while $self_lin_isa[0]->meta->is_anon_class;
  	push @other_anon_supers, shift @other_lin_isa while $other_lin_isa[0]->meta->is_anon_class;
  
  	my $common_ancestor = $self_lin_isa[0] eq $other_lin_isa[0] && $self_lin_isa[0];
  
  	if(!$common_ancestor){
  		$self->throw_error(sprintf '%s cannot have %s as a super class because of their metaclass incompatibility',
  			$self->name, $other->name);
  	}
  
  	my %seen;
  	return sort grep { !$seen{$_}++ } ## no critic
  		(map{ $_->name } map{ $_->meta->calculate_all_roles } @self_anon_supers),
  		(map{ $_->name } map{ $_->meta->calculate_all_roles } @other_anon_supers),
  	;
  }
  
  
  sub find_method_by_name {
  	my($self, $method_name) = @_;
  	defined($method_name)
  		or $self->throw_error('You must define a method name to find');
  
  	foreach my $class( $self->linearized_isa ){
  		my $method = $self->initialize($class)->get_method($method_name);
  		return $method if defined $method;
  	}
  	return undef;
  }
  
  sub get_all_methods {
  	my($self) = @_;
  	return map{ $self->find_method_by_name($_) } $self->get_all_method_names;
  }
  
  sub get_all_method_names {
  	my $self = shift;
  	my %uniq;
  	return grep { $uniq{$_}++ == 0 }
  			map { Mouse::Meta::Class->initialize($_)->get_method_list() }
  			$self->linearized_isa;
  }
  
  sub find_attribute_by_name {
  	my($self, $name) = @_;
  	defined($name)
  		or $self->throw_error('You must define an attribute name to find');
  	foreach my $attr($self->get_all_attributes) {
  		return $attr if $attr->name eq $name;
  	}
  	return undef;
  }
  
  sub add_attribute {
  	my $self = shift;
  
  	my($attr, $name);
  
  	if(Scalar::Util::blessed($_[0])){
  		$attr = $_[0];
  
  		$attr->isa('Mouse::Meta::Attribute')
  			|| $self->throw_error("Your attribute must be an instance of Mouse::Meta::Attribute (or a subclass)");
  
  		$name = $attr->name;
  	}
  	else{
  		# _process_attribute
  		$name = shift;
  
  		my %args = (@_ == 1) ? %{$_[0]} : @_;
  
  		defined($name)
  			or $self->throw_error('You must provide a name for the attribute');
  
  		if ($name =~ s/^\+//) { # inherited attributes
  			my $inherited_attr = $self->find_attribute_by_name($name)
  				or $self->throw_error("Could not find an attribute by the name of '$name' to inherit from in ".$self->name);
  
  			$attr = $inherited_attr->clone_and_inherit_options(%args);
  		}
  		else{
  			my($attribute_class, @traits) = $self->attribute_metaclass->interpolate_class(\%args);
  			$args{traits} = \@traits if @traits;
  
  			$attr = $attribute_class->new($name, %args);
  		}
  	}
  
  	Scalar::Util::weaken( $attr->{associated_class} = $self );
  
  	# install accessors first
  	$attr->install_accessors();
  
  	# then register the attribute to the metaclass
  	$attr->{insertion_order}   = keys %{ $self->{attributes} };
  	$self->{attributes}{$name} = $attr;
  	$self->_invalidate_metaclass_cache();
  
  	if(!$attr->{associated_methods} && ($attr->{is} || '') ne 'bare'){
  		Carp::carp(qq{Attribute ($name) of class }.$self->name
  			.qq{ has no associated methods (did you mean to provide an "is" argument?)});
  	}
  	return $attr;
  }
  
  sub _calculate_all_attributes {
  	my($self) = @_;
  	my %seen;
  	my @all_attrs;
  	foreach my $class($self->linearized_isa) {
  		my $meta  = Mouse::Util::get_metaclass_by_name($class) or next;
  		my @attrs = grep { !$seen{$_->name}++ } values %{$meta->{attributes}};
  		@attrs = sort {
  				$b->{insertion_order} <=> $a->{insertion_order}
  			} @attrs;
  		push @all_attrs, @attrs;
  	}
  	return [reverse @all_attrs];
  }
  
  sub linearized_isa;
  
  sub new_object;
  sub clone_object;
  
  sub immutable_options {
  	my ( $self, @args ) = @_;
  
  	return (
  		inline_constructor => 1,
  		inline_destructor  => 1,
  		constructor_name   => 'new',
  		@args,
  	);
  }
  
  sub make_immutable {
  	my $self = shift;
  	my %args = $self->immutable_options(@_);
  
  	$self->{is_immutable}++;
  
  	if ($args{inline_constructor}) {
  		$self->add_method($args{constructor_name} =>
  			Mouse::Util::load_class($self->constructor_class)
  				->_generate_constructor($self, \%args));
  	}
  
  	if ($args{inline_destructor}) {
  		$self->add_method(DESTROY =>
  			Mouse::Util::load_class($self->destructor_class)
  				->_generate_destructor($self, \%args));
  	}
  
  	# Moose's make_immutable returns true allowing calling code to skip
  	# setting an explicit true value at the end of a source file.
  	return 1;
  }
  
  sub make_mutable {
  	my($self) = @_;
  	$self->{is_immutable} = 0;
  	return;
  }
  
  sub is_immutable;
  sub is_mutable   { !$_[0]->is_immutable }
  
  sub _install_modifier {
  	my( $self, $type, $name, $code ) = @_;
  	my $into = $self->name;
  
  	my $original = $into->can($name)
  		or $self->throw_error("The method '$name' was not found in the inheritance hierarchy for $into");
  
  	my $modifier_table = $self->{modifiers}{$name};
  
  	if(!$modifier_table){
  		my(@before, @after, @around);
  		my $cache = $original;
  		my $modified = sub {
  			if(@before) {
  				for my $c (@before) { $c->(@_) }
  			}
  			unless(@after) {
  				return $cache->(@_);
  			}
  
  			if(wantarray){ # list context
  				my @rval = $cache->(@_);
  
  				for my $c(@after){ $c->(@_) }
  				return @rval;
  			}
  			elsif(defined wantarray){ # scalar context
  				my $rval = $cache->(@_);
  
  				for my $c(@after){ $c->(@_) }
  				return $rval;
  			}
  			else{ # void context
  				$cache->(@_);
  
  				for my $c(@after){ $c->(@_) }
  				return;
  			}
  		};
  
  		$self->{modifiers}{$name} = $modifier_table = {
  			original => $original,
  
  			before   => \@before,
  			after    => \@after,
  			around   => \@around,
  
  			cache    => \$cache, # cache for around modifiers
  		};
  
  		$self->add_method($name => $modified);
  	}
  
  	if($type eq 'before'){
  		unshift @{$modifier_table->{before}}, $code;
  	}
  	elsif($type eq 'after'){
  		push @{$modifier_table->{after}}, $code;
  	}
  	else{ # around
  		push @{$modifier_table->{around}}, $code;
  
  		my $next = ${ $modifier_table->{cache} };
  		${ $modifier_table->{cache} } = sub{ $code->($next, @_) };
  	}
  
  	return;
  }
  
  sub add_before_method_modifier {
  	my ( $self, $name, $code ) = @_;
  	$self->_install_modifier( 'before', $name, $code );
  }
  
  sub add_around_method_modifier {
  	my ( $self, $name, $code ) = @_;
  	$self->_install_modifier( 'around', $name, $code );
  }
  
  sub add_after_method_modifier {
  	my ( $self, $name, $code ) = @_;
  	$self->_install_modifier( 'after', $name, $code );
  }
  
  sub add_override_method_modifier {
  	my ($self, $name, $code) = @_;
  
  	if($self->has_method($name)){
  		$self->throw_error("Cannot add an override method if a local method is already present");
  	}
  
  	my $package = $self->name;
  
  	my $super_body = $package->can($name)
  		or $self->throw_error("You cannot override '$name' because it has no super method");
  
  	$self->add_method($name => sub {
  		local $Mouse::SUPER_PACKAGE = $package;
  		local $Mouse::SUPER_BODY    = $super_body;
  		local @Mouse::SUPER_ARGS    = @_;
  		&{$code};
  	});
  	return;
  }
  
  sub add_augment_method_modifier {
  	my ($self, $name, $code) = @_;
  	if($self->has_method($name)){
  		$self->throw_error("Cannot add an augment method if a local method is already present");
  	}
  
  	my $super = $self->find_method_by_name($name)
  		or $self->throw_error("You cannot augment '$name' because it has no super method");
  
  	my $super_package = $super->package_name;
  	my $super_body    = $super->body;
  
  	$self->add_method($name => sub {
  		local $Mouse::INNER_BODY{$super_package} = $code;
  		local $Mouse::INNER_ARGS{$super_package} = [@_];
  		&{$super_body};
  	});
  	return;
  }
  
  sub does_role {
  	my ($self, $role_name) = @_;
  
  	(defined $role_name)
  		|| $self->throw_error("You must supply a role name to look for");
  
  	$role_name = $role_name->name if ref $role_name;
  
  	for my $class ($self->linearized_isa) {
  		my $meta = Mouse::Util::get_metaclass_by_name($class)
  			or next;
  
  		for my $role (@{ $meta->roles }) {
  
  			return 1 if $role->does_role($role_name);
  		}
  	}
  
  	return 0;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Method.pm
  package Mouse::Meta::Method;
  use Mouse::Util qw(:meta); # enables strict and warnings
  use Scalar::Util ();
  
  use overload
  	'=='  => '_equal',
  	'eq'  => '_equal',
  	'&{}' => sub{ $_[0]->body },
  	fallback => 1,
  ;
  
  sub wrap {
  	my $class = shift;
  	unshift @_, 'body' if @_ % 2 != 0;
  	return $class->_new(@_);
  }
  
  sub _new{
  	my($class, %args) = @_;
  	my $self = bless \%args, $class;
  
  	if($class ne __PACKAGE__){
  		$self->meta->_initialize_object($self, \%args);
  	}
  	return $self;
  }
  
  sub body                 { $_[0]->{body}    }
  sub name                 { $_[0]->{name}    }
  sub package_name         { $_[0]->{package} }
  sub associated_metaclass { $_[0]->{associated_metaclass} }
  
  sub fully_qualified_name {
  	my($self) = @_;
  	return $self->package_name . '::' . $self->name;
  }
  
  # for Moose compat
  sub _equal {
  	my($l, $r) = @_;
  
  	return Scalar::Util::blessed($r)
  			&& $l->body         == $r->body
  			&& $l->name         eq $r->name
  			&& $l->package_name eq $r->package_name;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Method/Accessor.pm
  package Mouse::Meta::Method::Accessor;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  use constant _MOUSE_DEBUG => $ENV{MOUSE_DEBUG} ? 1 : 0;
  
  sub _inline_slot{
  	my(undef, $self_var, $attr_name) = @_;
  	return sprintf '%s->{q{%s}}', $self_var, $attr_name;
  }
  
  sub _generate_accessor_any{
  	my($method_class, $type, $attribute, $class) = @_;
  
  	my $name          = $attribute->name;
  	my $default       = $attribute->default;
  	my $constraint    = $attribute->type_constraint;
  	my $builder       = $attribute->builder;
  	my $trigger       = $attribute->trigger;
  	my $is_weak       = $attribute->is_weak_ref;
  	my $should_deref  = $attribute->should_auto_deref;
  	my $should_coerce = (defined($constraint)
  							&& $constraint->has_coercion
  							&& $attribute->should_coerce);
  
  	my $compiled_type_constraint = defined($constraint)
  		? $constraint->_compiled_type_constraint
  		: undef;
  
  	my $self  = '$_[0]';
  	my $slot  = $method_class->_inline_slot($self, $name);;
  
  	my $accessor = sprintf(qq{package %s;\n#line 1 "%s-accessor for %s (%s)"\n}, $class->name, $type, $name, __FILE__)
  				 . "sub {\n";
  
  	if ($type eq 'rw' || $type eq 'wo') {
  		if($type eq 'rw'){
  			$accessor .=
  				'if (scalar(@_) >= 2) {' . "\n";
  		}
  		else{ # writer
  			$accessor .=
  				'if(@_ < 2){ Carp::confess("Not enough arguments for the writer of $name") }'.
  				'{' . "\n";
  		}
  
  		my $value = '$_[1]';
  
  		if (defined $constraint) {
  			if ($should_coerce) {
  				$accessor .=
  					"\n".
  					'my $val = $constraint->coerce('.$value.');';
  				$value = '$val';
  			}
  			$accessor .=
  				"\n".
  				'$compiled_type_constraint->('.$value.') or
  					$attribute->_throw_type_constraint_error('.$value.', $constraint);' . "\n";
  		}
  
  		# if there's nothing left to do for the attribute we can return during
  		# this setter
  		$accessor .= 'return ' if !$is_weak && !$trigger && !$should_deref;
  
  		$accessor .= "my \@old_value = exists $slot ? $slot : ();\n" if $trigger;
  		$accessor .= "$slot = $value;\n";
  
  		if ($is_weak) {
  			$accessor .= "Scalar::Util::weaken($slot) if ref $slot;\n";
  		}
  
  		if ($trigger) {
  			$accessor .= '$trigger->('.$self.', '.$value.', @old_value);' . "\n";
  		}
  
  		$accessor .= "}\n";
  	}
  	elsif($type eq 'ro') {
  		$accessor .= 'Carp::confess("Cannot assign a value to a read-only accessor of $name") if scalar(@_) >= 2;' . "\n";
  	}
  	else{
  		$class->throw_error("Unknown accessor type '$type'");
  	}
  
  	if ($attribute->is_lazy and $type ne 'wo') {
  		my $value;
  
  		if (defined $builder){
  			$value = "$self->\$builder()";
  		}
  		elsif (ref($default) eq 'CODE'){
  			$value = "$self->\$default()";
  		}
  		else{
  			$value = '$default';
  		}
  
  		$accessor .= "els" if $type eq 'rw';
  		$accessor .= "if(!exists $slot){\n";
  		if($should_coerce){
  			$accessor .= "$slot = \$constraint->coerce($value)";
  		}
  		elsif(defined $constraint){
  			$accessor .= "my \$tmp = $value;\n";
  			$accessor .= "\$compiled_type_constraint->(\$tmp)";
  			$accessor .= " || \$attribute->_throw_type_constraint_error(\$tmp, \$constraint);\n";
  			$accessor .= "$slot = \$tmp;\n";
  		}
  		else{
  			$accessor .= "$slot = $value;\n";
  		}
  		if ($is_weak) {
  			$accessor .= "Scalar::Util::weaken($slot) if ref $slot;\n";
  		}
  		$accessor .= "}\n";
  	}
  
  	if ($should_deref) {
  		if ($constraint->is_a_type_of('ArrayRef')) {
  			$accessor .= "return \@{ $slot || [] } if wantarray;\n";
  		}
  		elsif($constraint->is_a_type_of('HashRef')){
  			$accessor .= "return \%{ $slot || {} } if wantarray;\n";
  		}
  		else{
  			$class->throw_error("Can not auto de-reference the type constraint " . $constraint->name);
  		}
  	}
  
  	$accessor .= "return $slot;\n}\n";
  
  	warn $accessor if _MOUSE_DEBUG;
  	my $code;
  	my $e = do{
  		local $@;
  		$code = eval $accessor;
  		$@;
  	};
  	die $e if $e;
  
  	return $code;
  }
  
  sub _generate_accessor{
  	#my($self, $attribute, $metaclass) = @_;
  	my $self = shift;
  	return $self->_generate_accessor_any(rw => @_);
  }
  
  sub _generate_reader {
  	#my($self, $attribute, $metaclass) = @_;
  	my $self = shift;
  	return $self->_generate_accessor_any(ro => @_);
  }
  
  sub _generate_writer {
  	#my($self, $attribute, $metaclass) = @_;
  	my $self = shift;
  	return $self->_generate_accessor_any(wo => @_);
  }
  
  sub _generate_predicate {
  	#my($self, $attribute, $metaclass) = @_;
  	my(undef, $attribute) = @_;
  
  	my $slot = $attribute->name;
  	return sub{
  		return exists $_[0]->{$slot};
  	};
  }
  
  sub _generate_clearer {
  	#my($self, $attribute, $metaclass) = @_;
  	my(undef, $attribute) = @_;
  
  	my $slot = $attribute->name;
  	return sub{
  		delete $_[0]->{$slot};
  	};
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Method/Constructor.pm
  package Mouse::Meta::Method::Constructor;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  use constant _MOUSE_DEBUG => $ENV{MOUSE_DEBUG} ? 1 : 0;
  
  sub _inline_slot{
  	my(undef, $self_var, $attr_name) = @_;
  	return sprintf '%s->{q{%s}}', $self_var, $attr_name;
  }
  
  sub _generate_constructor {
  	my ($class, $metaclass, $args) = @_;
  
  	my $associated_metaclass_name = $metaclass->name;
  
  	my $buildall      = $class->_generate_BUILDALL($metaclass);
  	my $buildargs     = $class->_generate_BUILDARGS($metaclass);
  	my $initializer   = $metaclass->{_mouse_cache}{_initialize_object} ||=
  	   $class->_generate_initialize_object($metaclass);
  	my $source = sprintf(<<'EOT', __FILE__, $metaclass->name, $buildargs, $buildall);
  #line 1 "%s"
  		package %s;
  		sub {
  			my $class = shift;
  			return $class->Mouse::Object::new(@_)
  				if $class ne __PACKAGE__;
  			# BUILDARGS
  			%s;
  			my $instance = bless {}, $class;
  			$metaclass->$initializer($instance, $args, 0);
  			# BUILDALL
  			%s;
  			return $instance;
  		}
  EOT
  	warn $source if _MOUSE_DEBUG;
  	my $body;
  	my $e = do{
  		local $@;
  		$body = eval $source;
  		$@;
  	};
  	die $e if $e;
  	return $body;
  }
  
  sub _generate_initialize_object {
  	my ($method_class, $metaclass) = @_;
  	my @attrs  = $metaclass->get_all_attributes;
  
  	my @checks = map { $_ && $_->_compiled_type_constraint }
  				 map { $_->type_constraint } @attrs;
  
  	my @res;
  
  	my $has_triggers;
  	my $strict = $metaclass->strict_constructor;
  
  	if($strict){
  		push @res, 'my $used = 0;';
  	}
  
  	for my $index (0 .. @attrs - 1) {
  		my $code = '';
  
  		my $attr = $attrs[$index];
  		my $key  = $attr->name;
  
  		my $init_arg        = $attr->init_arg;
  		my $type_constraint = $attr->type_constraint;
  		my $is_weak_ref     = $attr->is_weak_ref;
  		my $need_coercion;
  
  		my $instance_slot  = $method_class->_inline_slot('$instance', $key);
  		my $attr_var       = "\$attrs[$index]";
  		my $constraint_var;
  
  		if(defined $type_constraint){
  			 $constraint_var = "$attr_var\->{type_constraint}";
  			 $need_coercion  = ($attr->should_coerce && $type_constraint->has_coercion);
  		}
  
  		$code .= "# initialize $key\n";
  
  		my $post_process = '';
  		if(defined $type_constraint){
  			$post_process .= "\$checks[$index]->($instance_slot)\n";
  			$post_process .= "  or $attr_var->_throw_type_constraint_error($instance_slot, $constraint_var);\n";
  		}
  
  		# build cde for an attribute
  		if (defined $init_arg) {
  			my $value = "\$args->{q{$init_arg}}";
  
  			$code .= "if (exists $value) {\n";
  
  			if($need_coercion){
  				$value = "$constraint_var->coerce($value)";
  			}
  
  			$code .= "$instance_slot = $value;\n";
  			$code .= $post_process;
  
  			if ($attr->has_trigger) {
  				$has_triggers++;
  				$code .= "push \@triggers, [$attr_var\->{trigger}, $instance_slot];\n";
  			}
  
  			if ($strict){
  				$code .= '++$used;' . "\n";
  			}
  
  			$code .= "\n} else {\n"; # $value exists
  		}
  
  		if ($attr->has_default || $attr->has_builder) {
  			unless ($attr->is_lazy) {
  				my $default = $attr->default;
  				my $builder = $attr->builder;
  
  				my $value;
  				if (defined($builder)) {
  					$value = "\$instance->$builder()";
  				}
  				elsif (ref($default) eq 'CODE') {
  					$value = "$attr_var\->{default}->(\$instance)";
  				}
  				elsif (defined($default)) {
  					$value = "$attr_var\->{default}";
  				}
  				else {
  					$value = 'undef';
  				}
  
  				if($need_coercion){
  					$value = "$constraint_var->coerce($value)";
  				}
  
  				$code .= "$instance_slot = $value;\n";
  				$code .= $post_process;
  			}
  		}
  		elsif ($attr->is_required) {
  			$code .= "\$meta->throw_error('Attribute ($key) is required')";
  			$code .= "    unless \$is_cloning;\n";
  		}
  
  		$code .= "}\n" if defined $init_arg;
  
  		if($is_weak_ref){
  			$code .= "Scalar::Util::weaken($instance_slot) "
  				   . "if ref $instance_slot and not Scalar::Util::isweak($instance_slot);\n";
  		}
  
  		push @res, $code;
  	}
  
  	if($strict){
  		push @res, q{if($used < keys %{$args})}
  			. q{{ $meta->_report_unknown_args(\@attrs, $args) }};
  	}
  
  	if($metaclass->is_anon_class){
  		push @res, q{$instance->{__METACLASS__} = $meta;};
  	}
  
  	if($has_triggers){
  		unshift @res, q{my @triggers;};
  		push    @res, q{$_->[0]->($instance, $_->[1]) for @triggers;};
  	}
  
  	my $source = sprintf <<'EOT', __FILE__, $metaclass->name, join "\n", @res;
  #line 1 "%s"
  	package %s;
  	sub {
  		my($meta, $instance, $args, $is_cloning) = @_;
  		%s;
  		return $instance;
  	}
  EOT
  	warn $source if _MOUSE_DEBUG;
  	my $body;
  	my $e = do {
  		local $@;
  		$body = eval $source;
  		$@;
  	};
  	die $e if $e;
  	return $body;
  }
  
  sub _generate_BUILDARGS {
  	my(undef, $metaclass) = @_;
  
  	my $class = $metaclass->name;
  	if ( $class->can('BUILDARGS') && $class->can('BUILDARGS') != \&Mouse::Object::BUILDARGS ) {
  		return 'my $args = $class->BUILDARGS(@_)';
  	}
  
  	return <<'...';
  		my $args;
  		if ( scalar @_ == 1 ) {
  			( ref( $_[0] ) eq 'HASH' )
  				|| Carp::confess "Single parameters to new() must be a HASH ref";
  			$args = +{ %{ $_[0] } };
  		}
  		else {
  			$args = +{@_};
  		}
  ...
  }
  
  sub _generate_BUILDALL {
  	my (undef, $metaclass) = @_;
  
  	return '' unless $metaclass->name->can('BUILD');
  
  	my @code;
  	for my $class ($metaclass->linearized_isa) {
  		if (Mouse::Util::get_code_ref($class, 'BUILD')) {
  			unshift  @code, qq{${class}::BUILD(\$instance, \$args);};
  		}
  	}
  	return join "\n", @code;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Method/Delegation.pm
  package Mouse::Meta::Method::Delegation;
  use Mouse::Util qw(:meta); # enables strict and warnings
  use Scalar::Util;
  
  sub _generate_delegation{
  	my (undef, $attr, $handle_name, $method_to_call) = @_;
  
  	my @curried_args;
  	if(ref($method_to_call) eq 'ARRAY'){
  		($method_to_call, @curried_args) = @{$method_to_call};
  	}
  
  	# If it has a reader, we must use it to make method modifiers work
  	my $reader = $attr->get_read_method() || $attr->get_read_method_ref();
  
  	my $can_be_optimized = $attr->{_mouse_cache_method_delegation_can_be_optimized};
  
  	if(!defined $can_be_optimized){
  		my $tc = $attr->type_constraint;
  		$attr->{_mouse_cache_method_delegation_can_be_optimized} =
  			(defined($tc) && $tc->is_a_type_of('Object'))
  			&& ($attr->is_required || $attr->has_default || $attr->has_builder)
  			&& ($attr->is_lazy || !$attr->has_clearer);
  	}
  
  	if($can_be_optimized){
  		# need not check the attribute value
  		return sub {
  			return shift()->$reader()->$method_to_call(@curried_args, @_);
  		};
  	}
  	else {
  		# need to check the attribute value
  		return sub {
  			my $instance = shift;
  			my $proxy    = $instance->$reader();
  
  			my $error = !defined($proxy)                              ? ' is not defined'
  					  : ref($proxy) && !Scalar::Util::blessed($proxy) ? qq{ is not an object (got '$proxy')}
  																	  : undef;
  			if ($error) {
  				$instance->meta->throw_error(
  					"Cannot delegate $handle_name to $method_to_call because "
  						. "the value of "
  						. $attr->name
  						. $error
  				 );
  			}
  			$proxy->$method_to_call(@curried_args, @_);
  		};
  	}
  }
  
  
  }
  BEGIN{ # lib/Mouse/Meta/Method/Destructor.pm
  package Mouse::Meta::Method::Destructor;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  use constant _MOUSE_DEBUG => $ENV{MOUSE_DEBUG} ? 1 : 0;
  
  sub _generate_destructor{
  	my (undef, $metaclass) = @_;
  
  	my $demolishall = '';
  	for my $class ($metaclass->linearized_isa) {
  		if (Mouse::Util::get_code_ref($class, 'DEMOLISH')) {
  			$demolishall .= '                ' . $class
  				. '::DEMOLISH($self, Mouse::Util::in_global_destruction());'
  				. "\n",
  		}
  	}
  
  	if($demolishall) {
  		$demolishall = sprintf <<'EOT', $demolishall;
  		my $e = do{
  			local $?;
  			local $@;
  			eval{
  				%s;
  			};
  			$@;
  		};
  		no warnings 'misc';
  		die $e if $e; # rethrow
  EOT
  	}
  
  	my $name   = $metaclass->name;
  	my $source = sprintf(<<'EOT', __FILE__, $name, $demolishall);
  #line 1 "%s"
  	package %s;
  	sub {
  		my($self) = @_;
  		return $self->Mouse::Object::DESTROY()
  			if ref($self) ne __PACKAGE__;
  		# DEMOLISHALL
  		%s;
  		return;
  	}
  EOT
  
  	warn $source if _MOUSE_DEBUG;
  
  	my $code;
  	my $e = do{
  		local $@;
  		$code = eval $source;
  		$@;
  	};
  	die $e if $e;
  	return $code;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Module.pm
  package Mouse::Meta::Module;
  use Mouse::Util qw/:meta/; # enables strict and warnings
  
  use Carp         ();
  use Scalar::Util ();
  
  my %METAS;
  
  if(Mouse::Util::MOUSE_XS){
  	# register meta storage for performance
  	Mouse::Util::__register_metaclass_storage(\%METAS, 0);
  
  	# ensure thread safety
  	*CLONE = sub { Mouse::Util::__register_metaclass_storage(\%METAS, 1) };
  }
  
  sub initialize {
  	my($class, $package_name, @args) = @_;
  
  	($package_name && !ref($package_name))
  		|| $class->throw_error("You must pass a package name and it cannot be blessed");
  
  	return $METAS{$package_name}
  		||= $class->_construct_meta(package => $package_name, @args);
  }
  
  sub reinitialize {
  	my($class, $package_name, @args) = @_;
  
  	$package_name = $package_name->name if ref $package_name;
  
  	($package_name && !ref($package_name))
  		|| $class->throw_error("You must pass a package name and it cannot be blessed");
  
  	if(exists $METAS{$package_name}) {
  		unshift @args, %{ $METAS{$package_name} };
  	}
  	delete $METAS{$package_name};
  	return $class->initialize($package_name, @args);
  }
  
  sub _class_of{
  	my($class_or_instance) = @_;
  	return undef unless defined $class_or_instance;
  	return $METAS{ ref($class_or_instance) || $class_or_instance };
  }
  
  # Means of accessing all the metaclasses that have
  # been initialized thus far.
  # The public versions are aliased into Mouse::Util::*.
  #sub _get_all_metaclasses         {        %METAS         }
  sub _get_all_metaclass_instances { values %METAS         }
  sub _get_all_metaclass_names     { keys   %METAS         }
  sub _get_metaclass_by_name       { $METAS{$_[0]}         }
  #sub _store_metaclass_by_name     { $METAS{$_[0]} = $_[1] }
  #sub _weaken_metaclass            { weaken($METAS{$_[0]}) }
  #sub _does_metaclass_exist        { defined $METAS{$_[0]} }
  #sub _remove_metaclass_by_name    { delete $METAS{$_[0]}  }
  
  sub name;
  
  sub namespace;
  
  # add_attribute is an abstract method
  
  sub get_attribute_map { # DEPRECATED
  	Carp::cluck('get_attribute_map() has been deprecated. Use get_attribute_list() and get_attribute() instead');
  	return $_[0]->{attributes};
  }
  
  sub has_attribute     { exists $_[0]->{attributes}->{$_[1]} }
  sub get_attribute     {        $_[0]->{attributes}->{$_[1]} }
  sub remove_attribute  { delete $_[0]->{attributes}->{$_[1]} }
  
  sub get_attribute_list{ keys   %{$_[0]->{attributes}} }
  
  # XXX: not completely compatible with Moose
  my %foreign = map{ $_ => undef } qw(
  	Mouse Mouse::Role Mouse::Util Mouse::Util::TypeConstraints
  	Carp Scalar::Util List::Util
  );
  sub _get_method_body {
  	my($self, $method_name) = @_;
  	my $code = Mouse::Util::get_code_ref($self->{package}, $method_name);
  	return $code && !exists $foreign{ Mouse::Util::get_code_package($code) }
  		? $code
  		: undef;
  }
  
  sub add_method;
  
  sub has_method {
  	my($self, $method_name) = @_;
  	defined($method_name)
  		or $self->throw_error('You must define a method name');
  
  	return defined( $self->{methods}{$method_name} )
  		|| defined( $self->_get_method_body($method_name) );
  }
  
  sub get_method_body {
  	my($self, $method_name) = @_;
  	defined($method_name)
  		or $self->throw_error('You must define a method name');
  
  	return $self->{methods}{$method_name}
  		||= $self->_get_method_body($method_name);
  }
  
  sub get_method {
  	my($self, $method_name) = @_;
  
  	if(my $code = $self->get_method_body($method_name)){
  		return Mouse::Util::load_class($self->method_metaclass)->wrap(
  			body                 => $code,
  			name                 => $method_name,
  			package              => $self->name,
  			associated_metaclass => $self,
  		);
  	}
  
  	return undef;
  }
  
  sub get_method_list {
  	my($self) = @_;
  
  	return grep { $self->has_method($_) } keys %{ $self->namespace };
  }
  
  sub _collect_methods { # Mouse specific, used for method modifiers
  	my($meta, @args) = @_;
  
  	my @methods;
  	foreach my $arg(@args){
  		if(my $type = ref $arg){
  			if($type eq 'Regexp'){
  				push @methods, grep { $_ =~ $arg } $meta->get_all_method_names;
  			}
  			elsif($type eq 'ARRAY'){
  				push @methods, @{$arg};
  			}
  			else{
  				my $subname = ( caller(1) )[3];
  				$meta->throw_error(
  					sprintf(
  						'Methods passed to %s must be provided as a list,'
  						. ' ArrayRef or regular expression, not %s',
  						$subname,
  						$type,
  					)
  				);
  			}
  		 }
  		 else{
  			push @methods, $arg;
  		 }
  	 }
  	 return @methods;
  }
  
  my $ANON_SERIAL = 0;  # anonymous class/role id
  my %IMMORTALS;        # immortal anonymous classes
  
  sub create {
  	my($self, $package_name, %options) = @_;
  
  	my $class = ref($self) || $self;
  	$self->throw_error('You must pass a package name') if @_ < 2;
  
  	my $superclasses;
  	if(exists $options{superclasses}){
  		if(Mouse::Util::is_a_metarole($self)){
  			delete $options{superclasses};
  		}
  		else{
  			$superclasses = delete $options{superclasses};
  			(ref $superclasses eq 'ARRAY')
  				|| $self->throw_error("You must pass an ARRAY ref of superclasses");
  		}
  	}
  
  	my $attributes = delete $options{attributes};
  	if(defined $attributes){
  		(ref $attributes eq 'ARRAY' || ref $attributes eq 'HASH')
  			|| $self->throw_error("You must pass an ARRAY ref of attributes");
  	}
  	my $methods = delete $options{methods};
  	if(defined $methods){
  		(ref $methods eq 'HASH')
  			|| $self->throw_error("You must pass a HASH ref of methods");
  	}
  	my $roles = delete $options{roles};
  	if(defined $roles){
  		(ref $roles eq 'ARRAY')
  			|| $self->throw_error("You must pass an ARRAY ref of roles");
  	}
  	my $mortal;
  	my $cache_key;
  
  	if(!defined $package_name){ # anonymous
  		$mortal = !$options{cache};
  
  		# anonymous but immortal
  		if(!$mortal){
  				# something like Super::Class|Super::Class::2=Role|Role::1
  				$cache_key = join '=' => (
  					join('|',      @{$superclasses || []}),
  					join('|', sort @{$roles        || []}),
  				);
  				return $IMMORTALS{$cache_key} if exists $IMMORTALS{$cache_key};
  		}
  		$options{anon_serial_id} = ++$ANON_SERIAL;
  		$package_name = $class . '::__ANON__::' . $ANON_SERIAL;
  	}
  
  
  	# instantiate a module
  	{
  		no strict 'refs';
  		${ $package_name . '::VERSION'   } = delete $options{version}   if exists $options{version};
  		${ $package_name . '::AUTHORITY' } = delete $options{authority} if exists $options{authority};
  	}
  
  	my $meta = $self->initialize( $package_name, %options);
  
  	Scalar::Util::weaken($METAS{$package_name})
  		if $mortal;
  
  	$meta->add_method(meta => sub {
  		$self->initialize(ref($_[0]) || $_[0]);
  	});
  
  	$meta->superclasses(@{$superclasses})
  		if defined $superclasses;
  
  	# NOTE:
  	# process attributes first, so that they can
  	# install accessors, but locally defined methods
  	# can then overwrite them. It is maybe a little odd, but
  	# I think this should be the order of things.
  	if (defined $attributes) {
  		if(ref($attributes) eq 'ARRAY'){
  			# array of Mouse::Meta::Attribute
  			foreach my $attr (@{$attributes}) {
  				$meta->add_attribute($attr);
  			}
  		}
  		else{
  			# hash map of name and attribute spec pairs
  			while(my($name, $attr) = each %{$attributes}){
  				$meta->add_attribute($name => $attr);
  			}
  		}
  	}
  	if (defined $methods) {
  		while(my($method_name, $method_body) = each %{$methods}){
  			$meta->add_method($method_name, $method_body);
  		}
  	}
  	if (defined $roles and !$options{in_application_to_instance}){
  		Mouse::Util::apply_all_roles($package_name, @{$roles});
  	}
  
  	if($cache_key){
  		$IMMORTALS{$cache_key} = $meta;
  	}
  
  	return $meta;
  }
  
  sub DESTROY{
  	my($self) = @_;
  
  	return if Mouse::Util::in_global_destruction();
  
  	my $serial_id = $self->{anon_serial_id};
  	return if !$serial_id;
  
  	# XXX: cleaning stash with threads causes panic/SEGV on legacy perls.
  	if(exists $INC{'threads.pm'}) {
  		# (caller)[2] indicates the caller's line number,
  		# which is zero when the current thread is joining (destroying).
  		return if( (caller)[2] == 0);
  	}
  
  	# clean up mortal anonymous class stuff
  
  	# @ISA is a magical variable, so we must clear it manually.
  	@{$self->{superclasses}} = () if exists $self->{superclasses};
  
  	# Then, clear the symbol table hash
  	%{$self->namespace} = ();
  
  	my $name = $self->name;
  	delete $METAS{$name};
  
  	$name =~ s/ $serial_id \z//xms;
  	no strict 'refs';
  	delete ${$name}{ $serial_id . '::' };
  	return;
  }
  
  
  }
  BEGIN{ # lib/Mouse/Meta/Role.pm
  package Mouse::Meta::Role;
  use Mouse::Util qw(:meta); # enables strict and warnings
  
  use Mouse::Meta::Module;
  our @ISA = qw(Mouse::Meta::Module);
  
  sub method_metaclass;
  
  sub _construct_meta {
  	my $class = shift;
  
  	my %args  = @_;
  
  	$args{methods}          = {};
  	$args{attributes}       = {};
  	$args{required_methods} = [];
  	$args{roles}            = [];
  
  	my $self = bless \%args, ref($class) || $class;
  	if($class ne __PACKAGE__){
  		$self->meta->_initialize_object($self, \%args);
  	}
  	return $self;
  }
  
  sub create_anon_role{
  	my $self = shift;
  	return $self->create(undef, @_);
  }
  
  sub is_anon_role;
  
  sub get_roles;
  
  sub calculate_all_roles {
  	my $self = shift;
  	my %seen;
  	return grep { !$seen{ $_->name }++ }
  		   ($self, map  { $_->calculate_all_roles } @{ $self->get_roles });
  }
  
  sub get_required_method_list{
  	return @{ $_[0]->{required_methods} };
  }
  
  sub add_required_methods {
  	my($self, @methods) = @_;
  	my %required = map{ $_ => 1 } @{$self->{required_methods}};
  	push @{$self->{required_methods}}, grep{ !$required{$_}++ && !$self->has_method($_) } @methods;
  	return;
  }
  
  sub requires_method {
  	my($self, $name) = @_;
  	return scalar( grep{ $_ eq $name } @{ $self->{required_methods} } ) != 0;
  }
  
  sub add_attribute {
  	my $self = shift;
  	my $name = shift;
  
  	$self->{attributes}->{$name} = (@_ == 1) ? $_[0] : { @_ };
  	return;
  }
  
  sub apply {
  	my $self     = shift;
  	my $consumer = shift;
  
  	require 'Mouse/Meta/Role/Application.pm';
  	return Mouse::Meta::Role::Application->new(@_)->apply($self, $consumer);
  }
  
  sub combine {
  	my($self, @role_specs) = @_;
  
  	require 'Mouse/Meta/Role/Composite.pm';
  	return Mouse::Meta::Role::Composite->new(roles => \@role_specs);
  }
  
  sub add_before_method_modifier;
  sub add_around_method_modifier;
  sub add_after_method_modifier;
  
  sub get_before_method_modifiers;
  sub get_around_method_modifiers;
  sub get_after_method_modifiers;
  
  sub add_override_method_modifier{
  	my($self, $method_name, $method) = @_;
  
  	if($self->has_method($method_name)){
  		# This error happens in the override keyword or during role composition,
  		# so I added a message, "A local method of ...", only for compatibility (gfx)
  		$self->throw_error("Cannot add an override of method '$method_name' "
  				   . "because there is a local version of '$method_name'"
  				   . "(A local method of the same name as been found)");
  	}
  
  	$self->{override_method_modifiers}->{$method_name} = $method;
  }
  
  sub get_override_method_modifier {
  	my ($self, $method_name) = @_;
  	return $self->{override_method_modifiers}->{$method_name};
  }
  
  sub does_role {
  	my ($self, $role_name) = @_;
  
  	(defined $role_name)
  		|| $self->throw_error("You must supply a role name to look for");
  
  	$role_name = $role_name->name if ref $role_name;
  
  	# if we are it,.. then return true
  	return 1 if $role_name eq $self->name;
  	# otherwise.. check our children
  	for my $role (@{ $self->get_roles }) {
  		return 1 if $role->does_role($role_name);
  	}
  	return 0;
  }
  
  }
  BEGIN{ # lib/Mouse/Meta/Role/Application.pm
  package Mouse::Meta::Role::Application;
  use Mouse::Util qw(:meta);
  
  sub new {
  	my $class = shift;
  	my $args = $class->Mouse::Object::BUILDARGS(@_);
  
  	if(exists $args->{exclude} or exists $args->{alias}) {
  		warnings::warnif(deprecated =>
  			  'The alias and excludes options for role application have been'
  			. ' renamed -alias and -exclude');
  
  		if($args->{alias} && !exists $args->{-alias}){
  			$args->{-alias} = $args->{alias};
  		}
  		if($args->{excludes} && !exists $args->{-excludes}){
  			$args->{-excludes} = $args->{excludes};
  		}
  	}
  
  	$args->{aliased_methods} = {};
  	if(my $alias = $args->{-alias}){
  		@{$args->{aliased_methods}}{ values %{$alias} } = ();
  	}
  
  	if(my $excludes = $args->{-excludes}){
  		$args->{-excludes} = {}; # replace with a hash ref
  		if(ref $excludes){
  			%{$args->{-excludes}} = (map{ $_ => undef } @{$excludes});
  		}
  		else{
  			$args->{-excludes}{$excludes} = undef;
  		}
  	}
  	my $self = bless $args, $class;
  	if($class ne __PACKAGE__){
  		$self->meta->_initialize_object($self, $args);
  	}
  	return $self;
  }
  
  sub apply {
  	my($self, $role, $consumer, @extra) = @_;
  	my $instance;
  
  	if(Mouse::Util::is_a_metaclass($consumer)) {   # Application::ToClass
  		$self->{_to} = 'class';
  	}
  	elsif(Mouse::Util::is_a_metarole($consumer)) { # Application::ToRole
  		$self->{_to} = 'role';
  	}
  	else {                                         # Appplication::ToInstance
  		$self->{_to} = 'instance';
  		$instance  = $consumer;
  
  		my $meta = Mouse::Util::class_of($instance);
  		$consumer = ($meta || 'Mouse::Meta::Class')
  			->create_anon_class(
  				superclasses => [ref $instance],
  				roles        => [$role],
  				cache        => 0,
  
  				in_application_to_instance => 1, # suppress to apply roles
  			);
  	}
  
  	#$self->check_role_exclusions($role, $consumer, @extra);
  	$self->check_required_methods($role, $consumer, @extra);
  	#$self->check_required_attributes($role, $consumer, @extra);
  
  	$self->apply_attributes($role, $consumer, @extra);
  	$self->apply_methods($role, $consumer, @extra);
  	#$self->apply_override_method_modifiers($role, $consumer, @extra);
  	#$self->apply_before_method_modifiers($role, $consumer, @extra);
  	#$self->apply_around_method_modifiers($role, $consumer, @extra);
  	#$self->apply_after_method_modifiers($role, $consumer, @extra);
  	$self->apply_modifiers($role, $consumer, @extra);
  
  	$self->_append_roles($role, $consumer);
  
  	if(defined $instance){ # Application::ToInstance
  		# rebless instance
  		bless $instance, $consumer->name;
  		$consumer->_initialize_object($instance, $instance, 1);
  	}
  
  	return;
  }
  
  sub check_required_methods {
  	my($self, $role, $consumer) = @_;
  
  	if($self->{_to} eq 'role'){
  		$consumer->add_required_methods($role->get_required_method_list);
  	}
  	else{ # to class or instance
  		my $consumer_class_name = $consumer->name;
  
  		my @missing;
  		foreach my $method_name(@{$role->{required_methods}}){
  			next if exists $self->{aliased_methods}{$method_name};
  			next if exists $role->{methods}{$method_name};
  			next if $consumer_class_name->can($method_name);
  
  			push @missing, $method_name;
  		}
  		if(@missing){
  			$role->throw_error(sprintf "'%s' requires the method%s %s to be implemented by '%s'",
  				$role->name,
  				(@missing == 1 ? '' : 's'), # method or methods
  				Mouse::Util::quoted_english_list(@missing),
  				$consumer_class_name);
  		}
  	}
  
  	return;
  }
  
  sub apply_methods {
  	my($self, $role, $consumer) = @_;
  
  	my $alias    = $self->{-alias};
  	my $excludes = $self->{-excludes};
  
  	foreach my $method_name($role->get_method_list){
  		next if $method_name eq 'meta';
  
  		my $code = $role->get_method_body($method_name);
  
  		if(!exists $excludes->{$method_name}){
  			if(!$consumer->has_method($method_name)){
  				# The third argument $role is used in Role::Composite
  				$consumer->add_method($method_name => $code, $role);
  			}
  		}
  
  		if(exists $alias->{$method_name}){
  			my $dstname = $alias->{$method_name};
  
  			my $dstcode = $consumer->get_method_body($dstname);
  
  			if(defined($dstcode) && $dstcode != $code){
  				$role->throw_error("Cannot create a method alias if a local method of the same name exists");
  			}
  			else{
  				$consumer->add_method($dstname => $code, $role);
  			}
  		}
  	}
  
  	return;
  }
  
  sub apply_attributes {
  	my($self, $role, $consumer) = @_;
  
  	for my $attr_name ($role->get_attribute_list) {
  		next if $consumer->has_attribute($attr_name);
  
  		$consumer->add_attribute($attr_name
  			=> $role->get_attribute($attr_name));
  	}
  	return;
  }
  
  sub apply_modifiers {
  	my($self, $role, $consumer) = @_;
  
  	if(my $modifiers = $role->{override_method_modifiers}){
  		foreach my $method_name (keys %{$modifiers}){
  			$consumer->add_override_method_modifier(
  				$method_name => $modifiers->{$method_name});
  		}
  	}
  
  	for my $modifier_type (qw/before around after/) {
  		my $table = $role->{"${modifier_type}_method_modifiers"}
  			or next;
  
  		my $add_modifier = "add_${modifier_type}_method_modifier";
  
  		while(my($method_name, $modifiers) = each %{$table}){
  			foreach my $code(@{ $modifiers }) {
  				# skip if the modifier is already applied
  				next if $consumer->{"_applied_$modifier_type"}{$method_name, $code}++;
  				$consumer->$add_modifier($method_name => $code);
  			}
  		}
  	}
  	return;
  }
  
  sub _append_roles {
  	my($self, $role, $metaclass_or_role) = @_;
  
  	my $roles = $metaclass_or_role->{roles};
  	foreach my $r($role, @{$role->get_roles}){
  		if(!$metaclass_or_role->does_role($r)){
  			push @{$roles}, $r;
  		}
  	}
  	return;
  }
  }
  BEGIN{ # lib/Mouse/Meta/Role/Composite.pm
  package Mouse::Meta::Role::Composite;
  use Carp ();
  use Mouse::Util; # enables strict and warnings
  use Mouse::Meta::Role;
  use Mouse::Meta::Role::Application;
  our @ISA = qw(Mouse::Meta::Role);
  
  # FIXME: Mouse::Meta::Role::Composite does things in different way from Moose's
  # Moose: creates a new class for the consumer, and applies roles to it.
  # Mouse: creates a composite role and apply roles to the role,
  #        and then applies it to the consumer.
  
  sub new {
  	my $class = shift;
  	my $args  = $class->Mouse::Object::BUILDARGS(@_);
  	my $roles = delete $args->{roles};
  	my $self  = $class->create_anon_role(%{$args});
  	foreach my $role_spec(@{$roles}) {
  		my($role, $args) = ref($role_spec) eq 'ARRAY'
  			? @{$role_spec}
  			: ($role_spec, {});
  		$role->apply($self, %{$args});
  	}
  	return $self;
  }
  
  sub get_method_list {
  	my($self) = @_;
  	return grep { ! $self->{conflicting_methods}{$_} }
  													keys %{ $self->{methods} };
  }
  
  sub add_method {
  	my($self, $method_name, $code, $role) = @_;
  
  	if( ($self->{methods}{$method_name} || 0) == $code){
  		# This role already has the same method.
  		return;
  	}
  
  	if($method_name eq 'meta'){
  		$self->SUPER::add_method($method_name => $code);
  	}
  	else{
  		# no need to add a subroutine to the stash
  		my $roles = $self->{composed_roles_by_method}{$method_name} ||= [];
  		push @{$roles}, $role;
  		if(@{$roles} > 1){
  			$self->{conflicting_methods}{$method_name}++;
  		}
  		$self->{methods}{$method_name} = $code;
  	}
  	return;
  }
  
  sub get_method_body {
  	my($self, $method_name) = @_;
  	return $self->{methods}{$method_name};
  }
  
  sub has_method {
  	# my($self, $method_name) = @_;
  	return 0; # to fool apply_methods() in combine()
  }
  
  sub has_attribute {
  	# my($self, $method_name) = @_;
  	return 0; # to fool appply_attributes() in combine()
  }
  
  sub has_override_method_modifier {
  	# my($self, $method_name) = @_;
  	return 0; # to fool apply_modifiers() in combine()
  }
  
  sub add_attribute {
  	my $self      = shift;
  	my $attr_name = shift;
  	my $spec      = (@_ == 1 ? $_[0] : {@_});
  
  	my $existing = $self->{attributes}{$attr_name};
  	if($existing && $existing != $spec){
  		$self->throw_error("We have encountered an attribute conflict with '$attr_name' "
  						 . "during composition. This is fatal error and cannot be disambiguated.");
  	}
  	$self->SUPER::add_attribute($attr_name, $spec);
  	return;
  }
  
  sub add_override_method_modifier {
  	my($self, $method_name, $code) = @_;
  
  	my $existing = $self->{override_method_modifiers}{$method_name};
  	if($existing && $existing != $code){
  		$self->throw_error( "We have encountered an 'override' method conflict with '$method_name' during "
  						  . "composition (Two 'override' methods of the same name encountered). "
  						  . "This is fatal error.")
  	}
  	$self->SUPER::add_override_method_modifier($method_name, $code);
  	return;
  }
  
  sub apply {
  	my $self     = shift;
  	my $consumer = shift;
  
  	Mouse::Meta::Role::Application::RoleSummation->new(@_)->apply($self, $consumer);
  	return;
  }
  
  package Mouse::Meta::Role::Application::RoleSummation;
  our @ISA = qw(Mouse::Meta::Role::Application);
  
  sub apply_methods {
  	my($self, $role, $consumer, @extra) = @_;
  
  	if(exists $role->{conflicting_methods}){
  		my $consumer_class_name = $consumer->name;
  
  		my @conflicting = grep{ !$consumer_class_name->can($_) }
  			keys %{ $role->{conflicting_methods} };
  
  		if(@conflicting) {
  			my $method_name_conflict = (@conflicting == 1
  				? 'a method name conflict'
  				: 'method name conflicts');
  
  			my %seen;
  			my $roles = Mouse::Util::quoted_english_list(
  				grep{ !$seen{$_}++ } # uniq
  				map { $_->name }
  				map { @{$_} }
  				@{ $role->{composed_roles_by_method} }{@conflicting}
  			);
  
  			$self->throw_error(sprintf
  				  q{Due to %s in roles %s,}
  				. q{ the method%s %s must be implemented or excluded by '%s'},
  					$method_name_conflict,
  					$roles,
  					(@conflicting > 1 ? 's' : ''),
  					Mouse::Util::quoted_english_list(@conflicting),
  					$consumer_class_name);
  		}
  
  		my @changed_in_v2_0_0 = grep {
  			$consumer_class_name->can($_) && ! $consumer->has_method($_)
  		} keys %{ $role->{conflicting_methods} };
  		if (@changed_in_v2_0_0) {
  			my $method_name_conflict = (@changed_in_v2_0_0 == 1
  				? 'a method name conflict'
  				: 'method name conflicts');
  
  			my %seen;
  			my $roles = Mouse::Util::quoted_english_list(
  				grep{ !$seen{$_}++ } # uniq
  				map { $_->name }
  				map { @{$_} }
  				@{ $role->{composed_roles_by_method} }{@changed_in_v2_0_0}
  			);
  
  			Carp::cluck(sprintf
  				  q{Due to %s in roles %s,}
  				. q{ the behavior of method%s %s might be changed}
  				. q{ in Mouse-2.00, check it out},
  					$method_name_conflict,
  					$roles,
  					(@changed_in_v2_0_0 > 1 ? 's' : ''),
  					Mouse::Util::quoted_english_list(@changed_in_v2_0_0),
  					$consumer_class_name);
  		}
  	}
  
  	$self->SUPER::apply_methods($role, $consumer, @extra);
  	return;
  }
  
  package Mouse::Meta::Role::Composite;
  }
  BEGIN{ # lib/Mouse/Meta/Role/Method.pm
  package Mouse::Meta::Role::Method;
  use Mouse::Util; # enables strict and warnings
  
  use Mouse::Meta::Method;
  our @ISA = qw(Mouse::Meta::Method);
  
  sub _new{
  	my($class, %args) = @_;
  	my $self = bless \%args, $class;
  
  	if($class ne __PACKAGE__){
  		$self->meta->_initialize_object($self, \%args);
  	}
  	return $self;
  }
  
  }
  BEGIN{ # lib/Mouse/Object.pm
  package Mouse::Object;
  use Mouse::Util qw(does dump meta); # enables strict and warnings
  # all the stuff are defined in XS or PP
  
  sub DOES {
  	my($self, $class_or_role_name) = @_;
  	return $self->isa($class_or_role_name) || $self->does($class_or_role_name);
  }
  
  }
  BEGIN{ # lib/Mouse/Role.pm
  package Mouse::Role;
  use Mouse::Exporter; # enables strict and warnings
  
  our $VERSION = '2.4.1';
  
  use Carp         ();
  use Scalar::Util ();
  
  use Mouse ();
  
  Mouse::Exporter->setup_import_methods(
  	as_is => [qw(
  		extends with
  		has
  		before after around
  		override super
  		augment  inner
  
  		requires excludes
  	),
  		\&Scalar::Util::blessed,
  		\&Carp::confess,
  	],
  );
  
  
  sub extends  {
  	Carp::croak "Roles do not support 'extends'";
  }
  
  sub with {
  	Mouse::Util::apply_all_roles(scalar(caller), @_);
  	return;
  }
  
  sub has {
  	my $meta = Mouse::Meta::Role->initialize(scalar caller);
  	my $name = shift;
  
  	$meta->throw_error(q{Usage: has 'name' => ( key => value, ... )})
  		if @_ % 2; # odd number of arguments
  
  	for my $n(ref($name) ? @{$name} : $name){
  		$meta->add_attribute($n => @_);
  	}
  	return;
  }
  
  sub before {
  	my $meta = Mouse::Meta::Role->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_before_method_modifier($name => $code);
  	}
  	return;
  }
  
  sub after {
  	my $meta = Mouse::Meta::Role->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_after_method_modifier($name => $code);
  	}
  	return;
  }
  
  sub around {
  	my $meta = Mouse::Meta::Role->initialize(scalar caller);
  	my $code = pop;
  	for my $name($meta->_collect_methods(@_)) {
  		$meta->add_around_method_modifier($name => $code);
  	}
  	return;
  }
  
  
  sub super {
  	return if !defined $Mouse::SUPER_BODY;
  	$Mouse::SUPER_BODY->(@Mouse::SUPER_ARGS);
  }
  
  sub override {
  	# my($name, $code) = @_;
  	Mouse::Meta::Role->initialize(scalar caller)->add_override_method_modifier(@_);
  	return;
  }
  
  # We keep the same errors messages as Moose::Role emits, here.
  sub inner {
  	Carp::croak "Roles cannot support 'inner'";
  }
  
  sub augment {
  	Carp::croak "Roles cannot support 'augment'";
  }
  
  sub requires {
  	my $meta = Mouse::Meta::Role->initialize(scalar caller);
  	$meta->throw_error("Must specify at least one method") unless @_;
  	$meta->add_required_methods(@_);
  	return;
  }
  
  sub excludes {
  	Mouse::Util::not_supported();
  }
  
  sub init_meta{
  	shift;
  	my %args = @_;
  
  	my $class = $args{for_class}
  		or Carp::confess("Cannot call init_meta without specifying a for_class");
  
  	my $metaclass  = $args{metaclass}  || 'Mouse::Meta::Role';
  
  	my $meta = $metaclass->initialize($class);
  
  	$meta->add_method(meta => sub{
  		$metaclass->initialize(ref($_[0]) || $_[0]);
  	});
  
  	# make a role type for each Mouse role
  	Mouse::Util::TypeConstraints::role_type($class)
  		unless Mouse::Util::TypeConstraints::find_type_constraint($class);
  
  	return $meta;
  }
  
  }
  BEGIN{ # lib/Mouse/Util/MetaRole.pm
  package Mouse::Util::MetaRole;
  use Mouse::Util; # enables strict and warnings
  use Scalar::Util ();
  
  sub apply_metaclass_roles {
  	my %args = @_;
  	_fixup_old_style_args(\%args);
  
  	return apply_metaroles(%args);
  }
  
  sub apply_metaroles {
  	my %args = @_;
  
  	my $for = Scalar::Util::blessed($args{for})
  		?                                     $args{for}
  		: Mouse::Util::get_metaclass_by_name( $args{for} );
  
  	if(!$for){
  		Carp::confess("You must pass an initialized class, but '$args{for}' has no metaclass");
  	}
  
  	if ( Mouse::Util::is_a_metarole($for) ) {
  		return _make_new_metaclass( $for, $args{role_metaroles}, 'role' );
  	}
  	else {
  		return _make_new_metaclass( $for, $args{class_metaroles}, 'class' );
  	}
  }
  
  sub _make_new_metaclass {
  	my($for, $roles, $primary) = @_;
  
  	return $for unless keys %{$roles};
  
  	my $new_metaclass = exists($roles->{$primary})
  		? _make_new_class( ref $for, $roles->{$primary} ) # new class with traits
  		:                  ref $for;
  
  	my %classes;
  
  	for my $key ( grep { $_ ne $primary } keys %{$roles} ) {
  		my $metaclass;
  		my $attr = $for->can($metaclass = ($key . '_metaclass'))
  				|| $for->can($metaclass = ($key . '_class'))
  				|| $for->throw_error("Unknown metaclass '$key'");
  
  		$classes{ $metaclass }
  			= _make_new_class( $for->$attr(), $roles->{$key} );
  	}
  
  	return $new_metaclass->reinitialize( $for, %classes );
  }
  
  
  sub _fixup_old_style_args {
  	my $args = shift;
  
  	return if $args->{class_metaroles} || $args->{roles_metaroles};
  
  	$args->{for} = delete $args->{for_class}
  		if exists $args->{for_class};
  
  	my @old_keys = qw(
  		attribute_metaclass_roles
  		method_metaclass_roles
  		wrapped_method_metaclass_roles
  		instance_metaclass_roles
  		constructor_class_roles
  		destructor_class_roles
  		error_class_roles
  
  		application_to_class_class_roles
  		application_to_role_class_roles
  		application_to_instance_class_roles
  		application_role_summation_class_roles
  	);
  
  	my $for = Scalar::Util::blessed($args->{for})
  		?                                     $args->{for}
  		: Mouse::Util::get_metaclass_by_name( $args->{for} );
  
  	my $top_key;
  	if( Mouse::Util::is_a_metaclass($for) ){
  		$top_key = 'class_metaroles';
  
  		$args->{class_metaroles}{class} = delete $args->{metaclass_roles}
  			if exists $args->{metaclass_roles};
  	}
  	else {
  		$top_key = 'role_metaroles';
  
  		$args->{role_metaroles}{role} = delete $args->{metaclass_roles}
  			if exists $args->{metaclass_roles};
  	}
  
  	for my $old_key (@old_keys) {
  		my ($new_key) = $old_key =~ /^(.+)_(?:class|metaclass)_roles$/;
  
  		$args->{$top_key}{$new_key} = delete $args->{$old_key}
  			if exists $args->{$old_key};
  	}
  
  	return;
  }
  
  
  sub apply_base_class_roles {
  	my %options = @_;
  
  	my $for = $options{for_class};
  
  	my $meta = Mouse::Util::class_of($for);
  
  	my $new_base = _make_new_class(
  		$for,
  		$options{roles},
  		[ $meta->superclasses() ],
  	);
  
  	$meta->superclasses($new_base)
  		if $new_base ne $meta->name();
  	return;
  }
  
  sub _make_new_class {
  	my($existing_class, $roles, $superclasses) = @_;
  
  	if(!$superclasses){
  		return $existing_class if !$roles;
  
  		my $meta = Mouse::Meta::Class->initialize($existing_class);
  
  		return $existing_class
  			if !grep { !ref($_) && !$meta->does_role($_) } @{$roles};
  	}
  
  	return Mouse::Meta::Class->create_anon_class(
  		superclasses => $superclasses ? $superclasses : [$existing_class],
  		roles        => $roles,
  		cache        => 1,
  	)->name();
  }
  
  }
  END_OF_TINY
MOUSE_TINY

$fatpacked{"Mouse/TypeRegistry.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_TYPEREGISTRY';
  package Mouse::TypeRegistry;use Mouse::Util::TypeConstraints;sub import {warn "Mouse::TypeRegistry is deprecated, please use Mouse::Util::TypeConstraints instead.";shift @_;unshift @_,'Mouse::Util::TypeConstraints';goto \&Mouse::Util::TypeConstraints::import}sub unimport {warn "Mouse::TypeRegistry is deprecated, please use Mouse::Util::TypeConstraints instead.";shift @_;unshift @_,'Mouse::Util::TypeConstraints';goto \&Mouse::Util::TypeConstraints::unimport}1;
MOUSE_TYPEREGISTRY

$fatpacked{"Mouse/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_UTIL';
  package Mouse::Util;use Mouse::Exporter;sub get_linear_isa($;$);sub install_subroutines {my$into=shift;while(my($name,$code)=splice @_,0,2){no strict 'refs';no warnings 'once','redefine';use warnings FATAL=>'uninitialized';*{$into .'::' .$name}=\&{$code}}return}BEGIN{Mouse::Exporter->setup_import_methods(as_is=>[qw(find_meta does_role resolve_metaclass_alias apply_all_roles english_list load_class is_class_loaded get_linear_isa get_code_info get_code_package get_code_ref not_supported does meta throw_error dump)],groups=>{default=>[],meta=>[qw(does meta dump throw_error)],},);our$VERSION='2.4.1';my$xs=!(defined(&is_valid_class_name)|| $ENV{MOUSE_PUREPERL}|| $ENV{PERL_ONLY});if($xs){(my$hack_mouse_file=__FILE__)=~ s/.Util//;$xs=eval sprintf("#line %d %s\n",__LINE__,$hack_mouse_file).q{
              local $^W = 0; # workaround 'redefine' warning to &install_subroutines
              require XSLoader;
              XSLoader::load('Mouse', $VERSION);
              Mouse::Util->import({ into => 'Mouse::Meta::Method::Constructor::XS' }, ':meta');
              Mouse::Util->import({ into => 'Mouse::Meta::Method::Destructor::XS'  }, ':meta');
              Mouse::Util->import({ into => 'Mouse::Meta::Method::Accessor::XS'    }, ':meta');
              return 1;
          } || 0;warn $@ if $@ && $ENV{MOUSE_XS}}if(!$xs){require 'Mouse/PurePerl.pm'}*MOUSE_XS=sub(){$xs};my$get_linear_isa;if ($] >= 5.010_000){require 'mro.pm';$get_linear_isa=\&mro::get_linear_isa}else {my$_get_linear_isa_dfs;$_get_linear_isa_dfs=sub {my($classname)=@_;my@lin=($classname);my%stored;no strict 'refs';for my$parent (@{"$classname\::ISA"}){for my$p(@{$_get_linear_isa_dfs->($parent)}){next if exists$stored{$p};push(@lin,$p);$stored{$p}=1}}return \@lin};{package Class::C3;our%MRO}$get_linear_isa=sub ($;$){my($classname,$type)=@_;if(!defined$type){$type=exists$Class::C3::MRO{$classname}? 'c3' : 'dfs'}if($type eq 'c3'){require Class::C3;return [Class::C3::calculateMRO($classname)]}else{return$_get_linear_isa_dfs->($classname)}}}*get_linear_isa=$get_linear_isa}use Carp ();use Scalar::Util ();require Mouse::Meta::Module;{*class_of=\&Mouse::Meta::Module::_class_of;*get_metaclass_by_name=\&Mouse::Meta::Module::_get_metaclass_by_name;*get_all_metaclass_instances=\&Mouse::Meta::Module::_get_all_metaclass_instances;*get_all_metaclass_names=\&Mouse::Meta::Module::_get_all_metaclass_names;*Mouse::load_class=\&load_class;*Mouse::is_class_loaded=\&is_class_loaded;generate_can_predicate_for(['_compiled_type_constraint']=>'is_a_type_constraint');generate_can_predicate_for(['create_anon_class']=>'is_a_metaclass');generate_can_predicate_for(['create_anon_role']=>'is_a_metarole')}sub in_global_destruction;if (defined ${^GLOBAL_PHASE}){*in_global_destruction=sub {return ${^GLOBAL_PHASE} eq 'DESTRUCT'}}else {my$in_global_destruction=0;END {$in_global_destruction=1}*in_global_destruction=sub {return$in_global_destruction}}sub find_meta{return class_of($_[0])}sub _does_role_impl {my ($class_or_obj,$role_name)=@_;my$meta=class_of($class_or_obj);(defined$role_name)|| ($meta || 'Mouse::Meta::Class')->throw_error("You must supply a role name to does()");return defined($meta)&& $meta->does_role($role_name)}sub does_role {my($thing,$role_name)=@_;if((Scalar::Util::blessed($thing)|| is_class_loaded($thing))&& $thing->can('does')){return$thing->does($role_name)}goto&_does_role_impl}{my%cache;sub resolve_metaclass_alias {my ($type,$metaclass_name,%options)=@_;my$cache_key=$type .q{ } .($options{trait}? '-Trait' : '');return$cache{$cache_key}{$metaclass_name}||= do{my$possible_full_name=join '::','Mouse::Meta',$type,'Custom',($options{trait}? 'Trait' : ()),$metaclass_name ;my$loaded_class=load_first_existing_class($possible_full_name,$metaclass_name);$loaded_class->can('register_implementation')? $loaded_class->register_implementation : $loaded_class}}}sub get_code_info;sub get_code_package;sub is_valid_class_name;sub is_class_loaded;sub load_first_existing_class {my@classes=@_ or return;my%exceptions;for my$class (@classes){my$e=_try_load_one_class($class);if ($e){$exceptions{$class}=$e}else {return$class}}Carp::confess join("\n",map {sprintf("Could not load class (%s) because : %s",$_,$exceptions{$_})}@classes)}sub _try_load_one_class {my$class=shift;unless (is_valid_class_name($class)){my$display=defined($class)? $class : 'undef';Carp::confess "Invalid class name ($display)"}return '' if is_class_loaded($class);$class =~ s{::}{/}g;$class .= '.pm';return do {local $@;eval {require$class};$@}}sub load_class {my$class=shift;my$e=_try_load_one_class($class);Carp::confess "Could not load class ($class) because : $e" if$e;return$class}sub apply_all_roles {my$consumer=Scalar::Util::blessed($_[0])? $_[0]: Mouse::Meta::Class->initialize($_[0]);my@roles;my$max=scalar(@_);for (my$i=1;$i < $max ;$i++){my$role=$_[$i];my$role_name;if(ref$role){$role_name=$role->name}else {$role_name=$role;load_class($role_name);$role=get_metaclass_by_name($role_name)}if ($i + 1 < $max && ref($_[$i + 1])eq 'HASH'){push@roles,[$role=>$_[++$i]]}else {push@roles,[$role=>undef ]}is_a_metarole($role)|| $consumer->meta->throw_error("You can only consume roles, $role_name is not a Mouse role")}if (scalar@roles==1){my ($role,$params)=@{$roles[0]};$role->apply($consumer,defined$params ? $params : ())}else {Mouse::Meta::Role->combine(@roles)->apply($consumer)}return}sub english_list {return $_[0]if @_==1;my@items=sort @_;return "$items[0] and $items[1]" if@items==2;my$tail=pop@items;return join q{, },@items,"and $tail"}sub quoted_english_list {return english_list(map {qq{'$_'}}@_)}sub not_supported{my($feature)=@_;$feature ||= (caller(1))[3].'()';local$Carp::CarpLevel=$Carp::CarpLevel + 1;Carp::confess("Mouse does not currently support $feature")}sub meta :method{return Mouse::Meta::Class->initialize(ref($_[0])|| $_[0])}sub throw_error :method {my($self,$message,%args)=@_;local$Carp::CarpLevel=$Carp::CarpLevel + 1 + ($args{depth}|| 0);local$Carp::MaxArgNums=20;if(exists$args{longmess}&&!$args{longmess}){Carp::croak($message)}else{Carp::confess($message)}}sub dump :method {my($self,$maxdepth)=@_;require 'Data/Dumper.pm';my$dd=Data::Dumper->new([$self]);$dd->Maxdepth(defined($maxdepth)? $maxdepth : 3);$dd->Indent(1);$dd->Sortkeys(1);$dd->Quotekeys(0);return$dd->Dump()}sub does :method {goto&_does_role_impl}1;
MOUSE_UTIL

$fatpacked{"Mouse/Util/MetaRole.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_UTIL_METAROLE';
  package Mouse::Util::MetaRole;use Mouse::Util;use Scalar::Util ();sub apply_metaclass_roles {my%args=@_;_fixup_old_style_args(\%args);return apply_metaroles(%args)}sub apply_metaroles {my%args=@_;my$for=Scalar::Util::blessed($args{for})? $args{for}: Mouse::Util::get_metaclass_by_name($args{for});if(!$for){Carp::confess("You must pass an initialized class, but '$args{for}' has no metaclass")}if (Mouse::Util::is_a_metarole($for)){return _make_new_metaclass($for,$args{role_metaroles},'role')}else {return _make_new_metaclass($for,$args{class_metaroles},'class')}}sub _make_new_metaclass {my($for,$roles,$primary)=@_;return$for unless keys %{$roles};my$new_metaclass=exists($roles->{$primary})? _make_new_class(ref$for,$roles->{$primary}): ref$for;my%classes;for my$key (grep {$_ ne $primary}keys %{$roles}){my$metaclass;my$attr=$for->can($metaclass=($key .'_metaclass'))|| $for->can($metaclass=($key .'_class'))|| $for->throw_error("Unknown metaclass '$key'");$classes{$metaclass }=_make_new_class($for->$attr(),$roles->{$key})}return$new_metaclass->reinitialize($for,%classes)}sub _fixup_old_style_args {my$args=shift;return if$args->{class_metaroles}|| $args->{roles_metaroles};$args->{for}=delete$args->{for_class}if exists$args->{for_class};my@old_keys=qw(attribute_metaclass_roles method_metaclass_roles wrapped_method_metaclass_roles instance_metaclass_roles constructor_class_roles destructor_class_roles error_class_roles application_to_class_class_roles application_to_role_class_roles application_to_instance_class_roles application_role_summation_class_roles);my$for=Scalar::Util::blessed($args->{for})? $args->{for}: Mouse::Util::get_metaclass_by_name($args->{for});my$top_key;if(Mouse::Util::is_a_metaclass($for)){$top_key='class_metaroles';$args->{class_metaroles}{class}=delete$args->{metaclass_roles}if exists$args->{metaclass_roles}}else {$top_key='role_metaroles';$args->{role_metaroles}{role}=delete$args->{metaclass_roles}if exists$args->{metaclass_roles}}for my$old_key (@old_keys){my ($new_key)=$old_key =~ /^(.+)_(?:class|metaclass)_roles$/;$args->{$top_key}{$new_key}=delete$args->{$old_key}if exists$args->{$old_key}}return}sub apply_base_class_roles {my%options=@_;my$for=$options{for_class};my$meta=Mouse::Util::class_of($for);my$new_base=_make_new_class($for,$options{roles},[$meta->superclasses()],);$meta->superclasses($new_base)if$new_base ne $meta->name();return}sub _make_new_class {my($existing_class,$roles,$superclasses)=@_;if(!$superclasses){return$existing_class if!$roles;my$meta=Mouse::Meta::Class->initialize($existing_class);return$existing_class if!grep {!ref($_)&&!$meta->does_role($_)}@{$roles}}return Mouse::Meta::Class->create_anon_class(superclasses=>$superclasses ? $superclasses : [$existing_class],roles=>$roles,cache=>1,)->name()}1;
MOUSE_UTIL_METAROLE

$fatpacked{"Mouse/Util/TypeConstraints.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MOUSE_UTIL_TYPECONSTRAINTS';
  package Mouse::Util::TypeConstraints;use Mouse::Util;use Mouse::Meta::TypeConstraint;use Mouse::Exporter;use Carp ();use Scalar::Util ();Mouse::Exporter->setup_import_methods(as_is=>[qw(as where message optimize_as from via type subtype class_type role_type maybe_type duck_type enum coerce find_type_constraint register_type_constraint)],);our@CARP_NOT=qw(Mouse::Meta::Attribute);my%TYPE;$TYPE{Any}=Mouse::Meta::TypeConstraint->new(name=>'Any',);my@builtins=(Item=>'Any',undef,Maybe=>'Item',undef,Undef=>'Item',\&Undef,Defined=>'Item',\&Defined,Bool=>'Item',\&Bool,Value=>'Defined',\&Value,Str=>'Value',\&Str,Num=>'Str',\&Num,Int=>'Num',\&Int,Ref=>'Defined',\&Ref,ScalarRef=>'Ref',\&ScalarRef,ArrayRef=>'Ref',\&ArrayRef,HashRef=>'Ref',\&HashRef,CodeRef=>'Ref',\&CodeRef,RegexpRef=>'Ref',\&RegexpRef,GlobRef=>'Ref',\&GlobRef,FileHandle=>'GlobRef',\&FileHandle,Object=>'Ref',\&Object,ClassName=>'Str',\&ClassName,RoleName=>'ClassName',\&RoleName,);while (my ($name,$parent,$code)=splice@builtins,0,3){$TYPE{$name}=Mouse::Meta::TypeConstraint->new(name=>$name,parent=>$TYPE{$parent},optimized=>$code,)}$TYPE{Maybe}{constraint_generator}=\&_parameterize_Maybe_for;$TYPE{ArrayRef}{constraint_generator}=\&_parameterize_ArrayRef_for;$TYPE{HashRef}{constraint_generator}=\&_parameterize_HashRef_for;sub as ($) {(as=>$_[0])}sub where (&) {(where=>$_[0])}sub message (&) {(message=>$_[0])}sub optimize_as (&) {(optimize_as=>$_[0])}sub from {@_}sub via (&) {$_[0]}sub optimized_constraints {Carp::cluck('optimized_constraints() has been deprecated');return \%TYPE}undef@builtins;@builtins=keys%TYPE;sub list_all_builtin_type_constraints {@builtins}sub list_all_type_constraints {keys%TYPE}sub _define_type {my$is_subtype=shift;my$name;my%args;if(@_==1 && ref $_[0]){%args=%{$_[0]}}elsif(@_==2 && ref $_[1]){$name=$_[0];%args=%{$_[1]}}elsif(@_ % 2){($name,%args)=@_}else{%args=@_}if(!defined$name){$name=$args{name}}$args{name}=$name;my$parent=delete$args{as};if($is_subtype &&!$parent){$parent=delete$args{name};$name=undef}if(defined$parent){$args{parent}=find_or_create_isa_type_constraint($parent)}if(defined$name){my$this=$args{package_defined_in};if(!$this){$this=caller(1);if($this !~ /\A Mouse \b/xms){$args{package_defined_in}=$this}}if(defined$TYPE{$name}){my$that=$TYPE{$name}->{package_defined_in}|| __PACKAGE__;if($this ne $that){my$note='';if($that eq __PACKAGE__){$note=sprintf " ('%s' is %s type constraint)",$name,scalar(grep {$name eq $_}list_all_builtin_type_constraints())? 'a builtin' : 'an implicitly created'}Carp::croak("The type constraint '$name' has already been created in $that" ." and cannot be created again in $this" .$note)}}}$args{constraint}=delete$args{where}if exists$args{where};$args{optimized}=delete$args{optimized_as}if exists$args{optimized_as};my$constraint=Mouse::Meta::TypeConstraint->new(%args);if(defined$name){return$TYPE{$name}=$constraint}else{return$constraint}}sub type {return _define_type 0,@_}sub subtype {return _define_type 1,@_}sub coerce {my$type_name=shift;my$type=find_type_constraint($type_name)or Carp::croak("Cannot find type '$type_name', perhaps you forgot to load it");$type->_add_type_coercions(@_);return}sub class_type {my($name,$options)=@_;my$class=$options->{class}|| $name;return subtype$name=>(as=>'Object',optimized_as=>Mouse::Util::generate_isa_predicate_for($class),class=>$class,)}sub role_type {my($name,$options)=@_;my$role=$options->{role}|| $name;return subtype$name=>(as=>'Object',optimized_as=>sub {return Scalar::Util::blessed($_[0])&& Mouse::Util::does_role($_[0],$role)},role=>$role,)}sub maybe_type {my$param=shift;return _find_or_create_parameterized_type($TYPE{Maybe},$param)}sub duck_type {my($name,@methods);if(ref($_[0])ne 'ARRAY'){$name=shift}@methods=(@_==1 && ref($_[0])eq 'ARRAY')? @{$_[0]}: @_;return _define_type 1,$name=>(as=>'Object',optimized_as=>Mouse::Util::generate_can_predicate_for(\@methods),message=>sub {my($object)=@_;my@missing=grep {!$object->can($_)}@methods;return ref($object).' is missing methods ' .Mouse::Util::quoted_english_list(@missing)},methods=>\@methods,)}sub enum {my($name,%valid);if(!(@_==1 && ref($_[0])eq 'ARRAY')){$name=shift}%valid=map{$_=>undef}(@_==1 && ref($_[0])eq 'ARRAY' ? @{$_[0]}: @_);return _define_type 1,$name=>(as=>'Str',optimized_as=>sub{return defined($_[0])&&!ref($_[0])&& exists$valid{$_[0]}},)}sub _find_or_create_regular_type{my($spec,$create)=@_;return$TYPE{$spec}if exists$TYPE{$spec};my$meta=Mouse::Util::get_metaclass_by_name($spec);if(!defined$meta){return$create ? class_type($spec): undef}if(Mouse::Util::is_a_metarole($meta)){return role_type($spec)}else{return class_type($spec)}}sub _find_or_create_parameterized_type{my($base,$param)=@_;my$name=sprintf '%s[%s]',$base->name,$param->name;$TYPE{$name}||= $base->parameterize($param,$name)}sub _find_or_create_union_type{return if grep{not defined}@_;my@types=sort map{$_->{type_constraints}? @{$_->{type_constraints}}: $_}@_;my$name=join '|',@types;$TYPE{$name}||= Mouse::Meta::TypeConstraint->new(name=>$name,type_constraints=>\@types,)}sub _parse_param {my($c)=@_;if($c->{spec}=~ s/^\[//){my$type=_parse_type($c,1);if($c->{spec}=~ s/^\]//){return$type}Carp::croak("Syntax error in type: missing right square bracket in '$c->{orig}'")}return undef}sub _parse_name {my($c,$create)=@_;if($c->{spec}=~ s/\A ([\w.:]+) //xms){return _find_or_create_regular_type($1,$create)}Carp::croak("Syntax error in type: expect type name near '$c->{spec}' in '$c->{orig}'")}sub _parse_single_type {my($c,$create)=@_;my$type=_parse_name($c,$create);my$param=_parse_param($c);if(defined$type){if(defined$param){return _find_or_create_parameterized_type($type,$param)}else {return$type}}elsif(defined$param){Carp::croak("Undefined type with parameter [$param] in '$c->{orig}'")}else{return undef}}sub _parse_type {my($c,$create)=@_;my$type=_parse_single_type($c,$create);if($c->{spec}){my@types;while($c->{spec}=~ s/^\|//){push@types,_parse_single_type($c,$create)}if(@types){return _find_or_create_union_type($type,@types)}}return$type}sub find_type_constraint {my($spec)=@_;return$spec if Mouse::Util::is_a_type_constraint($spec)or not defined$spec;$spec =~ s/\s+//g;return$TYPE{$spec}}sub register_type_constraint {my($constraint)=@_;Carp::croak("No type supplied / type is not a valid type constraint")unless Mouse::Util::is_a_type_constraint($constraint);return$TYPE{$constraint->name}=$constraint}sub find_or_parse_type_constraint {my($spec)=@_;return$spec if Mouse::Util::is_a_type_constraint($spec)or not defined$spec;$spec =~ tr/ \t\r\n//d;my$tc=$TYPE{$spec};if(defined$tc){return$tc}my%context=(spec=>$spec,orig=>$spec,);$tc=_parse_type(\%context);if($context{spec}){Carp::croak("Syntax error: extra elements '$context{spec}' in '$context{orig}'")}return$TYPE{$spec}=$tc}sub find_or_create_does_type_constraint{my$tc=find_or_parse_type_constraint(@_);return defined($tc)? $tc : role_type(@_)}sub find_or_create_isa_type_constraint {my$tc=find_or_parse_type_constraint(@_);return defined($tc)? $tc : class_type(@_)}1;
MOUSE_UTIL_TYPECONSTRAINTS

$fatpacked{"Squirrel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SQUIRREL';
  package Squirrel;use strict;use warnings;sub _choose_backend {if ($INC{"Moose.pm"}){return {backend=>'Moose',import=>\&Moose::import,unimport=>\&Moose::unimport,}}else {require Mouse;return {backend=>'Mouse',import=>\&Mouse::import,unimport=>\&Mouse::unimport,}}}my%pkgs;sub _handlers {my$class=shift;my$caller=caller(1);$pkgs{$caller}||= $class->_choose_backend}sub import {require Carp;Carp::carp("Squirrel is deprecated. Please use Any::Moose instead. It fixes a number of design problems that Squirrel has.");my$handlers=shift->_handlers;unshift @_,$handlers->{backend};goto &{$handlers->{import}}}sub unimport {my$handlers=shift->_handlers;unshift @_,$handlers->{backend};goto &{$handlers->{unimport}}}1;
SQUIRREL

$fatpacked{"Squirrel/Role.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SQUIRREL_ROLE';
  package Squirrel::Role;use strict;use warnings;use base qw(Squirrel);sub _choose_backend {if ($INC{"Moose/Role.pm"}){return {backend=>'Moose::Role',import=>\&Moose::Role::import,unimport=>\&Moose::Role::unimport,}}else {require Mouse::Role;return {backend=>'Mouse::Role',import=>\&Mouse::Role::import,unimport=>\&Mouse::Role::unimport,}}}1;
SQUIRREL_ROLE

$fatpacked{"Test/Mouse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MOUSE';
  package Test::Mouse;use Mouse::Exporter;use Mouse::Util qw(does_role find_meta);use Test::Builder;Mouse::Exporter->setup_import_methods(as_is=>[qw(meta_ok does_ok has_attribute_ok with_immutable)],);my$Test=Test::Builder->new;sub meta_ok ($;$) {my ($class_or_obj,$message)=@_;$message ||= "The object has a meta";if (find_meta($class_or_obj)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub does_ok ($$;$) {my ($class_or_obj,$does,$message)=@_;$message ||= "The object does $does";if (does_role($class_or_obj,$does)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub has_attribute_ok ($$;$) {my ($class_or_obj,$attr_name,$message)=@_;$message ||= "The object does has an attribute named $attr_name";my$meta=find_meta($class_or_obj);if ($meta->find_attribute_by_name($attr_name)){return$Test->ok(1,$message)}else {return$Test->ok(0,$message)}}sub with_immutable (&@) {my$block=shift;my$before=$Test->current_test;$block->();$_->meta->make_immutable for @_;$block->();return if not defined wantarray;my$num_tests=$Test->current_test - $before;return!grep{!$_}($Test->summary)[-$num_tests .. -1]}1;
TEST_MOUSE

$fatpacked{"ouse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OUSE';
  package ouse;use Mouse::Util;my$package='Class';sub import {$package=$_[1]|| 'Class';if ($package =~ /^\+/){$package =~ s/^\+//;Mouse::Util::load_class($package)}}use Filter::Simple sub {s/^/package $package;\nuse Mouse;\nuse Mouse::Util::TypeConstraints;\n/};1;
OUSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use utf8;
use 5.008005;

{
    package Point;
    use Mouse;
    has x => (is => 'rw');
    has y => (is => 'rw');
    sub distance {
        my $self = shift;
        sqrt( $self->x ** 2 + $self->y ** 2 );
    }
    no Mouse;
}

print Point->new(x => 1, y => 1)->distance;
